#! /usr/local/bin/PikaCmd

/*
	Future:

	*)	Allow complex sequences (alts, opts etc) inside arrays too.

	*)	Allow a rule to be a key-value sequence, not only value (and complete structs) (for "inserts").

	*)	Checkpoint logic is kind of broken... tag groups are global, so we need checkpoints e.g.
		before entering alts (or a failed checkpoint could break the first alt path). If tag groups
		where per structural level of the schema this would not be a problem I think.

		So this doesn't work right now:

		    params: {
		        ( action: <action> | actionVariable: <var> )
		        [ params: <params> | paramsVariable: <var> ]
		    }

*/

include('systools.pika');

        ::run.root = 'examples/';

include('stdlib.pika');
include('debug.pika');
include('initPPEG.pika');
include('objects.pika');

calcLineAndColumn = function {
	args(@source, @offset, @line, @column);
	l = 0;
	lb = 0;
	for (i = 0; i <= offset; i += find(source{i:}, "\n") + 1) {
		lb = i;
		++l;
	};
	[line] = l;
	[column] = (offset - lb) + 1;
};

formatError = function {
	args(@source, @offset, @message);
	calcLineAndColumn(source, offset, @line, @column);
	// FIX : how?
/*	print("--------");
	s = (if (offset - 200 > 0) '...' else '')
		# source{offset - 200:200}
		# ' <!!!!> '
		# source{offset:200}
		# (if (offset + 200 < length(source)) '...' else '');
	print(s);
	print("--------");*/
	( bake("Line: {line}, column: {column} (@{offset}) {message}") )
};

createSchemaParser = function {
	print('Compiling Schema parser...');
	cushySchemaSource = load(::run.root # 'cushySchema.ppeg');
	ok = ppeg.compileFunction(cushySchemaSource, @schemaParser, @offset);
	if (!ok) {
		throw(formatError(cushySchemaSource, offset, bake("Error compiling Cushy Schema parser")));
	};

	print('Parsing Schema...');
	cushySchemaSource = load(::run.root # 'cushySchemaTest.schema');
	ok = schemaParser(cushySchemaSource, @schema, @offset);
	if (!ok) {
		throw(formatError(cushySchemaSource, offset, bake("Error parsing Cushy Schema")));
	};

	print('Compiling PEGs...');
	pegSource = '';
	foreach([schema].pegs, >pegSource #= $1 # ' <- ' # $2 # LF);
	ok = ppeg.compileFunction(pegSource, @[schema].pegParsers, @offset);
	if (!ok) throw(bake("Error parsing Schema PEGs"));

	errorCount = 0;

	print('Checking Schema references...');
	iterate([schema].refs, >{
		offset = [$2].offset;
		name = [$2].name;
		kind = [$2].kind;
		container = (if (kind === 'rule') [schema].rules else [schema].pegs);
		if (!exists(@[container][name])) {
			print(formatError(cushySchemaSource, offset, bake("{if (kind === 'rule') 'rule' else 'peg'} {name} is missing")));
			++errorCount;
		}
	});

	if (errorCount != 0) {
		throw("One or more errors occured");
	};

	gc();

	( schema )
};

if (false) {	// all alternatives (text implementation)
	createError = function {
		args(@message, @node);
		if (node == void) {
			( message )
		} else {
			calcLineAndColumn(cushySource, [node].begin, @line, @column);
			( bake("{message} at line: {line}, column: {column}") )
		}
	};

	createEmptyError = function { ( '' ) };

	joinErrors = function {
		args(@prior, @current);
		exists = false;
	//	tokenize(prior, >if ($0 === current) exists = true);
		if (!exists) {
			if (prior !== '') prior #= "\n";
			prior #= current;
		};
		( prior )
	};

	errorToString = function {
		s = '';
		tokenize($0, >s #= (if (s !== '') "  or ") # $0 # LF);
		( chop(s, 1) )
	}
} else if (false) {	// just the alternative that parsed the most text
	createError = function { ( new(Container, 'message', $0, 'node', $1, 'score', 0) ) };

	createEmptyError = function { ( void ) };

	joinErrors = function {
		args(@prior, @current);
		if (prior == void || [[prior].node].begin < [[current].node].begin) ( current ) else ( prior )
	};

	errorToString = function {
		args(@err);
		calcLineAndColumn(cushySource, [[err].node].begin, @line, @column);
		( bake("{[err].message} at line: {line}, column: {column}") )
	}
} else if (false) {	// all as array
	createError = function {
		( new(Array, new(Container, 'message', $0, 'node', $1, 'prior', void, 'score', 0)) )
	};

	createEmptyError = function { ( new(Array) ) };

	joinErrors = function {
		args(@prior, @current);
		joined = new(Array);
		inject(prior, 0, [prior].n, joined, 0);
		inject(current, 0, [current].n, joined, [joined].n);
		( joined )
	};

	errorToString = function {
		args(@err);
		e = [err][0];
		calcLineAndColumn(cushySource, [[e].node].begin, @line, @column);
		s = bake("{[e].message} {[e].score} at line: {line}, column: {column}");
		for (i = 1; i < [err].n; ++i) { e = [err][i]; s #= bake("\n  or {[e].message} {[e].score}"); };
		( s )
	}	
} else if (true) {
	NO_ERROR = void;
	createError = function { ( new(Array, new(Container, 'message', $0, 'node', $1, 'score', $2)) ) };
	createEmptyError = function { new(Array) };
	createMissingValueError = function { createError('missing value', void, $0) };

	joinErrors = function {
		args(@prior, @current);
		if ([prior].n == 0) {
			( current )
		} else if ([[current][0]].score > [[prior][0]].score) {
//print(errorToString(current));
//print("  has higher prio than:  ");
//print(errorToString(prior));
//print("");
			( current )
		} else if ([[current][0]].score < [[prior][0]].score) {
//print(errorToString(current));
//print("  has lower prio than:  ");
//print(errorToString(prior));
//print("");
			( prior )
		} else {
//print(errorToString(current));
//print("  has same prio as:  ");
//print(errorToString(prior));
//print(" == ");
			joined = new(Array);
			inject(prior, 0, [prior].n, joined, 0);
			inject(current, 0, [current].n, joined, [joined].n);
//print(errorToString(joined));
//print("");
			( joined )
		}
	};

	errorToString = function {
		args(@err);
/*
		offsets.n = 0;
		iterate(err, >{
			offset = [[$2].node].begin;
			if (!exists(@errByOffsets[offset].n)) append(@offsets, offset);
			append(@errByOffsets[offset], $2);
		});
		sort(@offsets);
		s = '';
		iterate(@offsets, >{
			offset = $2;
			calcLineAndColumn(cushySource, offset, @line, @column);
			l = '';
			iterate(@errByOffsets[offset], >{
				if (l !== '') l #= " or ";
				l #= [$2].message;
			});
			if (s !== '') s #= "\n  or ";
			s #= bake("Line: {line}, column: {column} (@{offset}): {l}");
		});
		( s )*/

		s = '';
		iterate(err, >{
			offset = [[$2].node].begin;
			message = [$2].message;
			calcLineAndColumn(cushySource, offset, @line, @column);
			l = bake("Line: {line}, column: {column} (@{offset}): {message}");
			if (!exists(@gotLines[l])) {
				gotLines[l] = true;
				if (s !== '') s #= "\n  or ";
				s #= l;
			}
		});
		( s )
	}	
};

countMembers = function { n = 0; foreach($0, >++n); ( n ) };

// crossList will contain every property *found* and checked in the validating struct, false = key was found, but not included in the successful branch
validateKVAlts = function {
	args(@node, @elem, @crossList, @score);

	// FIX: Q & D, must resolve checkpoint errors first
	error = checkpoint();
	if (error == NO_ERROR) {
		error = createEmptyError();
		alts = [elem].seqs;
		bestCount = 0;
		for ({ i = 0; n = [alts].n }; i < n && error != NO_ERROR; ++i) {
			foreach(@altCrossList, >[$0] = false);	// all found properties from last attempt is now considered invalid (but still found for slightly better error reports)
			altScore = [score];
			altError = validateKVSequence(node, [alts][i], @altCrossList, @altScore);
			if (altError == NO_ERROR) altError = checkpoint();
			error = (if (altError == NO_ERROR) NO_ERROR else joinErrors(error, altError));
		};
		clone(@altCrossList, crossList);
		[score] = altScore;
	};
	( error )
};

validateKVOpt = function {
	args(@node, @elem, @crossList, @score);
	optScore = [score];
	error = validateKVSequence(node, [elem].seq, @optCrossList, @optScore);
	if (error == NO_ERROR) {
		clone(@optCrossList, crossList);
		[score] = optScore;
	} else if (countMembers(@optCrossList) == 0) {
		error = NO_ERROR;
	};
	( error )
};

validateUnmatched = function {
	args(@node, @elem, @crossList, @score);

	error = NO_ERROR;
	foreach([node].value, >if (error == NO_ERROR && !exists(@[crossList][$1])) {
		[crossList][$1] = true;
		++[score];
		error = validateValue($2, [elem].template, score);
	});
	( error )
};

validateKV = function {
	args(@node, @elem, @crossList, @score);

	key = [elem].key;
	value = [elem].value;
	if (!exists(r = @[[node].value][key])) {
		error = createError(bake("missing '{key}' property"), node, [score]);
	} else {
		[crossList][key] = true;
		++[score];
		if (value == void) {
			if ([[r]].type != 'void') error = createError('expected no value', [r], [score])
			else error = NO_ERROR;
		} else {
			error = validateValue([r], value, score);
		}
	};
	( error )
};

map(@KV_SEQ_VALIDATORS
		, 'kv', validateKV
		, 'opt', validateKVOpt
		, 'alts', validateKVAlts
		, 'unmatched', validateUnmatched);

validateKVSequence = function {
	args(@node, @sequence, @crossList, @score);
	error = NO_ERROR;
	for ({ i = 0; n = [sequence].n }; i < n && error == NO_ERROR; ++i) {
		elem = [sequence][i];
		error = KV_SEQ_VALIDATORS[[elem].kind](node, elem, crossList, score);
	};
	( error )
};

validateStruct = function {
	args(@node, @rule, @score);
	if (node == void) ( createMissingValueError(score) )
	else if ([node].type !== 'struct') {
		error = createError(bake("expected struct (not {TYPE_DESCS[[node].type]})"), node, [score]);
	} else {
		error = validateKVSequence(node, [rule].seq, @crossList, score);
		if (error == NO_ERROR) {
			foreach([node].value, >{
				if (error == NO_ERROR && (!exists(@crossList[$1]) || !crossList[$1])) {
					error = createError(bake("unexpected '{$1}' property"), node, [score]);
				}
			})
		};
		if (error == NO_ERROR) error = checkpoint();
	};
	( error )
};

validateList = function {
	args(@node, @rule, @score);
	if (node == void) ( createMissingValueError(score) )
	else if ([node].type !== 'array') {
		error = createError(bake("expected array (not {TYPE_DESCS[[node].type]})"), node, [score]);
	} else {
		a = [node].value;
		v = [rule].values;
		n = [v].n;
		if ([a].n > n) {
			error = createError(bake("expected max {n} array elements (got {[a].n})"), node, [score]);
		} else {
			error = NO_ERROR;
			for (i = 0; i < n && error == NO_ERROR; ++i) {
				e = [v][i];
				// FIX : sep loops
				if (i >= [a].n) {
					if (validateValue(void, e, @dummy, score) != NO_ERROR) {
						error = createError(bake("missing array element(s)"), node, [score]);
					}
				} else {
					error = validateValue([a][i], e, score)
				}
			};
			if (error == NO_ERROR) error = checkpoint();
		};
	};
	( error )
};

validateArray = function {
	args(@node, @rule, @score);
	if (node == void) ( createMissingValueError(score) )
	else if ([node].type !== 'array') {
		error = createError(bake("expected array (not {TYPE_DESCS[[node].type]})"), node, [score]);
	} else {
		a = [node].value;
		t = [rule].template;
		error = NO_ERROR;
		for ({ i = 0; n = [a].n }; i < n && error == NO_ERROR; ++i) {
			error = validateValue([a][i], t, score);
			if (error == NO_ERROR) error = checkpoint();
		};
	};
	( error )
};

validateRule = function { ( validateValue($0, [[schema].rules][[$1].name], $2) ) };

validatePeg = function {
	args(@node, @rule, @score);
	if (node == void) ( createMissingValueError(score) )
	else if ([node].type !== [rule].type) {
		( createError(bake("expected {TYPE_DESCS[[rule].type]} (not {TYPE_DESCS[[node].type]})"), node, [score]) )
	} else if ([rule].peg == void
			|| ([schema].pegParsers([node].value, @dummy, @offset, [rule].peg)
			&& offset >= length([node].value))) {
		( NO_ERROR )
	} else {
		( createError(bake("expected valid '{[rule].peg}' (not '{[node].value}')"), node, [score]) )
	}
};

validateOpt = function {
	args(@node, @rule, @score);
	(if (node == void) NO_ERROR else validateValue(node, [rule].value, score))
};

validateAlts = function {
	args(@node, @rule, @score);	
	
	// FIX: Q & D, must resolve checkpoint errors first
	error = checkpoint();
	if (error == NO_ERROR) {
		alts = [rule].values;
		error = createEmptyError();
		for ({ i = 0; n = [alts].n }; i < n && error != NO_ERROR; ++i) {
			altScore = [score];
			altError = validateValue(node, [alts][i], @altScore);
			if (altError == NO_ERROR) altError = checkpoint();
			if (altError == NO_ERROR) {
				[score] = altScore;
				error = NO_ERROR;
			} else {
				error = joinErrors(error, altError);
			}
		}
	};
	( error )
};

map(@TYPE_DESCS, 'string','quoted string', 'text','unquoted value', 'struct','struct'
		, 'array','array', 'void','void / no value');

validateLiteral = function {
	args(@node, @rule, @score);
	if (node == void) ( createMissingValueError(score) )
	else if ([node].type !== [rule].type) {
		( createError(bake("expected {TYPE_DESCS[[rule].type]} (not {TYPE_DESCS[[node].type]})"), node, [score]) )
	} else if ([node].value !== [rule].literal) {
		( createError(bake("expected '{[rule].literal}' (not '{[node].value}')"), node, [score]) )
	} else {
		( NO_ERROR )
	}
};

validateAny = function {
	args(@node, @rule, @score);
	if (node == void) ( createMissingValueError(score) )
	else ( NO_ERROR )
};

checkpoint = function {
	clone(@::tagGroups, @myTagGroups);
	prune(@::tagGroups);
	error = NO_ERROR;
	foreach(@myTagGroups, >{
		if (error == NO_ERROR) {
			group = $1;
			tg = $2;
			groupScore = [tg].score;
			error = validateValue(tg, [[schema].rules][group], @groupScore);
			if (error == NO_ERROR) error = checkpoint();
		}
	});
foreach(@::tagGroups, >assert(false));
	( error )
};

validateTag = function {
	args(@node, @rule, @score);
	if (node == void) ( createMissingValueError(score) )
	else {
		error = NO_ERROR;
		group = [rule].group;
		tag = [rule].tag;
		tg = coalesce(@::tagGroups[group]);
		if (tg != void && [tg].opener === tag) {
			error = checkpoint();
			tg = void;
		};
		if (error == NO_ERROR) {
			if (tg == void) {
				tg = new(Container, 'type', 'struct', 'opener', tag, 'score', [score]
						, 'begin', [node].begin, 'end', [node].end, 'value', new(Container));
				::tagGroups[group] = tg;
			};
			[tg].begin = min([tg].begin, [node].begin);
			[tg].end = max([tg].end, [node].end);
			[[tg].value][tag] = node;
		};

		( error )
	}
};

/*
#	Value =
#		{ kind: 'struct', seq: KVSequence }			// numbstrict type must be struct
#		| { kind: 'array', template: Value }		// numbstrict type must be array (0 or more matches)
#		| { kind: 'list', values: [ Value, ... ] }	// numbstrict type must be array (exact length or less if last items are optional)
#		| { kind: 'rule', name: string }
#		| { kind: 'literal', literal: string }		// numbstrict type must be string or text
#		| { kind: 'text', peg: peg|void }			// numbstrict type must be text, void = match any
#		| { kind: 'string', peg: peg|void }			// numbstrict type must be string, void = match any
#		| { kind: 'opt', value: Value }
#		| { kind: 'alts', values: [ Value, ... ] }
#		| { kind: 'any' }							// anything goes!
#		| { kind: 'tag', group: string, tag: string }				// collect value and check against group rule
*/


map(@VALIDATORS
		, 'struct', validateStruct
		, 'array', validateArray
		, 'list', validateList
		, 'rule', validateRule
		, 'literal', validateLiteral
		, 'peg', validatePeg
		, 'opt', validateOpt
		, 'alts', validateAlts
		, 'any', validateAny
		, 'tag', validateTag
		);

validateValue = function { ( VALIDATORS[[$1].kind]($0, $1, $2) ) };

schema = void;
parsedCushy = void;
gc();
schema = createSchemaParser();

cushySource = load(::run.root # 'test.cushy');

print('Compiling Numbstrict parser...');
numbstrictSource = load(::run.root # 'numbstrictMeta.ppeg');
ok = ppeg.compileFunction(numbstrictSource, @numbstrictParser, @offset);
if (!ok) {
	throw(formatError(numbstrictSource, offset, bake("Error compiling Numbstrict parser")));
};

print("Parsing Numbstrict...");
ok = numbstrictParser(cushySource, @parsedCushy, @offset);
if (!ok) {
	throw(formatError(cushySource, offset, bake("Error parsing Numbstrict")));
};
gc();

print("Validating...");
score = 0;
error = validateValue(parsedCushy, [[schema].rules].root, @score);
if (error != NO_ERROR) {
	print('!!!! ' # errorToString(error));
} else {
	print('Validation OK');
};
gc();
