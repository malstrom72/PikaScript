// IDEA: same as blahblah in location to copy reactions for doors etc
// IDEA: write a or b (random argument, also for change etc) + write a or go to b (random statement)
// IDEA: if x is y then change it to z (it refers to last variable)
// IDEA: don't sort teleport locations and allow teleport to <number> directly on command... and find a shorter command than "teleport to"
// IDEA: flag / unflag booleans like "player has trousers" so that we can do "if player has no trousers then write Oh my gosh you have no trousers on!" (the boolean in this example is "player trousers = false|true")
// IDEA: "secret: " in front of reactions that should never be auto-suggested
// IDEA: when going to a new location after writing something always wait for a "(press enter)"
// IDEA: accept "and" without specifying the "verb" e.g. 'write "x" and "y"' or 'change x to y and a to b'
//
// TODO: bug when declaring something as a synonym when there is already an action defined using that something... saving and loading fixes it
// TODO: ignores and synonyms should be overridable by explicit actions in locations. We should drop the concept of a processed-action-map and just have an array that we match intelligently.
// TODO: resolve shouldn't be interactive cause we can't use it for loading game... it should throw ambiguous thingy and somehow on catch and display the ambigious alternatives
//		- or maybe, pika is ok as "persistent" game language
//		- alt. have yet another "persistent" language that the natural style language gets converted into, and it in turn converts to pika
//		- dropped the interactive place resolving entirely for now, but want to solve this better, e.g. keeping track of the source range of a reference and actually update the source code on resolve
//		- doing that now, but should update code also after interactive resolving when loading an adventure that contains an ambiguous reference
// TODO: synonymWords and ignoreWords should be same list and synonyms should be able to replace ignores and vice versa
// TODO: prevent recursion with global actions
// TODO: when a reaction isn't defined allow it to be defined immediately (so we can define reactions when writing room scripts for example)
// TODO: action for "no reaction" that gets executed when no reaction defined (instead of writing "can't do that" in english)
// TODO: multi-word synonyms
// TODO : place all language text in separate file, ideally also with ppeg for command parsing
// TODO : ppeg for parsing save files instead of manual parsing
// TODO : always should be a input directive only, not part of script semantics
// TODO : reload command just as we have resave
//
// DONE: carry out action as soon as defined (first time)
// DONE: have a nice source text file format (instead?) for the adventure ... interactive only gets you so far.
// DONE: scripts that always run in locations to print conditional texts etc (what should we call these?)
// DONE : when reprocessing after synonym or ignore we need to keep all old actions in case we use them from other scripts, in the future we should either simply compile all scripts to see if an action is in use or even better: recompile all scripts and replace action references with reprocessed versions.
//		- did it differently: saving and using original unprocessed texts and then reprocess them (only for fast lookup) whenever synonyms/ignores change
// DONE: dry-run a script to see if it does anything, and if it doesn't, don't include in "automatic suggestions" (hides a few secrets that way)
// DONE: keep track of possible variable values and list them as well as initial value etc on "what is"
//		- sort of
// DONE: a variable should have hard defined states that you can choose from or enter a new state when using it (sort of like locations). Perhaps just list the possible alternatives (they usually aren't many) on a line when you enter a non-existent state in code, with the alternative of creating a new state if it was intentional.
// DONE: suggest a lot more things in creation mode (like we do with rooms/places now), e.g. when performing an action, do a similarity lookup and suggest stuff. Also when setting/checking variables, suggest variable names and values too (with an option to add a value)
// DONE: if x is y or z (short for if x is y or x is z)
// DONE: "note that x is y" instead of / alternative to "change x to y"... works better for the flag / unflag idea too ("note that x has y").


/*
	places: [
		[number]: {
			.name: 'name'
			.description: 'text'
			.actions: {
				'action': {
					'script'
					.original: 'action'
					.$pika: function { /* compiled code * / }
				}
				...
			}
		}
		...
	]
	vars: {
		'name': {
			'current'
			.init: 'state'
			.states: {
				'state': true
				...
			}
		}
	}
*/


// include('debug.pika');
include('stdlib.pika');
include('lab/parsing.pika');

WRAP_COLUMN = 80;

ok = ppeg.compileFunction(load('lab/advScript.ppeg'), @scriptParser);
if (!ok) throw("Error compiling the command parser");

map(@LANGS.english
	, 'playModeHelp', "Special commands in play mode:\n"
			# "\n"
			# "  load <filename> - loads an adventure\n"
			# "  restart - resets game\n"
			# "  create - starts creation mode\n"
			# "  quit - quits program\n"
			# "  language <language> - change user interface language\n"
	, 'createModeHelp', "Special commands in create mode:\n"
			# "\n"
			# "  load <filename> - loads an adventure\n"
			# "  restart - resets game\n"
			# "  play - starts play mode\n"
			# "  quit - quits program\n"
			# "  change [reaction] - edits the reaction for last written input\n"
			# "  change reaction for <input> - edits the reaction on <input>\n"
			# "  change name - edits the name of the location\n"
			# "  change text - edits the description of the location\n"
			# "  change script - edits the script of the location\n"
			# "  change <variable> to <state>\n"
			# "  <word> = <word> - adds a synonym\n"
			# "  ignore <word> - adds a word to the ignore list\n"
			# "  list variables - show all declared variables\n"
			# "  list reactions - show reactions of current location\n"
			# "  list locations - show all locations in the game\n"
			# "  teleport to <location>\n"
			# "  save [<filename>] - saves the adventure\n"
			# "  autosync (on | off) - enables or disables automatic loading and saving of file\n"
			# "  language <language> - change user interface language\n"
	, 'scriptHelp', "Possible instructions are:\n"
			# "\n"
			# "  write <text>\n"
			# "  go [to] <location name>\n"
			# "  (change | set) [the] <variable> to <value> | make [the] <variable> <value>\n"
			# "  if [the] <variable> is [not] <value> [and | or ...] [then] <command> [otherwise ...]\n"
			# "  describe [location]\n"
			# "  [same as] <action>\n"
			# "\n"
			# "Chain multiple instructions with \"and\" (after \"if\") or \"also\"\n"
			# "Type \"always\" before the instruction to define a global reaction used everywhere."
	, 'variableDoesNotExist', "The variable {quote(var)} does not exist, do you wish to create it (no)? "
	, 'initialState', "Should the initial state of {quote(var)} be {quote(state)} (yes)? "
	, 'knownVariables', "The following variables are defined:"
	, 'enterVariableName', "Enter variable name or number (leave empty to cancel): "
	, 'unknownState', "{quote(state)} is not a known state for {quote(var)}, do you wish to add it (no)? "
	, 'validStates', "The following are known states for {quote(var)}:"
	, 'enterState', "Enter state or number (leave empty to cancel): "

	, 'noPlaceWithName', "No location with the name {quote(name)} exists. Create a new location with that name (no)? "
	, 'knownPlaces', "The following locations exist:"
	, 'enterLocation', "Enter location name or number (leave empty to cancel): "
	, 'nearlyMatch', "When you say {quote(written)}, do you mean {quote(match)} (yes)? "
	, 'unknownReaction', "I don't know what you mean with {quote(written)}."
	, 'exception.unknownLocation', "Unknown location."
	, 'exception.unknownReaction', "Unknown reaction."
	, 'exception.unknownVariable', "Unknown variable."
	, 'exception.unknownState', "Unknown variable state."
	, 'exception.userCancelled', "User cancelled."

	, 'badScriptBackToGame', "I didn't understand those instructions. Never mind then. Back to the game."
	, 'badScriptTryAgain', "I didn't understand those instructions. Please try again."
	, 'backToTheGame', " Back to the game."
	, 'globalReactionDefined', "OK. (Global reaction defined.)"
	, 'globalReactionDeleted', "OK. (Global reaction deleted.)"
	, 'localReactionDefined', "OK. (Local reaction defined.)"
	, 'localReactionDeleted', "OK. (Local reaction deleted.)"
	, 'ok', "OK"
	, 'unknownAction', "I don't know the reaction for {quote(action)}. Please tell me what should happen (or leave empty to cancel)."
	, 'youCantDoThat', "You can't do that."
	, 'beMoreSpecific', "Please be more specific."
	, 'undescribedLocation', "I don't know anything about this location yet. Do you wish to describe it (no)? "
	, 'descriptionInput', "description> "
	, 'youMayEnterDescription', "You may now enter a script to run when this description is displayed. Leave empty for no script."
	, 'undefinedLocation', "I don't know anything about this location yet."
	, 'doYouWantTo', "{action} (no)? "

	, 'youHaveNotDoneAnythingYet', "You haven't done anything yet."
	, 'changeReaction', "You are about to replace the reaction for {quote(action)} in {quote(capitalize(locationName))}. The previous reaction was:"
	, 'noSuchReactionExists', "No such reaction is defined."
	, 'leaveEmptyToCancel', "Leave empty to cancel. Write \"delete\" to delete."
	, 'delete', "delete"
	, 'replaceDescription', "You are about to replace the description of {quote(capitalize(locationName))}. Leave empty to cancel."
	, 'changedText', "Changed description."
	, 'cancelled', "Cancelled."
	, 'newNameForLocation', "New name for {quote(capitalize(locationName))}. Leave empty to cancel."
	, 'nameInput', "name> "
	, 'changedNameTo', "Changed name to {quote(capitalize(newName))}"
	, 'doNotUnderstand', "I do not understand."

	, 'replaceScriptFor', "You are about to replace the script for {quote(capitalize(locationName))}. The previous script was:"
	, 'createScriptFor', "You are about to create a script for {quote(capitalize(locationName))}."
	, 'definedSynonym', "Defined synonym: {word} = {isSynonymOf}"
	, 'ignoringWord', "Ignoring: {word}"
	, 'enteringPlayMode', "Entering play mode."
	, 'enteringCreateMode', "Entering create mode."
	, 'changedLanguageTo', "Changed language to {language}."
	, 'unknownLanguage', "Language {language} is unknown."
	, 'globalReactions', "Global reactions"
	, 'duplicatesWarning', "Warning! The following reactions will be replaced."
	, 'continueReplacement', "Do you wish to continue (no)? "

	, 'scriptInput', "script> "
	, 'yesFirstChar', "y"
	, 'noFirstChar', "n"
	, 'autoLoaded', "  (auto loaded)"
	, 'autoSaved', "  (auto saved)"
	, 'pleaseUseLoadCommandFirst', "Please use the \"load\" or \"save\" command first."
	, 'autoSyncEnabledFor', "Automatic file synchronization enabled for {fn}."
	, 'autoSyncDisabled', "Automatic file synchronization disabled."
	, 'savedTo', "Saved to {fn}"
	, 'loadedFrom', "Loaded {fn}"

	, 'loadCommand', "load {*}"
	, 'reloadCommand', "load"
	, 'restartCommand', "restart"
	, 'createCommand', "create"
	, 'playCommand', "play"
	, 'quitCommand', "quit"
	, 'languageCommand', "language {*}"
	, 'changeCommand', "change"
	, 'changeReactionCommand', "change reaction"
	, 'changeReactionToCommand', "change reaction for {*}"
	, 'changeNameCommand', "change name"
	, 'changeTextCommand', "change text"
	, 'changeScriptCommand', "change script"
	, 'synonymCommand', "{*}={*}"
	, 'ignoreCommand', "ignore {*}"
	, 'listReactionsCommand', "list reactions"
	, 'listVariablesCommand', "list variables"
	, 'listLocationsCommand', "list locations"
	, 'saveCommand', "save {*}"
	, 'resaveCommand', "save"
	, 'autoSyncOnCommand', "autosync on"
	, 'autoSyncOffCommand', "autosync off"
	, 'changeVariableCommand', "change {*} to {*}"
	, 'teleportCommand', "teleport to {*}"
);

map(@LANGS.swedish
	, 'playModeHelp', "Speciella kommandon i spelläge:\n"
			# "\n"
			# "  ladda <filnamn> - laddar ett äventyr\n"
			# "  omstart - startar om spelet\n"
			# "  skapa - byter till skaparläge\n"
			# "  avsluta - avslutar programmet"
	, 'createModeHelp', "Speciella kommandon i skaparläge:\n"
			# "\n"
			# "  ladda <filnamn> - laddar ett äventyr\n"
			# "  omstart - startar om spelet\n"
			# "  spela - startar spelläge\n"
			# "  avsluta - avslutar programmet\n"
			# "  ändra [reaktion] - editerar reaktion för senast skrivna mening\n"
			# "  ändra reaktion för <input> - ändrar reaktion för <input>\n"
			# "  ändra namn - ändrar namn på platsen\n"
			# "  ändra text - ändrar beskrivning på platsen\n"
			# "  ändra manus - ändrar manus på platsen\n"
			# "  ändra <variabel> till <tillstånd>\n"
			# "  <ord> = <ord> - lägger till ett ord på synonymlistan\n"
			# "  ignorera <ord> - lägger till ett ord på ignoreringslistan\n"
			# "  lista variabler - visar en lista på alla deklarerade variabler\n"
			# "  lista reaktioner - visar reaktioner för nuvarande plats\n"
			# "  lista platser - listar alla platser i spelet\n"
			# "  teleportera till <plats>\n" 
			# "  spara [<filnamn>] - sparar äventyret\n"
			# "  autosynk (på | av) - slår på eller av automatisk laddning och sparning av fil\n"
			# "  language <language> - change user interface language\n"	// always english for these
	, 'scriptHelp', "Möjliga instruktioner är:\n"
			# "\n"
			# "  skriv <text>\n"
			# "  gå [till] <plats>\n"
			# "  (ändra | sätt) <variabel> till <värde> | gör <variabel> <värde>\n"
			# "  om <variabel> [inte] är <värde> [och | eller ...] [så] <command> [annars [så] ...]\n"
			# "  beskriv [platsen]\n"
			# "  samma som <aktion>\n"
			# "\n"
			# "Kedja flera instruktioner med \"och\" (efter \"om\") eller \"samt\"\n"
			# "Skriv \"alltid: \" före instruktionen för att definiera en reaktion som används överallt."
	, 'variableDoesNotExist', "Variabeln {quote(var)} finns ej, vill du skapa den (nej)? "
	, 'initialState', "Ska det ursprungliga tillståndet för {quote(var)} vara {quote(state)} (ja)? "
	, 'knownVariables', "Följande variabler är definierade:"
	, 'enterVariableName', "Mata in variabelnamn eller nummer (lämna tomt för att avbryta): "
	, 'unknownState', "{quote(state)} är inte ett känt tillstånd för {quote(var)}, vill du lägga till det (nej)? "
	, 'validStates', "Följande är kända tillstånd för {quote(var)}:"
	, 'enterState', "Mata in tillstånd eller nummer (lämna tomt för att avbryta): "

	, 'noPlaceWithName', "Det finns ingen plats som heter {quote(name)}. Vill du skapa en ny plats med det namnet (nej)? "
	, 'knownPlaces', "Följande platser existerar:"
	, 'enterLocation', "Mata in platsens namn eller nummer (lämna tomt för att avbryta): "
	, 'nearlyMatch', "När du skriver {quote(written)}, menar du {quote(match)} (ja)? "
	, 'unknownReaction', "Jag vet inte vad du menar med {quote(written)}."
	, 'exception.unknownLocation', "Okänd plats."
	, 'exception.unknownReaction', "Okänd reaktion."
	, 'exception.unknownVariable', "Okänd variabel."
	, 'exception.unknownState', "Okänt tillstånd för variabel."
	, 'exception.userCancelled', "Användaren avbröt."

	, 'badScriptBackToGame', "Jag förstod inte dessa instruktioner. Strunt samma. Tillbaka till spelet."
	, 'badScriptTryAgain', "Jag förstod inte dessa instruktioner. Vänligen försök igen."
	, 'backToTheGame', " Tillbaka till spelet."
	, 'globalReactionDefined', "OK. (Global reaktion definierad.)"
	, 'globalReactionDeleted', "OK. (Global reaktion borttagen.)"
	, 'localReactionDefined', "OK. (Lokal reaktion definierad.)"
	, 'localReactionDeleted', "OK. (Lokal reaktion borttagen.)"
	, 'ok', "OK"
	, 'unknownAction', "Jag känner inte till någon reaktion för {quote(action)}. Vänligen berätta vad som ska hända (eller lämna tomt för att avbryta)."
	, 'youCantDoThat', "Du kan inte göra det."
	, 'beMoreSpecific', "Vänligen formulera dig mer specifikt."
	, 'undescribedLocation', "Jag vet ingenting om den här platsen än. Vill du beskriva den (nej)? "
	, 'descriptionInput', "beskrivning> "
	, 'youMayEnterDescription', "Du har nu möjlighet att skriva ett manus som körs när beskrivningen visas. Lämna tomt för inget manus."
	, 'undefinedLocation', "Jag vet ingenting om den här platsen än."
	, 'doYouWantTo', "{action} (nej)? "

	, 'youHaveNotDoneAnythingYet', "Du har inte gjort någonting än."
	, 'changeReaction', "Du kommer nu att ersätta reaktionen på {quote(action)} i {quote(capitalize(locationName))}. Den förra reaktionen var:"
	, 'noSuchReactionExists', "Det finns ingen sådan reaktion definierad."
	, 'leaveEmptyToCancel', "Lämna tomt för att avbryta. Skriv \"ta bort\" för att ta bort."
	, 'delete', "ta bort"
	, 'replaceDescription', "Du kommer nu att ersätta beskrivningen för {quote(capitalize(locationName))}. Lämna tomt för att avbryta."
	, 'changedText', "Beskrivning ändrad."
	, 'cancelled', "Avbrutet."
	, 'newNameForLocation', "Nytt namn för {quote(capitalize(locationName))}. Lämna tomt för att avbryta."
	, 'nameInput', "namn> "
	, 'changedNameTo', "Ändrat namn till {quote(capitalize(newName))}"
	, 'doNotUnderstand', "Jag förstår inte."

	, 'replaceScriptFor', "Du kommer nu att ersätta manus för {quote(capitalize(locationName))}. Det förra manuset var:"
	, 'createScriptFor', "Du kommer nu att skapa ett manus för {quote(capitalize(locationName))}."
	, 'definedSynonym', "Definierad synonym: {word} = {isSynonymOf}"
	, 'ignoringWord', "Ignorerar: {word}"
	, 'enteringPlayMode', "Startar spelläge."
	, 'enteringCreateMode', "Startar skaparläge."
	, 'changedLanguageTo', "Changed language to {language}."	// always english for these
	, 'unknownLanguage', "Language {language} is unknown."	// always english for these
	, 'globalReactions', "Globala reaktioner"
	, 'duplicatesWarning', "Varning!! Följande reaktioner kommer ersättas."
	, 'continueReplacement', "Vill du fortsätta (nej)? "

	, 'scriptInput', "manus> "
	, 'yesFirstChar', "j"
	, 'noFirstChar', "n"
	, 'autoLoaded', "  (auto-laddat)"
	, 'autoSaved', "  (auto-sparat)"
	, 'pleaseUseLoadCommandFirst', "Vänligen använd \"ladda\" eller \"spara\" kommandot först."
	, 'autoSyncEnabledFor', "Automatisk filsynkronisering påslaget för {fn}."
	, 'autoSyncDisabled', "Automatisk filsynkronisering avstängt."
	, 'savedTo', "Sparat till {fn}"
	, 'loadedFrom', "Laddat {fn}"

	, 'loadCommand', "ladda {*}"
	, 'reloadCommand', "ladda"
	, 'restartCommand', "omstart"
	, 'createCommand', "skapa"
	, 'playCommand', "spela"
	, 'quitCommand', "avsluta"
	, 'languageCommand', "language {*}"	// always english for these
	, 'changeCommand', "ändra"
	, 'changeReactionCommand', "ändra reaktion"
	, 'changeReactionToCommand', "ändra reaktion för {*}"
	, 'changeNameCommand', "ändra namn"
	, 'changeTextCommand', "ändra text"
	, 'changeScriptCommand', "ändra manus"
	, 'synonymCommand', "{*}={*}"
	, 'ignoreCommand', "ignorera {*}"
	, 'listReactionsCommand', "lista reaktioner"
	, 'listVariablesCommand', "lista variabler"
	, 'listLocationsCommand', "lista platser"
	, 'saveCommand', "spara {*}"
	, 'resaveCommand', "spara"
	, 'autoSyncOnCommand', "autosynk på"
	, 'autoSyncOffCommand', "autosynk av"
	, 'changeVariableCommand', "ändra {*} till {*}"
	, 'teleportCommand', "teleportera till {*}"
);
defaults(@::lang, @LANGS.english);

//set(@::ignoreWords, '', 'the');
//map(@::synonymWords, 'examine','look' , 'run','go');

foreachDirect = function { f = $1; foreach($0, >if (span('.', $1) == 0) f($0, $1, $2)) };
quote = function { '"' # $0 # '"' };
capitalize = function { upper($0{0}) # lower($0{1:}) };

preprocessAction = function {
	args(@s);
	assert(>trim(s) == s);
	s = lower(s);
	x = '';
	tokenize(s, >{
		if (!exists(@::ignoreWords[$0])) {
			if (exists(p = @::synonymWords[$0])) {
				x #= [p] # ' '
			} else {
				x #= $0 # ' '
			}
		}
	}, WS);
	( chop(x, 1) )
};

chooseFromList = function {
	args(@header, @prompt, @list);
	print(header);
	print("");
	iterate(list, >print(repeat(' ', 4 - length($1+1)) # $1+1 # ') ' # $2));
	print("");
	choice = lower(trim(input(prompt)));
	if (classify(choice) === 'number') {
		choice = +choice;
		if (choice >= 1 && choice <= [list].n) {
			choice = [list][choice - 1];
		}
	};
	if (choice == '') {
		throw('userCancelled');
	};
	( choice )
};

getPlaceName = function {
	args(@number);
	( ::places[number].name )
};

confirm = function {
	args(@question, @defaultIsYes);
	answer = lower(trim(input(question)){0});
	if (defaultIsYes) ( answer !== [lang].noFirstChar )
	else ( answer === [lang].yesFirstChar )
};

wrap = function {
	s = '';
	tokenize($0, >{
		if (length(s # $0) < WRAP_COLUMN) s #= $0 # ' '
		else { print(chop(s, 1)); s = $0 # ' ' }
	}, WS);
	( chop(s, 1) )
};

scriptInput = function {
	for (; (s = input([lang].scriptInput)) == '?'; ) {
		print([lang].scriptHelp);
	};

	( s )
};

compileScript = function {
	args(@source, @compiler, @pika, @error);
	::compiler = compiler;
	success = false;
	[error] = try(>success = scriptParser(source, pika));
	( success )
};

editReaction = function {
	args(@action, @processed);

	s = trim(scriptInput());

	if (s == '') {
		( false )
	} else if (s == [lang].delete) {
		if (exists(r = @::places[::location].actions[processed])) {
			prune(r);
			print([lang].localReactionDeleted);
		} else if (exists(r = @::globalActions[processed])) {
			prune(r);
			print([lang].globalReactionDeleted);
		};
	} else {
		if (!compileScript(s, @::interactiveCompiler, @pika, @error)) {
			if (error == void) print([lang].badScriptBackToGame)
			else print(coalesce(@[lang].exception[error], error) # ' ' # [lang].backToTheGame);
			( false )
		} else {
			s = pika.updatedSource;
			if (pika.isGlobal) {
				::globalActions[processed] = s;
				::globalActions[processed].original = action;
				::globalActions[processed].$pika = pika;
				prune(@::places[::location].actions[processed]);
				print([lang].globalReactionDefined);
				autoSave();
				( true )
			} else {	// FIX : merge with above
				::places[::location].actions[processed] = s;
				::places[::location].actions[processed].original = action;
				::places[::location].actions[processed].$pika = pika;
				// prune(@::globalActions[processed]);
				print([lang].localReactionDefined);
				autoSave();
				( true )
			};
		}
	};
};

editScript = function {
	args(@loc);
	for (; {
		s = scriptInput();

		if (s == [lang].delete) {
			delete(@::places[loc].script);
			autoSave();
			print([lang].ok);

			( false )
		} else if (s === '') {
			( false )
		} else {
			if (!compileScript(s, @::interactiveCompiler, @pika, @error)) {
				if (error == void) print([lang].badScriptTryAgain)
				else print(error);

				( true )
			} else {
				::places[loc].script = pika.updatedSource;
				::places[loc].script.$pika = pika;
				autoSave();
				print([lang].ok);

				( false )
			};
		};
	}; );
};

simScore = function {
	args(@a, @b, @i, @j);
	s = 0;
	if (i < [a].n && j < [b].n) {
		for (o = i; o < [a].n; ++o) {
			s = max(s, (if ([a][o] === [b][j]) 1 else 0) + simScore(a, b, o + 1, j + 1));
		};
		for (o = j; o < [b].n; ++o) {
			s = max(s, (if ([b][o] === [a][i]) 1 else 0) + simScore(a, b, i + 1, o + 1));
		};
	};
	( s )
};

similarity = function {
	args(@a, @b);
	tokenize(a, >if ($0 != void) append(@wordsA, $0), WS);
	tokenize(b, >if ($0 != void) append(@wordsB, $0), WS);
	wordsA.n = min(wordsA.n, 7);	// sanity thing, takes forever otherwise...
	wordsB.n = min(wordsB.n, 7);
	( simScore(@wordsA, @wordsB, 0, 0) )
};

maybeAppendAction = function {
	args(@list, @action, @dryRunCheck);
	if (!dryRunCheck) {
		append(list, action);
	} else {
		::dryExecutor.willDoSomething = false;
		compileAndRunScript(action, @::passiveCompiler, @::dryExecutor);
		if (::dryExecutor.willDoSomething) {
			append(list, action);
		}
	}
};

/*
	`dryRunCheck` dry-runs scripts without actually writing / updating etc to check that an action is possible to
	perform before including it. This is used to prevent revealing some hidden yet-to-be-enabled actions.
*/
findActions = function {
	args(@action, @list, @dryRunCheck, @minScore);
	[list].n = 0;
	bestScore = minScore;
	if (exists(p = @::places[::location].actions[action])) {
		append(list, p);
		bestScore = +infinity;
	} else if (exists(p = @::globalActions[action])) {
		append(list, p);
		bestScore = +infinity;
	} else {
		foreachDirect(@::places[::location].actions, >{
			score = similarity($1, action);
			// print($1 # " = " # action # " : " # score);
			if (score > bestScore) {
				bestScore = score;
				[list].n = 0;
				maybeAppendAction(list, $0, dryRunCheck);
			} else if (score == bestScore) {
				maybeAppendAction(list, $0, dryRunCheck);
			}
		});
		foreachDirect(@::globalActions, >{
			if (!exists(@::places[::location].actions[$1])) {
				score = similarity($1, action);
				// print($1 # " = " # action # " : " # score);
				if (score > bestScore) {
					bestScore = score;
					[list].n = 0;
					maybeAppendAction(list, $0, dryRunCheck);
				} else if (score == bestScore) {
					maybeAppendAction(list, $0, dryRunCheck);
				}
			}
		});
	};
	( bestScore )
};

compileAndRunScript = function {
	args(@script, @compiler, @executor);
	::executor = executor;
	if (!exists(@[script].$pika)) {
		if (!compileScript([script], compiler, @[script].$pika, @error)) {
			throw(coalesce(error, "Could not compile script")); // FIX : not throw?
		};
	};
	evaluate([script].$pika);
};

wetExecutor.write = function {
	::didSomething = true;
	print(wrap($0));
};

wetExecutor.goto = function { ::didSomething = true; ::location = $0 };

wetExecutor.update = function { ::didSomething = true; ::vars[$0] = $[1 + floor(random($n - 1))] };

wetExecutor.describe = function {
	::didSomething = true;

	// FIX : sub
	print("");
	print(::places[::location].name);
	print(repeat('-', length(::places[::location].name)));
	print(wrap(::places[::location].description));

	script = @::places[::location].script;
	if (exists(script)) compileAndRunScript(script, @::passiveCompiler, @::wetExecutor);
};

wetExecutor.do = function {
	args(@act);
	a = preprocessAction(act);
	if (exists(p = @::places[::location].actions[a]) || exists(p = @::globalActions[a])) {
		compileAndRunScript(p, @::passiveCompiler, this());
	}
};

interactiveCompiler.resolveReaction = function {
	args(@written);

	reaction = void;
	processed = preprocessAction(written);
	if (processed !== '') {
		bestScore = findActions(processed, @solutions, false, 1);
		if (bestScore == +infinity) {
			reaction = [solutions[0]].original;
		} else if (solutions.n > 0) {
			for (i = 0; reaction == void && i < solutions.n; ++i) {
				match = [solutions[i]].original;
				if (confirm(bake([lang].nearlyMatch), true)) reaction = match;
			}
		}
	};

	if (reaction == void) {	// FIX : ugly double message here with the exception... ugly to use exceptions to begin with! try to set a variable in the parser instead that invalidates the result
		print(bake([lang].unknownReaction));
		throw('unknownReaction');
	};

	( reaction )
};

interactiveCompiler.resolveLocation = function {
	args(@name, @updatedName);
	for (; {
		name = capitalize(name);
		for (placeNumber = 0; placeNumber < ::places.n && ::places[placeNumber].name != name; ++placeNumber) ;
		if (placeNumber >= ::places.n) {
			if (name != '?' && confirm(bake([lang].noPlaceWithName), false)) {
				placeNumber = ::places.n;
				::places[::places.n].name = name;
				++::places.n;
			} else {
				choices.n = 0;
				iterate(@::places, >append(@choices, [$0].name));
				sort(@choices);
				name = chooseFromList([lang].knownPlaces, [lang].enterLocation, @choices);
			}
		};
		(placeNumber >= ::places.n);
	}; ) ;
	[updatedName] = name;

	( placeNumber )
};

interactiveCompiler.resolveVar = function {
	args(@var, @state, @updatedVar, @updatedState);
	assert(>var == lower(trim(var)));
	assert(>state == lower(trim(state)));
	for (; !exists(@::vars[var]); ) {
		if (::gameMode !== 'create') {
			throw('unknownVariable');
		};
		if (var !== '?' && confirm(bake([lang].variableDoesNotExist), false)) {
			if (confirm(bake([lang].initialState), true)) {
				initValue = state;
			} else {
				initValue = lower(trim(input([lang].enterState)));
				if (state == '') {
					throw('userCancelled');
				};
			};
			::vars[var] = initValue;
			::vars[var].init = initValue;
			::vars[var].states[initValue] = true;
		} else {
			varNames.n = 0;
			foreachDirect(@::vars, >append(@varNames, $1));
			var = chooseFromList([lang].knownVariables, [lang].enterVariableName, @varNames);
		}
	};
	for (; !exists(@::vars[var].states[state]); ) {
		if (::gameMode !== 'create') {
			throw('unknownState');
		};
		if (state !== '?' && confirm(bake([lang].unknownState), false)) {
			::vars[var].states[state] = true;
		} else {
			validStates.n = 0;
			foreach(@::vars[var].states, >append(@validStates, $1));
			state = chooseFromList(bake([lang].validStates), [lang].enterState, @validStates);
		}
	};
	[updatedVar] = var;
	[updatedState] = state;
};

executor = @::wetExecutor;
dryExecutor.write = function { ::dryExecutor.willDoSomething = true; };
dryExecutor.goto = dryExecutor.write;
dryExecutor.update = dryExecutor.write;
dryExecutor.describe = dryExecutor.write;
dryExecutor.do = wetExecutor.do;

passiveCompiler.resolveVar = function { [$2] = $0; [$3] = $1; };
passiveCompiler.resolveReaction = function { $0 };
passiveCompiler.resolveLocation = function {
	args(@name, @updatedName);
	name = capitalize(name);
	// FIX : why isn't this a map?!
	for (placeNumber = 0; placeNumber < ::places.n && ::places[placeNumber].name != name; ++placeNumber) ;
	if (placeNumber >= ::places.n) throw('unknownLocation');
	[updatedName] = name;
	( placeNumber )
};

tryToDo = function {
	args(@act);
	processed = preprocessAction(act);
	if (processed === '') {
		print([lang].doNotUnderstand);
		( false )
	} else if ({ bestScore = findActions(processed, @solutions, true, 2); solutions.n > 0 }) {
		if (solutions.n == 1) {
			p = solutions[0];
		} else {
			p = void;
			for (i = 0; p == void && i < solutions.n; ++i) {
				action = [solutions[i]].original;
				if (confirm(bake([lang].doYouWantTo), false)) {
					p = solutions[i];
				}
			}
		};
		if (p != void) {
			if (act !== [p].original) {
				print(bake("({[p].original})"));
			};
			::didSomething = false;
			compileAndRunScript(p, if (::gameMode === 'create') @::interactiveCompiler else @::passiveCompiler
					, @::wetExecutor);
			if (!::didSomething) {
				print([lang].youCantDoThat);
				( true )
			} else {
				( true )
			}
		} else if (::gameMode == 'create') {
			// FIX : sub / merge, see below
			action = act;
			print(bake([lang].unknownAction));
			if (editReaction(act, processed)) {
				tryToDo(act);
				( true )
			} else {
				( false )
			}
		} else {
			( false )
		}
	} /* didn't work so well else if (bestScore > 0 && solutions.n > 0) {
		print([lang].beMoreSpecific);
		( false )
	}*/ else if (::gameMode == 'create') {
		action = act;
		print(bake([lang].unknownAction));
		if (editReaction(act, processed)) {
			tryToDo(act);
			( true )
		} else {
			( false )
		}
	} else {
		print([lang].youCantDoThat);
		( false )
	};
};

// TODO: use ppeg
loadAdventure = function {
	args(@contents, @restart);

	prune(@::ignoreWords);
	prune(@::synonymWords);
	prune(@::globalActions);
	clone(@::vars, @oldVars);
	prune(@::vars);
	prune(@::places);
	::places.n = 0;

	lastLine = '';
	expectDescription = false;
	definingScript = void;
	needsToNormalizeSynonyms = false;
	tokenize(contents, >{
		l = trim($0);
		if (::places.n == 0) {
			if (wildmatch(l, "ignore:{*}", @word)) {
				::ignoreWords[lower(trim(word))] = true;
			}
			else if (wildmatch(l, "synonym:{*}={*}", @word, @isSynonymOf)) {
				word = lower(trim(word));
				isSynonymOf = lower(trim(isSynonymOf));
				::synonymWords[word].original = isSynonymOf;
				::synonymWords[word] = preprocessAction(isSynonymOf);
				needsToNormalizeSynonyms = true;
			}
			else if (wildmatch(l, "var:{*}={*}", @varName, @allStates)) {
				varName = lower(trim(varName));
				allStates = lower(allStates);
				initValue = void;
				r = @::vars[varName];
				tokenize(allStates, >{
					state = trim($0);
					if (initValue == void) initValue = state;
					if (state{0} == '[') {
						state = state{1:length(state)-2};
						initValue = state;
					};
					[r].states[state] = true;
				}, '/');
				[r].init = initValue;
				[r] = initValue;
			}
		};
		if (wildmatch(l, ">{*}:{*}", @sentence, @reaction)) {
			if (needsToNormalizeSynonyms) {
				reprocessAllSynonyms();
				needsToNormalizeSynonyms = false;
			};
			sentence = trim(sentence);
			processed = preprocessAction(lower(sentence));
			if (::places.n == 0) {
				definingScript = @::globalActions[processed];
			} else {
				definingScript = @::places[::places.n - 1].actions[processed];
			};
			[definingScript].original = sentence;
			expectDescription = false;
			[definingScript] = trim(reaction);
		}
		else if (lastLine != '' && l{:3}{:length(lastLine)} === '---'{:length(lastLine)}) {
			++::places.n;
			if (lastLine{0} === '#') lastLine = lastLine{1:};
			::places[::places.n - 1].name = capitalize(trim(lastLine));
			expectDescription = true;
		}
		else if (::places.n > 0 && wildmatch(l, ":{*}", @script)) {
			definingScript = @::places[::places.n - 1].script;
			expectDescription = false;
			[definingScript] = trim(script);
		}
		else if (::places.n > 0 && expectDescription) {
			if (l == '') {
				expectDescription = false;
			} else {
				r = @::places[::places.n - 1].description;
				if (!exists(r)) [r] = l
				else [r] #= LF # l;
			};
		}
		else if (definingScript != void) {
			if (($0{0} === ' ' || $0{0} === TAB) && l != '') {
				[definingScript] #= LF # trim($0,void);
			} else {
				definingScript = void;
			}
		};

		lastLine = l;
	});

	if (restart) {
		::location = 0;
		::lastLocation = void;
	} else {
		foreachDirect(@::vars, >{
			if (exists(@oldVars[$1]) && exists(@::vars[$1].states[oldVars[$1]])) {
				[$0] = oldVars[$1];
			}
		});
	};
};

makeStateList = function {
	args(@var, @value);
	states = '';
	foreach(@::vars[var].states, >states #= (if (states != '') ' / ') # bake(if (value === $1) '[{$1}]' else '{$1}'));
	( states )
};

saveAdventure = function {
	args(@fn);
	contents = '';
	foreach(@::ignoreWords, >contents #= 'ignore: ' # $1 # LF);
	contents #= LF;
	foreachDirect(@::synonymWords, >contents #= 'synonym: ' # $1 # ' = ' # [$0].original # LF);
	contents #= LF;
	foreachDirect(@::vars, >contents #= 'var: ' # $1 # ' = ' # makeStateList($1, ::vars[$1].init) # LF);
	contents #= LF;
	foreachDirect(@::globalActions, >{
		contents #= '> ' # [$0].original # ' : ' # $2 # LF;
		if (find($2, LF) < length($2)) contents #= LF;
	});
	contents #= LF;
	iterate(@::places, >{
		contents #= '# ' # [$0].name # LF;
		contents #= repeat('-', length([$0].name) + 2) # LF;
		if (exists(@[$0].description)) {
			contents #= [$0].description # LF;
		};
		if (exists(@[$0].script)) {
			contents #= ': ' # [$0].script # LF;
		};
		contents #= LF;
		foreachDirect(@[$0].actions, >{
			contents #= '> ' # [$0].original # ' : ' # $2 # LF;
			if (find($2, LF) < length($2)) contents #= LF;
		});
		contents #= LF;
	});
	save(fn, contents);
	::lastAdventureFilename = fn;
	::lastAdventureFileContents = contents;
};

autoSave = function {
	if (::autoSyncEnabled) {
		saveAdventure(::lastAdventureFilename);
		print([lang].autoSaved);
	}
};

reprocessAllActionsUnder = function {
	args(@desc, @under, @dryRun);
	s = '';
	foreachDirect(under, >{
		original = [$0].original;
		if ((reprocessed = preprocessAction(original)) != $1) {
			if (exists(@[under][reprocessed])) {
				s #= bake("{desc}: {quote([under][reprocessed].original)} -> {quote(original)}\n");
			};
			if (!dryRun) {
				prune(@[under][reprocessed]);
				prune($0);
				[under][reprocessed] = $2;
				[under][reprocessed].original = original;
			}
		}
	});
	( s )
};

reprocessAllSynonyms = function {
	for (; {
		changed = false;
		foreachDirect(@::synonymWords, >{
			processed = preprocessAction([$0].original);
			if (processed !== $2) {
				changed = true;
				[$0] = processed;
			}
		});
		( changed )
	}; ) ;
};

reprocessAllActions = function {
	goAhead = true;
	s = '';
	iterate(@::places, >s #= reprocessAllActionsUnder([$0].name, @[$0].actions, true));
	s #= reprocessAllActionsUnder([lang].globalReactions, @::globalActions, true);
	if (s !== '') {
		print([lang].duplicatesWarning);
		print(s);
		if (confirm([lang].continueReplacement, false)) {
			iterate(@::places, >reprocessAllActionsUnder([$0].name, @[$0].actions, false));
			reprocessAllActionsUnder([lang].globalReactions, @::globalActions, false);
		} else {
			goAhead = false;
		}
	};
	( goAhead )
};

if (!exists(@::places.n)) {
	::places.n = 1;
	::places[0].name = 'Entry';
	::places[0].description = 'empty';
};

defaults(@::location, 0
		, @::gameMode, 'play'
		, @::autoSyncEnabled, false
		, @::lastAdventureFilename, void
		, @::lastAdventureFileContents, void
		, @::lastLocation, void
		, @::lastActionLocation, 0
		, @::lastAction, void);

for (::doExit = false; !::doExit ;) {
	x = try(>{
		for (; {
			if (::location != ::lastLocation) {
				print("");
				print(::places[::location].name);
				print(repeat('-', length(::places[::location].name)));
			};
			( !exists(@::places[::location].description) )
		};) {
			if (::gameMode == 'create') {
				if (confirm([lang].undescribedLocation, false)) {
					::places[::location].description = input([lang].descriptionInput);
					print([lang].youMayEnterDescription);
					editScript(::location);
				} else {
					::location = ::lastLocation
				};
			} else {
				print([lang].undefinedLocation);
				::location = ::lastLocation;
				::lastLocation = void;
			};
		};
		if (::location != ::lastLocation) {
			::lastLocation = ::location;
			print(wrap(::places[::location].description));
			script = @::places[::location].script;
			if (exists(script)) {
				compileAndRunScript(script, @::passiveCompiler, @::wetExecutor);
			}
		};

		s = input("> ");

		if (::autoSyncEnabled) {
			contents = load(::lastAdventureFilename);
			if (::lastAdventureFileContents !== contents) {
				lastAdventureFileContents = contents;
				loadAdventure(contents, false);
				print([lang].autoLoaded);
			}
		};

		createMode = (::gameMode == 'create');

		if (s == '') {
			;
		} else if (s == '?') {
			print([lang][if (createMode) "createModeHelp" else "playModeHelp"]);
		} else if (s == [lang].quitCommand) {
			::doExit = true
		} else if (s == [lang].restartCommand) {
			::location = 0;
			::lastLocation = void;
			foreachDirect(@::vars, >[$0] = [$0].init)
		} else if (createMode
				&& { action = ''; s == [lang].changeCommand || s == [lang].changeReactionCommand
				|| wildmatch(s, [lang].changeReactionToCommand, @action) }) {
			if (action == '') {
				action = ::lastAction;
				::location = ::lastActionLocation;
				isChangingLastAction = true;
			} else {
				action = lower(trim(action));
				isChangingLastAction = false;
			};
			if (action == void) {
				print([lang].youHaveNotDoneAnythingYet);
			} else {
				processed = preprocessAction(action);
				if (!exists(r = @::places[::location].actions[processed])) {
					r = @::globalActions[processed];
				};
				if (!exists(r) && !isChangingLastAction) {
					print([lang].noSuchReactionExists);
				} else {
					if (!exists(r)) {
						print(bake([lang].unknownAction));
					} else {
						locationName = ::places[::location].name;
						print(bake([lang].changeReaction));
						print("");
						print("  " # [r]);
						print("");
						print([lang].leaveEmptyToCancel);
					};
					editReaction(action, processed);
				}
			}
		} else if (createMode && wildmatch(s, [lang].saveCommand, @filename)) {
			saveAdventure(trim(filename));
		} else if (createMode && s === [lang].resaveCommand) {
			if (::lastAdventureFilename === void) {
				print([lang].pleaseUseLoadCommandFirst);
			} else {
				fn = ::lastAdventureFilename;
				saveAdventure(fn);
				print(bake([lang].savedTo));
			}
		} else if (wildmatch(s, [lang].loadCommand, @filename) || {filename = lastAdventureFilename; s === [lang].reloadCommand}) {
			if (::autoSyncEnabled) {
				::autoSyncEnabled = false;
				print([lang].autoSyncDisabled);
			};
			contents = load(trim(filename));
			loadAdventure(contents, ::lastAdventureFilename !== filename);
			::lastAdventureFilename = filename;
			::lastAdventureFileContents = contents;
			fn = ::lastAdventureFilename;
			print(bake([lang].loadedFrom));
		} else if (createMode && s === [lang].changeTextCommand) {
			locationName = ::places[::location].name;
			print(bake([lang].replaceDescription));
			s = input([lang].descriptionInput);
			if (s != void) {
				::places[::location].description = s;
				print([lang].changedText);
				autoSave();
			} else {
				print([lang].cancelled);
			}
		} else if (createMode && s === [lang].changeNameCommand) {
			locationName = ::places[::location].name;
			print(bake([lang].newNameForLocation));
			s = input([lang].nameInput);
			if (s != void) {
				newName = capitalize(s);
				::places[::location].name = newName;
				print(bake([lang].changedNameTo));
				// FIX : go through all scripts and update names
				autoSave();
			} else {
				print([lang].cancelled);
			}
		} else if (createMode && s === [lang].changeScriptCommand) {
			locationName = ::places[::location].name;
			if (exists(@::places[::location].script)) {
				print(bake([lang].replaceScriptFor));
				print("");
				print("  " # ::places[::location].script);
				print("");
				print([lang].leaveEmptyToCancel);
			} else {
				print(bake([lang].createScriptFor));
			};
			editScript(::location);
		} else if (createMode && s == [lang].listReactionsCommand) {
			foreachDirect(@::places[::location].actions, >{
				print("> " # [$0].original # " : " # $2);
			});
		} else if (createMode && s == [lang].listVariablesCommand) {
			foreachDirect(@::vars, >print($1 # ' = ' # makeStateList($1, ::vars[$1])))
		} else if (createMode && s == [lang].listLocationsCommand) {
			iterate(@::places, >{
				print((if (::location == $1) '-> ' else if (!exists(@[$0].description)) '?? ' else '   ') # [$0].name);
			});
		} else if (createMode && wildmatch(s, [lang].synonymCommand, @word, @isSynonymOf)) {
			word = lower(trim(word));
			isSynonymOf = lower(trim(isSynonymOf));
			previousExisted = exists(@::synonymWords[word].original);
			previousValue = (if (previousExisted) ::synonymWords[word].original else void);
			::synonymWords[word].original = isSynonymOf;
			::synonymWords[word] = void;
			reprocessAllSynonyms();
			if (reprocessAllActions()) {
				print(bake([lang].definedSynonym));
				autoSave();
			} else {
				if (!previousExisted) delete(@::synonymWords[word])
				else ::synonymWords[word].original = previousValue;
				reprocessAllSynonyms();
			}
		} else if (createMode && wildmatch(s, [lang].ignoreCommand, @word)) {
			word = lower(trim(word));
			if (exists(@::ignoreWords[word])) {
				print(bake([lang].ignoringWord));
			} else {
				::ignoreWords[word] = true;
				reprocessAllSynonyms();
				if (reprocessAllActions()) {
					print(bake([lang].ignoringWord));
					autoSave();
				} else {
					delete(@::ignoreWords[word]);
					reprocessAllSynonyms();
				}
			}
		} else if (createMode && s === [lang].playCommand) {
			if (::autoSyncEnabled) { // FIX : sub
				::autoSyncEnabled = false;
				print([lang].autoSyncDisabled);
			};
			::gameMode = 'play';
			print([lang].enteringPlayMode);
		} else if (!createMode && s === [lang].createCommand) {
			::gameMode = 'create';
			print([lang].enteringCreateMode);
		} else if (wildmatch(s, [lang].languageCommand, @language)) {
			language = lower(language);
			newLang = @LANGS[language];
			if (exists(@[newLang].languageCommand)) {
				lang = newLang;
				language = upper(language{0}) # lower(language{1:});
				print(bake([lang].changedLanguageTo));
			} else {
				print(bake([lang].unknownLanguage));
			}
		} else if (createMode && s === [lang].autoSyncOnCommand) {
			if (::lastAdventureFilename === void) {
				print([lang].pleaseUseLoadCommandFirst);
			} else {
				::autoSyncEnabled = true;
				fn = ::lastAdventureFilename;
				print(bake([lang].autoSyncEnabledFor));
			}
		} else if (createMode && s === [lang].autoSyncOffCommand) {
			::autoSyncEnabled = false;
			print([lang].autoSyncDisabled);
		} else if (createMode && wildmatch(s, [lang].changeVariableCommand, @variable, @state)) {
			interactiveCompiler.resolveVar(lower(trim(variable)), lower(trim(state)), @updatedVariable, @updatedState);
			::vars[updatedVariable] = updatedState;
		} else if (createMode && wildmatch(s, [lang].teleportCommand, @teleportLocation)) {
			::location = interactiveCompiler.resolveLocation(trim(teleportLocation), @updatedLocationName);
		} else {
			s = trim(s);
			wasLocation = ::location;
			if (tryToDo(s)) {
				::lastActionLocation = wasLocation;
				::lastAction = s;
			}
		}
	});
	if (x != void) {
		print(coalesce(@[lang].exception[x], x));
	};
}
