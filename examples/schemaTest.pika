#! /usr/local/bin/PikaCmd

include('systools.pika');

	::run.root = 'lab/';

include('stdlib.pika');
include('debug.pika');
include('initPPEG.pika');
include('objects.pika');

calcLineAndColumn = function {
	args(@source, @offset, @line, @column);
	l = 0;
	lb = 0;
	for (i = 0; i <= offset; i += find(source{i:}, "\n") + 1) {
		lb = i;
		++l;
	};
	[line] = l;
	[column] = (offset - lb) + 1;
};

formatError = function {
	args(@source, @offset, @message);
	calcLineAndColumn(source, offset, @line, @column);
	// FIX : how?
/*	print("--------");
	s = (if (offset - 200 > 0) '...' else '')
		# source{offset - 200:200}
		# ' <!!!!> '
		# source{offset:200}
		# (if (offset + 200 < length(source)) '...' else '');
	print(s);
	print("--------");*/
	( bake("Line: {line}, column: {column} (@{offset}) {message}") )
};

createSchemaParser = function {
	print('Compiling Schema parser...');
	cushySchemaSource = load(::run.root # 'cushySchema.ppeg');
	ok = ppeg.compileFunction(cushySchemaSource, @schemaParser, @offset);
	if (!ok) {
		throw(formatError(cushySchemaSource, offset, bake("Error compiling Cushy Schema parser")));
	};

	print('Parsing Schema...');
	cushySchemaSource = load(::run.root # 'cushySchemaTest.schema');
	ok = schemaParser(cushySchemaSource, @schema, @offset);
	if (!ok) {
		throw(formatError(cushySchemaSource, offset, bake("Error parsing Cushy Schema")));
	};

	print('Compiling PEGs...');
	pegSource = '';
	foreach([schema].pegs, >pegSource #= $1 # ' <- ' # $2 # LF);
	ok = ppeg.compileFunction(pegSource, @[schema].pegParsers, @offset);
	if (!ok) throw(bake("Error parsing Schema PEGs"));

	errorCount = 0;

	print('Checking Schema references...');
	iterate([schema].refs, >{
		offset = [$2].offset;
		name = [$2].name;
		kind = [$2].kind;
		container = (if (kind === 'rule') [schema].rules else [schema].pegs);
		if (!exists(@[container][name])) {
			print(formatError(cushySchemaSource, offset, bake("{if (kind === 'rule') 'rule' else 'peg'} {name} is missing")));
			++errorCount;
		}
	});

	if (errorCount != 0) {
		throw("One or more errors occured");
	};

	gc();

	( schema )
};

if (false) {	// all alternatives (text implementation)
	makeError = function {
		args(@message, @node);
		if (node === void) {
			( message )
		} else {
			calcLineAndColumn(cushySource, [node].begin, @line, @column);
			( bake("{message} at line: {line}, column: {column}") )
		}
	};

	makeEmptyError = function { ( '' ) };

	joinErrors = function {
		args(@prior, @current);
		exists = false;
	//	tokenize(prior, >if ($0 === current) exists = true);
		if (!exists) {
			if (prior !== '') prior #= "\n";
			prior #= current;
		};
		( prior )
	};

	errorToString = function {
		s = '';
		tokenize($0, >s #= (if (s !== '') "  or ") # $0 # LF);
		( chop(s, 1) )
	}
} else if (false) {	// just the alternative that parsed the most text
	makeError = function { ( new(Container, 'message', $0, 'node', $1, 'score', 0) ) };

	makeEmptyError = function { ( void ) };

	joinErrors = function {
		args(@prior, @current);
		if (prior === void || [[prior].node].begin < [[current].node].begin) ( current ) else ( prior )
	};

	errorToString = function {
		args(@err);
		calcLineAndColumn(cushySource, [[err].node].begin, @line, @column);
		( bake("{[err].message} at line: {line}, column: {column}") )
	}
} else if (false) {	// all as array
	makeError = function {
		( new(Array, new(Container, 'message', $0, 'node', $1, 'prior', void, 'score', 0)) )
	};

	makeEmptyError = function { ( new(Array) ) };

	joinErrors = function {
		args(@prior, @current);
		joined = new(Array);
		inject(prior, 0, [prior].n, joined, 0);
		inject(current, 0, [current].n, joined, [joined].n);
		( joined )
	};

	errorToString = function {
		args(@err);
		e = [err][0];
		calcLineAndColumn(cushySource, [[e].node].begin, @line, @column);
		s = bake("{[e].message} {[e].score} at line: {line}, column: {column}");
		for (i = 1; i < [err].n; ++i) { e = [err][i]; s #= bake("\n  or {[e].message} {[e].score}"); };
		( s )
	}	
} else if (true) {
	makeError = function {
		( new(Array, new(Container, 'message', $0, 'node', $1, 'score', 0)) )
	};

	makeEmptyError = function { ( new(Array) ) };

	joinErrors = function {
		args(@prior, @current);
		if ([prior].n == 0) {
			( current )
		} else if ([[current][0]].score > [[prior][0]].score) {
print(errorToString(current));
print("  has higher prio than:  ");
print(errorToString(prior));
print("");
			( current )
		} else if ([[current][0]].score < [[prior][0]].score) {
print(errorToString(current));
print("  has lower prio than:  ");
print(errorToString(prior));
print("");
			( prior )
		} else {
print(errorToString(current));
print("  has same prio as:  ");
print(errorToString(prior));
print(" == ");
			joined = new(Array);
			inject(prior, 0, [prior].n, joined, 0);
			inject(current, 0, [current].n, joined, [joined].n);
print(errorToString(joined));
print("");
			( joined )
		}
	};

	errorToString = function {
		args(@err);
		e = [err][0];
		calcLineAndColumn(cushySource, [[e].node].begin, @line, @column);
		s = bake("{[e].message} {[e].score} at line: {line}, column: {column}");
		for (i = 1; i < [err].n; ++i) { e = [err][i]; s #= bake("\n  or {[e].message} {[e].score}"); };
		( s )
	}	
};

countMembers = function { n = 0; foreach($0, >++n); ( n ) };
countTrue = function { n = 0; foreach($0, >if ($2) ++n); ( n ) };

// crossList will contain true or false for every property *found* and checked in the validating struct, false = one or several validations (not guaranteed all) on this property has failed
validateKVAlts = function {
	args(@schema, @node, @elem, @error, @crossList);
	[error] = makeEmptyError();

	alts = [elem].seqs;
	bestCount = 0;
	for ({ i = 0; n = [alts].n }; i < n && {
		foreach(@altCrossList, >[$0] = false);	// all found properties from last attempt is now considered invalid (but still found for slightly better error reports)
		thisError = void;
		if (validateKVSequence(schema, node, [alts][i], @thisError, @altCrossList)) {
			( false )
		} else {
			//print(errorToString(thisError));
			[error] = joinErrors([error], thisError);
			( true )
		}
	}; ++i);
	clone(@altCrossList, crossList);
	if ( i < n ) {
		( true )
	} else {
		( false )
	}
};

validateKVOpt = function {
	args(@schema, @node, @elem, @error, @crossList);
	if (validateKVSequence(schema, node, [elem].seq, error, @optCrossList)) {
		clone(@optCrossList, crossList);
		( true )
	} else {
		( countMembers(@optCrossList) === 0 );
	}
};

validateUnmatched = function {
	args(@schema, @node, @elem, @error, @crossList);

	ok = true;
	foreach([node].value, >if (ok && !exists(@[crossList][$1])) {
		ok = validateValue(schema, $2, [elem].template, error);
		[crossList][$1] = ok;
	});
	( ok )
};

validateKV = function {
	args(@schema, @node, @elem, @error, @crossList);

	key = [elem].key;
	if (!exists(r = @[[node].value][key])) {
		[error] = makeError(bake("missing '{key}'"), node);
		( false )
	} else {
		ok = validateValue(schema, [r], [elem].value, error);
		[crossList][key] = ok;
		( ok )
	}
};

map(@KV_SEQ_VALIDATORS
		, 'kv', validateKV
		, 'opt', validateKVOpt
		, 'alts', validateKVAlts
		, 'unmatched', validateUnmatched);

validateKVSequence = function {
	args(@schema, @node, @sequence, @error, @crossList);
	for ({ i = 0; n = [sequence].n }; i < n && {
		elem = [sequence][i];
		KV_SEQ_VALIDATORS[[elem].kind](schema, node, elem, error, crossList);
	}; ++i);
if (i < n) {
asdfasdf = countTrue(crossList);
for (z = 0; z < [[error]].n; ++z) [[ [error] ][z]].score = asdfasdf;
};
	(i >= n)
};

validateStruct = function {
	args(@schema, @node, @rule, @error);
	if (node === void) ( false ) // error message set by validateList
	else if ([node].type !== 'struct') {
		[error] = makeError(bake("expected struct (not {TYPE_DESCS[[node].type]})"), node);
		( false )
	} else if (validateKVSequence(schema, node, [rule].seq, error, @crossList)) {
		ok = true;
		foreach([node].value, >{
			if (ok && (!exists(@crossList[$1]) || !crossList[$1])) {
				[error] = makeError(bake("unrecognized or irrelevant property: '{$1}'"), node);
	[[ [error] ][0]].score = countTrue(@crossList);
				ok = false
			}
		});
		( ok )
	} else {
		( false )
	}
};

validateList = function {
	args(@schema, @node, @rule, @error);
	if (node === void) ( false ) // error message set by validateList
	else if ([node].type !== 'array') {
		[error] = makeError(bake("expected array (not {TYPE_DESCS[[node].type]})"), node);
		( false )
	} else {
		a = [node].value;
		v = [rule].values;
		n = [v].n;
		if ([a].n > n) {
			[error] = makeError(bake("expected max {n} array elements (got {[a].n})"), node);
			( false )
		} else {
			for (i = 0; i < n && {
				e = [v][i];
				// FIX : sep loops
				if (i >= [a].n) {	// set last visited node to this entire array for undefined array elements
					if (!validateValue(schema, void, e, @dummy)) {
						[error] = makeError(bake("missing array element(s)"), node);
						( false )
					} else {
						( true )
					}
				} else {
					validateValue(schema, [a][i], e, error)
				}
			}; ++i);
			i == n
		}
	}
};

validateArray = function {
	args(@schema, @node, @rule, @error);
	if (node === void) ( false ) // error message set by validateList
	else if ([node].type !== 'array') {
		[error] = makeError(bake("expected array (not {TYPE_DESCS[[node].type]})"), node);
		( false )
	} else {
		a = [node].value;
		t = [rule].template;
		for ({ i = 0; n = [a].n }; i < n && validateValue(schema, [a][i], t, error); ++i);
		(i >= n)
	}
};

validateRule = function {
	args(@schema, @node, @rule, @error);
	ref = [rule].name;
	validateValue(schema, node, [[schema].rules][ref], error)
};

validatePeg = function {
	args(@schema, @node, @rule, @error);
	if (node === void) ( false ) // error message set by validateList
	else if ([node].type !== [rule].type) {
		[error] = makeError(bake("expected {TYPE_DESCS[[rule].type]} (not {TYPE_DESCS[[node].type]})"), node);
		( false )
	} else if ([rule].peg == void
			|| ([schema].pegParsers([node].value, @dummy, @offset, [rule].peg)
			&& offset >= length([node].value))) {
		( true )
	} else {
		[error] = makeError(bake("expected valid '{[rule].peg}' (not '{[node].value}')"), node);
		( false )
	}
};

validateOpt = function {
	args(@schema, @node, @rule, @error);
	(node === void || validateValue(schema, node, [rule].value, error))
};

validateAlts = function {
	args(@schema, @node, @rule, @error);
	alts = [rule].values;
	[error] = makeEmptyError();
	for ({ i = 0; n = [alts].n }; i < n && {
		thisError = void;
		if (validateValue(schema, node, [alts][i], @thisError)) {
			( false )
		} else {
			//print(errorToString(thisError));
			[error] = joinErrors([error], thisError);
			( true )
		}
	}; ++i);
	(i < n)
};

map(@TYPE_DESCS, 'string','quoted string', 'text','unquoted text', 'struct','struct'
		, 'array','array', 'void','void / no value');

validateLiteral = function {
	args(@schema, @node, @rule, @error);
	if (node === void) ( false ) // error message set by validateList
	else if ([node].type !== [rule].type) {
		[error] = makeError(bake("expected {TYPE_DESCS[[rule].type]} (not {TYPE_DESCS[[node].type]})"), node);
		( false )
	} else if ([node].value !== [rule].literal) {
		[error] = makeError(bake("expected '{[rule].literal}' (not '{[node].value}')"), node);
		( false )
	} else {
		( true )
	}
};

validateAny = function {
	args(@schema, @node, @rule, @error);
	(node !== void)
};

/*
#	Value =
#		{ kind: 'struct', seq: KVSequence }			// numbstrict type must be struct
#		| { kind: 'array', template: Value }		// numbstrict type must be array (0 or more matches)
#		| { kind: 'list', values: [ Value, ... ] }	// numbstrict type must be array (exact length or less if last items are optional)
#		| { kind: 'rule', name: string }
#		| { kind: 'literal', literal: string }		// numbstrict type must be string or text
#		| { kind: 'text', peg: peg|void }			// numbstrict type must be text, void = match any
#		| { kind: 'string', peg: peg|void }			// numbstrict type must be string, void = match any
#		| { kind: 'opt', value: Value }
#		| { kind: 'alts', values: [ Value, ... ] }
#		| { kind: 'any' }							// anything goes!
*/


map(@VALIDATORS
		, 'struct', validateStruct
		, 'array', validateArray
		, 'list', validateList
		, 'rule', validateRule
		, 'literal', validateLiteral
		, 'peg', validatePeg
		, 'opt', validateOpt
		, 'alts', validateAlts
		, 'any', validateAny
		);

validateValue = function {
	args(@schema, @node, @rule, @error);
	VALIDATORS[[rule].kind](schema, node, rule, error)
};

schema = void;
parsedCushy = void;
gc();
schema = createSchemaParser();

cushySource = load(::run.root # 'test.cushy');

print('Compiling Numbstrict parser...');
numbstrictSource = load(::run.root # 'numbstrictMeta.ppeg');
ok = ppeg.compileFunction(numbstrictSource, @numbstrictParser, @offset);
if (!ok) {
	throw(formatError(numbstrictSource, offset, bake("Error compiling Numbstrict parser")));
};

print("Parsing Numbstrict...");
ok = numbstrictParser(cushySource, @parsedCushy, @offset);
if (!ok) {
	throw(formatError(cushySource, offset, bake("Error parsing Numbstrict")));
};
gc();

print("Validating...");
ok = validateValue(schema, parsedCushy, [[schema].rules].root, @error);
if (!ok) {
	print('!!!! ' # errorToString(error));
} else {
	print('Validation OK');
};
gc();
