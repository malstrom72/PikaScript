########################################
#									   #
#		   PEG for PikaScript		   #
#									   #
#  Copyright 2008-2025                 #
#  NuEdge Development                  #
#									   #
########################################

{
$$parser.$cat = function {
	args(@left, @right);
	if (left == '') ( right )
	else if (right == '') ( left )
	else if ((i = find(left, "\1")) < length(left)) {
		( left{:i} # (if (right{:2} == '{}') right{2:} else right) # left{i + 1:} )
	} else if ((i = find(left, "\2")) < length(left)) {
		( left{:i} # ' && ' # (if (right{:2} == '{}') ('{ ' # right{2:} # ' }') else right) # left{i + 1:} )
	} else assert(false);
};

$$parser.$normalize = function {
	args(@expression, @doBrackets);
	if (expression{:2} == '{}') expression = (if (doBrackets) '{ ' # expression{2:} # ' }' else expression{2:});
	expression = $$parser.$cat("\1", replace(replace(expression, "\2", ""), "\1", "true"));
	( expression )
};

$$parser.$finalize = function {
	$0 = replace($0, "\n\r", "\t", find, 1);
	for (; (nu = replace($0, "\t\t", "\t")) != $0;) $0 = nu;
	$0 = replace($0, " \t", " ");
	$0 = replace($0, "\t ", " ");
	$0 = replace($0, "\t", " ");
	evaluate('function { ' # $0 # ' }')
};

$$parser.$processCode = function {
	args(@forTag, @action);
	replace(replace(replace(replace(action, "$$s", '$0'), "$$i", [forTag].ixv)
			, "\x24\x24parser", $$parser.$target), "$$", '[$2]');
	
};

$$parser.FAIL = function { ppeg.fail('Parsing failed', $0, [$1]) };
}

# ----------------------------------------------------------------------------------------------------------------------

root		<-									{
													$t = $$parser.$compileTo;
													$$parser.$target = (if ($t{:2} == '::') $t else ('[' # escape($t) # ']'));
													[$$parser.$compileTo].FAIL = $$parser.FAIL;
												}
				( Spacing $$=PikaBlock			{ evaluate(replace($$, "\x24\x24parser", $$parser.$target), @$) }
				)? Spacing Grammar

# ----------------------------------------------------------------------------------------------------------------------


#############################
#	 Hierarchical syntax	#
#############################


# ----------------------------------------------------------------------------------------------------------------------

Grammar		<-	Spacing Definition* EndOfFile

# ----------------------------------------------------------------------------------------------------------------------

Definition	<-									{ $$.ixv = '[$1]'; $$.tag = '$2'; $$.vi = 0; }
				$id:Identifier LEFTARROW
				Expression						{ [$$parser.$compileTo][$id] = $$parser.$finalize($$parser.$normalize($$, false)); }
				/ !EndOfFile					{ ppeg.fail("Syntax error around here", $$s, $$i); }

# ----------------------------------------------------------------------------------------------------------------------

Expression	<-									{ clone(@$$, @$s); group = false }
				Sequence ( SLASH $s:Sequence	{
													$$ = $$parser.$normalize($$, true) # ' || ' # $$parser.$normalize($s, true);
													group = true;
												}
				)*								{ if (group) $$ = '(' # $$ # ")\2" }

# ----------------------------------------------------------------------------------------------------------------------

Sequence	<-	$a:Actions (OneSeq / ManySeq)?	{ $$ = $$parser.$cat($$parser.$processCode(@$$, $a), $$) }

# ----------------------------------------------------------------------------------------------------------------------

OneSeq		<-									{ clone(@$$, @$p) }
				$p:Prefix $a:Actions !Prefix	{ $$ = $$parser.$cat($p, $$parser.$processCode(@$p, $a)) }

# ----------------------------------------------------------------------------------------------------------------------

ManySeq		<-									{	
													clone(@$$, @$p);
													$p.ixv = '$i' # ($p.vi = $$.vi + 1);
													$$ = bake("{}<($p.ixv)> = <($$.ixv)>; \1", '<(', ')>');
												}
				( $p:Prefix $a:Actions			{ $$ = $$parser.$cat($$, $$parser.$cat($p, $$parser.$processCode(@$p, $a))) }
				)+								{ $$ = $$parser.$cat($$, bake("{}<($$.ixv)> = <($p.ixv)>; \1", '<(', ')>')) }

# ----------------------------------------------------------------------------------------------------------------------

Actions		<-									{ $$ = '' }
				( $b=PikaBlock Spacing			{ $$ = $$parser.$cat($$, bake("{}<($b)>; \1", '<(', ')>')) }
				)*
												
# ----------------------------------------------------------------------------------------------------------------------

Prefix		<-									{ clone(@$$, @$c) }
				AND								{
													$c.ixv = '$i' # ($c.vi = $$.vi + 1);
													$$ = bake("{}<($c.ixv)> = <($$.ixv)>; \1", '<(', ')>')
												}
					$c:Capture					{ $$ = $$parser.$cat($$, $c) }
				/ NOT							{
													$c.ixv = '$i' # ($c.vi = $$.vi + 1);
													$$ = bake("{}<($c.ixv)> = <($$.ixv)>; !{ \1 }\2", '<(', ')>')
												}
					$c:Capture					{ $$ = $$parser.$cat($$, $$parser.$normalize($c, false)) }
				/ Capture

# ----------------------------------------------------------------------------------------------------------------------

Capture		<-									{ $prefix = $suffix = '' }
				( $v:Variable EQUALS			{
													$markv = '$m' # $$.vi;
													$prefix = bake("{}<($markv)> = <($$.ixv)>; \1", '<(', ')>');
													$suffix = bake("{}<($v)> = $0{<($markv)>:<($$.ixv)> - <($markv)>}; \1", '<(', ')>');
												}
				)?
				Tagged							{ $$ = $$parser.$cat($prefix, $$parser.$cat($$, $suffix)) }

# ----------------------------------------------------------------------------------------------------------------------

Tagged		<-									{ clone(@$$, @$t) }
				( $v:Variable COLON				{ $t.tag = '@' # $v }
				)?								
				$t:Suffix						{ $$ = $t }

# ----------------------------------------------------------------------------------------------------------------------

Suffix		<-	Primary ( QUESTION				{ $$ = $$parser.$cat("{}\1; \1", $$parser.$normalize($$, false)) }
						  / STAR				{ $$ = $$parser.$cat("{}for (; \1; ); \1", $$parser.$normalize($$, true)) }
						  / PLUS				{ $$ = $$parser.$cat("{ false; for (; \1; ) true }\2", $$parser.$normalize($$, true)) }
				)?

# ----------------------------------------------------------------------------------------------------------------------

Primary		<-	Identifier !LEFTARROW			{ $$ = bake("<($$parser.$target)>.<($$)>($0, @<($$.ixv)>, <($$.tag)>)\2", '<(', ')>') }
				/ Literal						{
													l = length($$);
													if (l == 0) $$ = "{}\1"
													else if (l == 1) $$ = bake("($0{<($$.ixv)>} == <(escape($$))>) && { ++<($$.ixv)>; \1 }", '<(', ')>')
													else $$ = bake("($0{<($$.ixv)>:<(l)>} == <(escape($$))>) && { <($$.ixv)> += <(l)>; \1 }", '<(', ')>')
												}
				/ Class							{ $$ = bake("(span($0{<($$.ixv)>}, <(escape($$))>) == 1) && { ++<($$.ixv)>; \1 }", '<(', ')>'); }
				/ DOT							{ $$ = bake("($0{<($$.ixv)>} != '') && { ++<($$.ixv)>; \1 }", '<(', ')>'); }
				/ OPEN							{ clone(@$$, @$e) }
					$e:Expression CLOSE			{ $$ = $e }

# ----------------------------------------------------------------------------------------------------------------------


########################
#	 Lexical syntax	   #
########################


# ----------------------------------------------------------------------------------------------------------------------

Identifier	<-	$$=(IdentStart IdentCont*) Spacing

# ----------------------------------------------------------------------------------------------------------------------

IdentStart	<-	[a-zA-Z_]

# ----------------------------------------------------------------------------------------------------------------------

IdentCont	<-	IdentStart / [0-9] 

# ----------------------------------------------------------------------------------------------------------------------

Variable	<-	( '$$'							{ $$ = '[$2]' }
				  / $$=PikaVar
				) Spacing

# ----------------------------------------------------------------------------------------------------------------------

Literal		<-									{ $$ = '' }
				['] ( !['] $c:Char				{ $$ #= $c }
				)* ['] Spacing
				/ ["] ( !["] $c:Char			{ $$ #= $c }
				)* ["] Spacing

# ----------------------------------------------------------------------------------------------------------------------

Class		<-									{ $$ = '' }
				'[' ( !']' $r:Range				{ $$ #= $r }
				)* ']' Spacing

# ----------------------------------------------------------------------------------------------------------------------

Range		<-	$f:Char '-' $t:Char				{ $$ = ''; for (i = ordinal($f); i <= ordinal($t); ++i) $$ #= char(i); }
				/ $$:Char

# ----------------------------------------------------------------------------------------------------------------------

Char		<-	"\\" $x=[nrt'"\[\]\\]			{ $$ = "\n\r\t'\"[]\\"{find("nrt'\"[]\\", $x)} }
				/ "\\" $x=([0-2][0-7][0-7])		{ $$ = char($x{0} * 64 + $x{1} * 8 + $x{2}) }
				/ "\\" $x=([0-7][0-7]?)			{ $$ = char($x{0} * 8 + coalesce($x{1}, 0)) }
				/ ![\\\0-\37] $$=.				/ { ppeg.fail("Invalid character", $$s, $$i); }

# ----------------------------------------------------------------------------------------------------------------------

Spacing		<-	(Space / Comment)*

# ----------------------------------------------------------------------------------------------------------------------

Comment		<-	'#' (!EndOfLine .)* (EndOfLine / EndOfFile)

# ----------------------------------------------------------------------------------------------------------------------

Space		<-	' ' / "\t" / EndOfLine

# ----------------------------------------------------------------------------------------------------------------------

EndOfLine	<-	"\r\n" / "\n" / "\r"

# ----------------------------------------------------------------------------------------------------------------------

EndOfFile	<-	!.

# ----------------------------------------------------------------------------------------------------------------------


#################
#	 Actions	#
#################


# ----------------------------------------------------------------------------------------------------------------------

PikaVar		<-	( '$'? [a-zA-Z_] ( '.'? [a-zA-Z_0-9] )* )

# ----------------------------------------------------------------------------------------------------------------------

PikaBlock	<-									{ pikaBegin = $$i }
				( '{' ( &'{' PikaBlock
					/ &["'] PikaString
					/ &('/*' / '//') PikaComment
					/ ![{"'}] !'/*' !'//' .
					/ !'}'						{ ppeg.fail("Invalid PikaScript in this block", $$s, pikaBegin); }
					)* '}' )

# ----------------------------------------------------------------------------------------------------------------------

PikaString	<-	'"' ( ('\\' / !'"') . )* '"' / "'" ( ("''" / !"'" .) )* "'"

# ----------------------------------------------------------------------------------------------------------------------

PikaComment	<-	'/*' (!'*/' .)* '*/' / "//" (!EndOfLine .)* (EndOfLine / EndOfFile)

# ----------------------------------------------------------------------------------------------------------------------


################
#	 Tokens	   #
################


# ----------------------------------------------------------------------------------------------------------------------

LEFTARROW	<-	'<-' Spacing
SLASH		<-	'/' Spacing
AND			<-	'&' Spacing
NOT			<-	'!' Spacing
QUESTION	<-	'?' Spacing
STAR		<-	'*' Spacing
PLUS		<-	'+' Spacing
OPEN		<-	'(' Spacing
CLOSE		<-	')' Spacing
DOT			<-	'.' Spacing
COLON		<-	':' Spacing
EQUALS		<-	'=' Spacing

# ----------------------------------------------------------------------------------------------------------------------
