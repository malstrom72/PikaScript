// TODO : I should really have defined this function "findPattern" with from and to instead of just offset.
// That way, the function would have been able to quickly locate a substring etc. Right now, we test this step by
// step = lots of unnecessary function calls etc
// (actually, I started on this transition as you can see in the code below, $from and $to in "inner" is used to quickly
// locate fixed literal strings, but nothing else... for example [a-z] could also quickly be located in a similar manner
// but this isn't implemented here yet)
::nuexpLo = function { // (source, offset, pattern, capture)
	args(@src, @offset, @ptn, @capture);
	stops.n = 0;
	defaults(@[capture].n, 0);

	charsetSpan => {
		$i = find(ptn{$0:}, ']') + 1;
		if (ptn{$0 + $i:1} == ']') ++$i					// special handling of terminating ]] or ]^]
		else if (ptn{$0 + $i:2} == '^]') $i += 2;
		$i;
	};
	
	inner => {
		args(@$from, @$to, @$index);
		$dir = if ($from < $to) 1 else -1;
		$ok = false;
		for ($offset = $from; !$ok && {
			$i = find(ptn{$index:}, '`{([?*%~|.)}');
			if ($i > 0) {
				$y = ptn{$index:$i};
				if ($from < $to) {
					$i = $to - $offset + length($y);
					$a = search(src{$offset:$i}, $y);
					$b = search(usrc{$offset:$i}, $y);
					$offset += min($a, $b);
				} else {
					$i = $offset - $to + length($y);
					$a = rsearch(src{$to:$i}, $y);
					$b = rsearch(usrc{$to:$i}, $y);
					$offset = $to + max($a, $b);
				}
			} else if (($c = ptn{$index}) == '') {
				$ok = (max($to, $from) >= length(src));
				$offset = -1;
			};
			$offset >= min($from, $to) && $offset <= max($from, $to)
		}; $offset += $dir) {
			$p = $index;
			$o = $offset;
			$captureMark = [capture].n;
			for (; {
				for ($ok = true; {
						// FIX: this is not really bonafide, since we have caseless comparison by uppercasing only the source, we
						// match things like MAGNUS == mAgNus, but not Magnus == magnus... that could be ok, but now '.' etc suddenly
						// make a difference, since they separate the tests. E.g. MAGNUS lidstršm will only match exactly, while
						// MAGNUS.lidstršm will match any case on magnus, but exact on lidstršm.
						$i = find(ptn{$p:}, '`{([?*%~|.)}');
						$y = ptn{$p:$i};
						$x = src{$o:$i};
						$o += $i;
						$p += $i;
						if ($x != $y && upper($x) != $y) $ok = false				// break if not matching until next instruction char
						else if (ptn{$p} != '`') false
						else if (src{$o} != ptn{$p + 1}) $ok = false						// match exactly a single char after escape char
						else true
					}; ) {
					$p += 2;
					++$o;
				};
				if (!$ok || ($c = ptn{$p}) == '') {
					if ($o < length(src)) $ok = false;
					false
				} else if ($c == '.' && ptn{$p:3} == '...') {
					$i = begins[$p];
					if (ptn{$i} == '(') {
						[$capt = groups[$i]].end = $o;
						[$capt].string = src{[$capt].begin:$o - [$capt].begin};
					};
					if (inner($o, $o, ends[$i] + 1)) false
					else { $p += 3; true }
				} else if ($c == '.') {
					if (src{$o} != '.') {
						$ok = false;
						false;
					} else {
						++$o;
						++$p;
						true;
					}
				} else if ($c == ')' || $c == '}' || $c == '|') {											// ) } = group
					$i = repeats[$p];
					if ($i != void) $p = $i + 1
					else {
						$p = begins[$p];
						if (ptn{$p} == '(') {
							[$capt = groups[$p]].end = $o;
							[$capt].string = src{[$capt].begin:$o - [$capt].begin};
						};
						$p = ends[$p] + 1;
					};
					true
				} else if ($c == '(') {														// ( = group with capture
					[$capt = @[capture][[capture].n++]].begin = $o;
					$oldP = $p;
					$oldGroup = groups[$p];
					groups[$p] = $capt;
					[$capt].id = $p;
					[$capt].alt = 0;
					for (; !($ok = inner($o, $o, $p + 1)) && ptn{$p = alts[$p]} == '|';) ++[$capt].alt;
					groups[$oldP] = $oldGroup;
					false
				} else if ($c == '{') {														// { = group
					for (; !($ok = inner($o, $o, $p + 1)) && ptn{$p = alts[$p]} == '|';) ;
					false
				} else {																	// [ ? * % ~ = wildcard matching
					$charset = '';
					$test = length;
					if ($c == '[') {															// [ ] = character set
						$i = charsetSpan($p);
						$cs = ptn{$p + 1:$i - 2};
						$p += $i;
						if ($cs != '') {														// empty [] means match anything
							$test = span;
							if ($cs{0} == '^' && $cs != '^') {						// if beginning with ^ (and not only [^]), reverse set by using 'find' function instead of 'span' further down
								$cs = $cs{1:};
								$test = find;
							};
							for (; $cs != ''; $cs = $cs{$i:}) {
								$charset #= $cs{:$i = 1 + find($cs{1:}, '-')};	// add all chars up until next - (if it isn't the first or last character)
								if ($i < length($cs) - 1) {
									$f = ordinal($cs{$i - 1}) + 1;				// add range of chars
									$t = ordinal($cs{$i + 1});
									for (; $f <= $t; ++$f) $charset #= char($f);
									$i += 2;
								}
							}
						}
					};
					
					$p += ($f = span(ptn{$p:}, '?'));								// min length is number of ?
					if (($y = ptn{$p}) == '%' || $y == '*') {							// if * (greedy) or % (lazy) repeat, test entire string further down
						$d = (if ($y == '%') +1 else -1);										// search forwards or backwards depending on greediness
						++$p;
						$x = src{$o:};
					} else {
						$d = -1;
						$p += ($i = span(ptn{$p:}, '~'));									// max length is number of ~
						if ($i == 0 && $f == 0) $f = 1;		// no '?' and no '~' = match 1 exactly
						$x = src{$o:$i += $f};
					};
					$t = $test($x, $charset);									// figure out max length using span, find or length functions depending on character set
					if ($f > $t) $ok = false
					else $ok = inner($o + (if ($d < 0) $t else $f), $o + (if ($d < 0) $f else $t), $p);
					false
				};
			}; ) ;
			if (!$ok) [capture].n = $captureMark;
		};
		$ok
	};

	// TODO : detect errors such as '|' outside of '{}' and unbalanced '{' or '}'
	prepare => {
		args(@$p);
		$start = $p;
		$prev = $p;
		$repeat = false;
		++$p;
		for (; {
				$p += find(ptn{$p:}, '`[{(|.)}');
				(($c = ptn{$p}) != ')' && $c != '}')							// end of string or group (can be '', } or |)
			}; ) {
			if ($c == '') throw('Unbalanced { or (')
			else if ($c == '`') $p += 2														// ` = escape
			else if ($c == '{' || $c == '(') $p = prepare($p)								// ( { = group
			else if ($c == '.' && ptn{$p:3} == '...') { begins[$p] = $start; $p += 3; $repeat = true; }
			else if ($c == '.') ++$p
			else if ($c == '|') {
				begins[$p] = $start;
				repeats[$p] = (if ($repeat) $prev else void);
				$repeat = false;
				alts[$prev] = $p;
				$prev = $p;
				++$p;
			} else $p += charsetSpan($p);																	// [ ] = character set
		};
		begins[$p] = $start;
		repeats[$p] = (if ($repeat) $prev else void);
		$repeat = false;
		alts[$prev] = $p;
		ends[$start] = $p;
		groups[$start] = -1;
		++$p;
	};

	for ($p = 0; {
			$p += find(ptn{$p:}, '`[{(');
			(($c = ptn{$p}) != '')							// end of string or group (can be '', } or |)
		}; ) {
		if ($c == '`') $p += 2														// ` = escape
		else if ($c == '{' || $c == '(') $p = prepare($p)								// ( { = group
		else $p += charsetSpan($p);																	// [ ] = character set
	};
	
	usrc = upper(src);
	inner(offset, offset, 0);
};

::nuexp = function {
	captured.n = 0;
	success = nuexpLo($0, 0, $1, @captured);
	for (i = 0; i < captured.n && i < $n - 2; ++i) { [$[2 + i]] = captured[i].string; };
	success;
};

::charsetSpan = function {
	$i = find($0, ']') + 1;
	if ($0{$i:1} == ']') ++$i					// special handling of terminating ]] or ]^]
	else if ($0{$i:2} == '^]') $i += 2;
	$i;
};

::blurp = function {
	args(@ptn, @finder, @spanner, @term);
	[finder] = function { 0 };
	[spanner] = length;
	$charset = '';
	$c = ptn{0};
	if ($c == '[') {															// [ ] = character set
		i = charsetSpan(ptn);
		$cs = ptn{1:i - 2};
		if ($cs != '') {														// empty [] means match anything
			[finder] = find;
			[spanner] = span;
			if ($cs{0} == '^' && $cs != '^') {						// if beginning with ^ (and not only [^]), reverse set by using 'find' function instead of 'span' further down
				$cs = $cs{1:};
				swap(finder, spanner);
			};
			for (; $cs != ''; $cs = $cs{$i:}) {
				$charset #= $cs{:$i = 1 + find($cs{1:}, '-')};	// add all chars up until next - (if it isn't the first or last character)
				if ($i < length($cs) - 1) {
					$f = ordinal($cs{$i - 1}) + 1;				// add range of chars
					$t = ordinal($cs{$i + 1});
					for (; $f <= $t; ++$f) $charset #= char($f);
					$i += 2;
				}
			}
		}
	} else if (span($c, '`*?[') == 0) {
		for (i = 0; {
			$charset #= ptn{i:j = find(ptn{i:}, '`*?[')};
			i += j;
			if (ptn{i} == '`') {
				++i;
				true;
			} else false;
		}; );
		[finder] = search;
	};
	[term] = $charset;
	ptn{i:};
};

