// Bugs: doesnt support en passant or castling, doesnt know when check-mate occurs

::quicksort = function { // (@array, fromIndex, toIndex, compareFunction)
	args(@array, @bottom, @top, @comp);
	for (; bottom + 1 < top ;) {
		low = bottom;
		high = top;
		middleV = [array][(low + high) >> 1];
		for (; low < high ;) {
			for (; low <= high
					&& comp([array][low], middleV) <= 0
					&& comp([array][high], middleV) >= 0 ;) {
				++low;
				--high;
			};
			for (; low <= high && comp([array][high], middleV) > 0; --high);
			for (; low <= high && comp([array][low], middleV) < 0; ++low);
			if (low < high) swap(@[array][low], @[array][high]);
		};
		quicksort(array, bottom, low - 1, comp);
		bottom = low;
	};
	if (comp([array][bottom], [array][top]) > 0) swap(@[array][bottom], @[array][top]);
};

prune(@::scores);
prune(@::rowScores);
map(@::scores,    'R', +50, 'N', +30, 'B', +30, 'Q', +90, 'K', +1000, 'P', +10);
map(@::rowScores, 'R', 1, 'N', 1, 'B', 1, 'Q', 1, 'K', 1, 'P', 1);
foreach(@::scores, >{ ::colors[$1] = 'W'; ::colors[lower($1)] = 'B'; ::scores[lower($1)] = -$2 - ::rowScores[$1] * 7; ::rowScores[lower($1)] = ::rowScores[$1]; });
::colors['.'] = void;
::king['W'] = 'K';
::king['B'] = 'k';

::onBoard = function { (0 <= $0 && $0 < 8 && 0 <= $1 && $1 < 8) };
::isPiece = function { ($0 != '.'); };
::turnColor = function { $0{65} };
// ::getSquare = function { args(@state, @x, @y); assert(>onBoard(x, y)); state{y * 8 + x} };
::getSquare = function { $0{$2 * 8 + $1} };
::noKing = function { find($0{:64}, king[$0{65}]) == 64; };

::liftUp = function {
	// args(@state, @x, @y);
	i = $2 * 8 + $1;
	$0{:i} # '.' # $0{i + 1:};
};

::putDown = function {
	// args(@state, @piece, @x, @y);
	i = $3 * 8 + $2;
	$0{:i} # $1 # $0{i + 1:65 - i - 1} # (if (colors[$1] == 'W') 'B' else 'W')
};

::scoreCounter = 0;
::calcScore = function {
++::scoreCounter;
	s = 0;
	for (i = 0; (i += span($0{i:}, '.')) < 64; ++i) {
		p = $0{i};
		s += scores[p] + rowScores[p] * (i >> 3);
	};
	if (turnColor($0) == 'B') -s else s;
};

::unicode = false;
map(@::unicodeMap	, 'R', '♖', 'N', '♘', 'B', '♗', 'Q', '♕', 'K', '♔', 'P', '♙'
					, 'r', '♜', 'n', '♞', 'b', '♝', 'q', '♛', 'k', '♚', 'p', '♟', '.', '☐');
::display = function {
	print("\n" # (if (turnColor($0) == 'W') 'White''s turn' else 'Black''s turn') # ' (score: ' # calcScore($0) # ")\n");
	if (unicode) {
		for (y = 7; y >= 0; --y) {
			s = (y + 1) # ' | ';
			for (x = 0; x < 8; ++x) s #= unicodeMap[$0{y * 8 + x}] # " ";
			print(s);
		};
		print("    ---------------\n    A B C D E F G H\n");
	} else {
		for (y = 7; y >= 0; --y) {
			s = (y + 1) # ' | ';
			for (x = 0; x < 8; ++x) s #= $0{y * 8 + x} # ' ';
/* FIX : drop?			s = (y + 1) # ' | ';
			for (x = 0; x < 8; ++x) {
				p = $0{y * 8 + x};
				s #= (if (p == '.' && ((x ^ y) & 1) == 0) '*' else p) # ' ';
			}*/
			print(s);
		};
		print("    ---------------\n    A B C D E F G H\n");
	};
};
  
::singleStep = function {
	args(@state, @x, @y, @p, @exec, @dx, @dy);
	if (!onBoard(x += dx, y += dy) || colors[getSquare(state, x, y)] == colors[p]) true
	else exec(putDown(state, p, x, y))
};

::manySteps = function {
	args(@state, @x, @y, @p, @exec, @dx, @dy);
	color = colors[p];
	for (continue = true; {
		if (!onBoard(x += dx, y += dy) || colors[q = getSquare(state, x, y)] == color) false
		else (continue = exec(putDown(state, p, x, y))) && !isPiece(q);
	}; ) ;
	continue
};

::rotate = function {
	// args(@movement, @state, @x, @y, @p, @exec, @a, @b);
	$0($1, $2, $3, $4, $5, +$6, +$7) &&
	$0($1, $2, $3, $4, $5, -$7, +$6) &&
	$0($1, $2, $3, $4, $5, -$6, -$7) &&
	$0($1, $2, $3, $4, $5, +$7, -$6);
};

map(@::moves
	, 'P', function {
		args(@state, @x, @y, @p, @exec);
		continue = true;
		if ((color = colors[p]) == 'W') { capture = 'B'; d = 1; first = 1; newPiece = (if (y == 6) 'q' else p); }
		else { capture = 'W'; d = -1; first = 6; newPiece = (if (y == 1) 'Q' else p); };
		if (continue && !isPiece(getSquare(state, x, y + d))) {
			continue = exec(putDown(state, newPiece, x, y + d));
			if (continue && y == first && !isPiece(getSquare(state, x, y + d + d))) {
				continue = exec(putDown(state, p, x, y + d + d));
			};
		};
		if (continue && x > 0 && colors[getSquare(state, x - 1, y + d)] == capture) {
			continue = exec(putDown(state, newPiece, x - 1, y + d));
		};
		if (continue && x < 7 && colors[getSquare(state, x + 1, y + d)] == capture) {
			continue = exec(putDown(state, newPiece, x + 1, y + d));
		};
		continue
	}
	, 'R', function {
		rotate(manySteps, $0, $1, $2, $3, $4, +1, 0);
	}
	, 'B', function {
		rotate(manySteps, $0, $1, $2, $3, $4, +1, +1);
	}
	, 'Q', function {
		rotate(manySteps, $0, $1, $2, $3, $4, +1, 0) &&
		rotate(manySteps, $0, $1, $2, $3, $4, +1, +1);
	}
	, 'N', function {
		rotate(singleStep, $0, $1, $2, $3, $4, +2, +1) &&
		rotate(singleStep, $0, $1, $2, $3, $4, +1, +2);
	}
	, 'K', function {
		rotate(singleStep, $0, $1, $2, $3, $4, +1, 0) &&
		rotate(singleStep, $0, $1, $2, $3, $4, +1, +1);
	}
);
foreach(@::moves, >::moves[lower($1)] = $2);

::tryAll = function {
	args(@state, @exec);
	color = turnColor(state);
	continue = true;
	for (y = 0; continue && y < 8; ++y) {
		for (x = 0; continue && x < 8; ++x) {
			if (colors[p = getSquare(state, x, y)] == color) continue = moves[p](liftUp(state, x, y), x, y, p, exec);
		}
	};
	continue
};

// Note: if no king return -1000 directly, since no more turns are possible after this happens
::divider = function {
	args(@state, @count, @drop, @noKingAlpha, @alpha, @beta);
	if (noKing(state)) alpha = -noKingAlpha
	else if (count <= 0) {
		tryAll(state, >{ alpha = max(alpha, -calcScore($0)); (alpha < beta); });
	} else if (count >= 30) {
		tryAll(state, >{ alpha = max(alpha, -divider($0, floor(count * drop), drop, -1000, -beta, -alpha)); (alpha < beta); });
	} else {
		n = 0;
		tryAll(state, >{ b = @branches[n]; sorted[n] = b; [b].state = $0; [b].score = -calcScore($0); ++n; true; });
		quicksort(@sorted, 0, n - 1, >[$1].score - [$0].score);
		n = min(count, n);
		for (i = 0; alpha < beta && i < n; ++i) alpha = max(alpha, -divider([sorted[i]].state, floor(count * drop), drop, -1000, -beta, -alpha));
	};
	alpha
};

compose(@::depthCounts, 13, 7, 3, 0, 0, 0, 0);
::useDepthCounts = @::depthCounts;
// Note: if no king return directly, since no more turns are possible after this happens, in case depth <= 1 this actually means a checkmate, so we return the special value -2000
::divider3 = function {
	args(@state, @depth, @alpha, @beta);
	count = [useDepthCounts][depth];
	if (noKing(state)) alpha = if (depth <= 1) -2000 else -calcScore(state)
	else if (count <= 0) {
		tryAll(state, >{ alpha = max(alpha, -calcScore($0)); (alpha < beta); });
	} else {
		n = 0;
		tryAll(state, >{ b = @branches[n]; sorted[n] = b; [b].state = $0; [b].score = -calcScore($0); ++n; true; });
		quicksort(@sorted, 0, n - 1, >[$1].score - [$0].score);	
if (state == 'R....BNRP..KPPPP.PP.....................p..B.pp..p..n..prnb.kb.r;B') {
	for (i = 0; i < count && i < n; ++i) print([sorted[i]].state # ' ' # [sorted[i]].score);
};
		n = min(count, n);
		for (i = 0; alpha < beta && i < n; ++i) alpha = max(alpha, -divider3([sorted[i]].state, depth + 1, -beta, -alpha));
	};
	alpha
};

::divider4 = function {
	args(@state, @depth, @alpha, @beta);
	count = [useDepthCounts][depth];
	beta = min(beta, calcScore(state) + 50);
	if (noKing(state)) alpha = if (depth <= 1) -2000 else calcScore(state)
	else if (count <= 0) {
		tryAll(state, >{ alpha = max(alpha, -calcScore($0)); (alpha < beta); });
	} else {
		n = 0;
		tryAll(state, >{ b = @branches[n]; sorted[n] = b; [b].state = $0; [b].score = -calcScore($0); ++n; true; });
		quicksort(@sorted, 0, n - 1, >[$1].score - [$0].score);	
//		n = min(count, n);
		for (i = 0; alpha < beta && i < n; ++i) alpha = max(alpha, -divider4([sorted[i]].state, depth + 1, -beta, -alpha));
	};
	alpha
};

// Note: if no king return -1000 directly, since no more turns are possible after this happens
::divider2 = function {
	args(@state, @ratio, @drop, @min, @alpha, @beta);
	if (ratio <= min) {
		tryAll(state, >{ alpha = max(alpha, -calcScore($0)); (alpha < beta); });
	} else if (noKing(state)) alpha = -1000
	else if (ratio >= 1.0) {
		tryAll(state, >{ alpha = max(alpha, -divider2($0, ratio * drop, drop, min, -beta, -alpha)); (alpha < beta); });
	} else {
		n = 0;
		tryAll(state, >{ b = @branches[n]; sorted[n] = b; [b].state = $0; [b].score = -calcScore($0); ++n; true; });
		quicksort(@sorted, 0, n - 1, >[$1].score - [$0].score);
		n *= ratio;
		for (i = 0; alpha < beta && i < n; ++i) alpha = max(alpha, -divider2([sorted[i]].state, ratio * drop, drop, min, -beta, -alpha));
	};
	alpha
};

// Note: if no king return -1000 directly, since no more turns are possible after this happens
::alphabeta = function {
	args(@state, @depth, @alpha, @beta);
	if (noKing(state)) alpha = -1000
	else tryAll(state, if (depth == 1) >{ alpha = max(alpha, -calcScore($0)); (alpha < beta); }
			else >{ alpha = max(alpha, -alphabeta($0, depth - 1, -beta, -alpha)); (alpha < beta); });
	alpha
};

::minimax = function {
	args(@state, @depth);
	if (depth == 0) calcScore(state)
	else {
		maxi = -infinity; // TODO : support inf in pika i think, http://fogbugz.nuedge.net/default.asp?7844
		tryAll(state, >{ maxi = max(maxi, -minimax($0, depth - 1)); true; });
		maxi;
	}
};

::help = function {
	print("Enter moves like this: D2-D4.\nType 'exit' to quit.\nType 'restart' to restart.\n"
			# "Type 'play' to have the computer play your color instead.\nType 'undo' to take back last move.");
};

compose(@depthCountsW, 13, 4, 0, 0, 0, 0, 0);
compose(@depthCountsB, 13, 4, 0, 0, 0, 0, 0);

whiteCounter = 0;
blackCounter = 0;
winCounter = 0;
turns = 0;
state = 'RNBQKBNRPPPPPPPP................................pppppppprnbqkbnr;WCC-';
//state = 'RNBQKBNRPP..PPPP..P........P..b....p............ppp.pppprn.qkbnr;W';
state = 'R....BNRP..KPPPP.PP..........B..........p.q..pp..p..n..prnb.kb.r;BCC-;0';

display(state);
if (false)
for (checkmate = false; !checkmate; ) {
	print(state);
	maxi = -infinity;
	isWhite = (turnColor(state) == 'W');
	if (isWhite) {
		::useDepthCounts = @depthCountsW;
		funcy = divider3;
	} else {
		::useDepthCounts = @depthCountsB;
		funcy = divider4;
	};
	::scoreCounter = 0;
	tryAll(state, >{
		if (!exists(@done[$0])) {
			score = -funcy($0, 0, -infinity, -maxi);
			if (score > maxi) {
				maxi = score;
				state = $0;
			}
		};
		true
	});
	if (isWhite) whiteCounter += scoreCounter
	else blackCounter += scoreCounter;
	print('Tested ' # scoreCounter # ' (tot white: ' # whiteCounter # ', tot black: ' # blackCounter # ')');
	print('maxi: ' # maxi);
	done[state] = true;
	display(state);
	++turns;
	if (maxi <= -2000 || turns >= 200) {
		if (maxi <= -2000) print('CHECKMATE');
		// checkmate = true;
		if (maxi <= -2000 && blackCounter < whiteCounter * 1.1 && isWhite) {
			if (++winCounter >= 2) {
				print('!!!!!!!!!!!!!! IMPROVEMENT !!!!!!!!!!!!!!');
				clone(@depthCountsB, @depthCountsW);
				print('--- good ---'); dump(@depthCountsW);
			}
		} else {
			winCounter = 0;
			clone(@depthCountsW, @depthCountsB);
			for (i = 0; i < 4; ++i) depthCountsB[i] += round(random(4) - 2);
			depthCountsB[0] = max(depthCountsB[0], 1);
			for (i = 1; i < 4; ++i) depthCountsB[i] = max(depthCountsB[i], 0);
			print('--- testing ---'); dump(@depthCountsB);
		};
		prune(@done);
		whiteCounter = 0;
		blackCounter = 0;
		turns = 0;
		state = 'RNBQKBNRPPPPPPPP................................pppppppprnbqkbnr;WCC-';
	}
};

history.n = 0;
for (; {
	history[history.n] = state;
	s = replace(upper(input("> ")), "-", "");
	ok = false;
	if (s == "EXIT") false
	else if (s == "UNDO") {
		if (history.n > 0) state = history[--history.n];
		display(state);
		true;
	} else if (s == "RESTART") {
		state = 'RNBQKBNRPPPPPPPP................................pppppppprnbqkbnr;WCC-';
		history.n = 0;
		display(state);
		true;
	} else {
		if (s == "PLAY") ok = true
		else if (length(s) != 4) help()
		else {
			fromX = ordinal(s{0}) - ordinal('A');
			fromY = ordinal(s{1}) - ordinal('1');
			toX = ordinal(s{2}) - ordinal('A');
			toY = ordinal(s{3}) - ordinal('1');
			if (!onBoard(fromX, fromY) || !onBoard(toX, toY)) print("Enter moves like this: D2-D4. Type 'exit' to quit.")
			else {
				color = turnColor(state);
				p = getSquare(state, fromX, fromY);
				t = getSquare(state, toX, toY);
				if (!isPiece(p)) print("No piece on " # s{0:2})
				else if (colors[p] != color) print("The piece on " # s{0:2} # " is not yours")
				else if (colors[t] == color) print(s{2:2} # " is occupied")
				else {
					newState = liftUp(state, fromX, fromY);
					moves[p](newState, fromX, fromY, p, >{
						t = getSquare($0, toX, toY);
						if (isPiece(t) && colors[t] == color) {
							newState = $0;
							ok = true;
						};
						!ok;
					});
					if (!ok) print(s{0:2} # " to " # s{2:2} # " is not a legal move")
					else {
						if (tryAll(newState, >{
							if (noKing($0)) { ok = false; print("Your king is in check"); false; }
							else true
						})) {
							state = newState;
						}
					}
				}
			};
			if (ok) display(state)
		};
		if (!ok) true
		else {
			history.n++;
			maxi = -infinity;
			print('Thinking...');
	::scoreCounter = 0;
			tryAll(state, >{
				score = -divider3($0, 0, -infinity, -maxi);
				if (score > maxi) {
					maxi = score;
					print($0 # ' ' # score);
					state = $0;
				};
				true
			});
			display(state);
			print('Tested: ' # scoreCounter # ', satisfaction: ' # maxi);
			if (maxi > -2000) true
			else upper(input('Checkmate! Do you wish to play another game (y/n)? ')){0} == 'Y'
		}
	}
}; ) ;
