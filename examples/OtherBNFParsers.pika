/*

100% recursive, works with all non left-recursive grammars, but eats way too much stack

::bnf.match = function {
	args(@sym, @src, @head, @tail);
	if (head == '' && tail == '') ( src == '' )
	else {
		alt = head{:i = find(head, '|')};
		next = head{i:};
		c = alt{0};
		if (c == '') {
			ok = bnf.match(sym, src, tail, '');
		} else if (c == "'") {
			i = find(alt{1:}, "'");
			ok = (src{:i} == alt{1:i} && bnf.match(sym, src{i:}, alt{2 + i:}, tail));
		} else if (c == '<') {
			i = find(alt{1:}, '>');
			nsym = @[ascend(sym)][alt{1:i}];
			ok = bnf.match(nsym, src, [nsym], alt{2 + i:} # tail);
		} else if (c == '[') {
			i = find(alt, ']') + 1;
			ok = (wildmatch(src{0}, alt{:i}) && bnf.match(sym, src{1:}, alt{i:}, tail));
		} else throw("Invalid syntax");
			
		( ok || next{0} == '|' && bnf.match(sym, src, next{1:}, tail) );
	}
};

*/

/*

trying to eliminate recursion, but it feels impossible if we should allow arbitrary "look ahead", e.g. the tail concept...

::depth = 0;
::bnf.match = function {
print(' depth: ' # ++::depth);
	args(@sym, @src, @head, @tail);
	for (repeat = true; repeat;) {
						print('  match : ' # src # '   ->   ' # head # '   (tail: ' # tail # ')');
		repeat = false;
		if (head == '' && tail == '') {
			ok = ( src == '' )
		} else {
			p = head{:i = find(head, '|')};
			next = head{i:};
			s = src;
			for (; {
						print(s # '   ->   ' # p);
				c = p{0};
				if (c == '') {
					if (next{0} != '|' && tail != '') {
						p = tail;
						tail = '';
						( true )
					} else
//					if (next{0} == '|' && tail != '') {
//					print("rev recurse: " # tail # " (next: " # next # ")");
//						ok = bnf.match(sym, src, next{1:} # tail, '');
//						next = '|' # tail;
//						( false )
//					} else
					 {
					print("recurse: " # tail # " (next: " # next # ")");
						ok = bnf.match(sym, s, tail, '');
						( false )
					}
				} else if (c == "'") {
					i = find(p{1:}, "'");
					if (s{:i} == p{1:i}) {
						s = s{i:};
						p = p{2 + i:};
						( true )
					} else {
						( ok = false )
					}
				} else if (c == '<') {
					i = find(p{1:}, '>');
					nsym = @[ascend(sym)][p{1:i}];
					if (next{0} != '|') {
						tail = p{2 + i:} # tail;
						sym = nsym;
						head = [nsym];
						p = head{:i = find(head, '|')};
						next = head{i:};
						src = s;
						( true )
					} else {
						ok = bnf.match(nsym, s, [nsym], p{2 + i:} # tail);
						( false )
					}
				} else if (c == '[') {
					i = find(p, ']') + 1;
					if (wildmatch(s{0}, p{:i})) {
						s = s{1:};
						p = p{i:};
						( true )
					} else {
						( ok = false )
					}
				} else throw("Invalid syntax");
			}; );
				
	//if (ok) print(sym # '  :  ' # src # '  ->  ' # head);
			if (!ok) {
				if (next{0} == '|') {
					s = src;
					head = next{1:};
					repeat = true;
				}
			}
		}
	};
--::depth;
	( ok )
};

*/
