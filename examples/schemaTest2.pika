#! /usr/local/bin/PikaCmd

include('systools.pika');

	::run.root = 'lab/';

include('stdlib.pika');
include('debug.pika');
include('initPPEG.pika');
include('objects.pika');

calcLineAndColumn = function {
	args(@source, @offset, @line, @column);
	l = 0;
	lb = 0;
	for (i = 0; i <= offset; i += find(source{i:}, "\n") + 1) {
		lb = i;
		++l;
	};
	[line] = l;
	[column] = (offset - lb) + 1;
};

formatError = function {
	args(@source, @offset, @message);
	calcLineAndColumn(source, offset, @line, @column);
	// FIX : how?
/*	print("--------");
	s = (if (offset - 200 > 0) '...' else '')
		# source{offset - 200:200}
		# ' <!!!!> '
		# source{offset:200}
		# (if (offset + 200 < length(source)) '...' else '');
	print(s);
	print("--------");*/
	( bake("Line: {line}, column: {column} (@{offset}) {message}") )
};

createSchemaParser = function {
	print('Compiling Schema parser...');
	cushySchemaSource = load(::run.root # 'cushySchema.ppeg');
	ok = ppeg.compileFunction(cushySchemaSource, @schemaParser, @offset);
	if (!ok) {
		throw(formatError(cushySchemaSource, offset, bake("Error compiling Cushy Schema parser")));
	};

	print('Parsing Schema...');
	cushySchemaSource = load(::run.root # 'cushySchemaTest.schema');
	ok = schemaParser(cushySchemaSource, @schema, @offset);
	if (!ok) {
		throw(formatError(cushySchemaSource, offset, bake("Error parsing Cushy Schema")));
	};

	print('Compiling PEGs...');
	pegSource = '';
	foreach([schema].pegs, >pegSource #= $1 # ' <- ' # $2 # LF);
	ok = ppeg.compileFunction(pegSource, @[schema].pegParsers, @offset);
	if (!ok) throw(bake("Error parsing Schema PEGs"));

	errorCount = 0;

	print('Checking Schema references...');
	iterate([schema].refs, >{
		offset = [$2].offset;
		name = [$2].name;
		kind = [$2].kind;
		container = (if (kind === 'rule') [schema].rules else [schema].pegs);
		if (!exists(@[container][name])) {
			print(formatError(cushySchemaSource, offset, bake("{if (kind === 'rule') 'rule' else 'peg'} {name} is missing")));
			++errorCount;
		}
	});

	if (errorCount != 0) {
		throw("One or more errors occured");
	};

	gc();

	( schema )
};

if (false) {	// all alternatives (text implementation)
	makeError = function {
		args(@message, @node);
		if (node == void) {
			( message )
		} else {
			calcLineAndColumn(cushySource, [node].begin, @line, @column);
			( bake("{message} at line: {line}, column: {column}") )
		}
	};

	makeEmptyError = function { ( '' ) };

	joinErrors = function {
		args(@prior, @current);
		exists = false;
	//	tokenize(prior, >if ($0 === current) exists = true);
		if (!exists) {
			if (prior !== '') prior #= "\n";
			prior #= current;
		};
		( prior )
	};

	errorToString = function {
		s = '';
		tokenize($0, >s #= (if (s !== '') "  or ") # $0 # LF);
		( chop(s, 1) )
	}
} else if (false) {	// just the alternative that parsed the most text
	makeError = function { ( new(Container, 'message', $0, 'node', $1, 'score', 0) ) };

	makeEmptyError = function { ( void ) };

	joinErrors = function {
		args(@prior, @current);
		if (prior == void || [[prior].node].begin < [[current].node].begin) ( current ) else ( prior )
	};

	errorToString = function {
		args(@err);
		calcLineAndColumn(cushySource, [[err].node].begin, @line, @column);
		( bake("{[err].message} at line: {line}, column: {column}") )
	}
} else if (false) {	// all as array
	makeError = function {
		( new(Array, new(Container, 'message', $0, 'node', $1, 'prior', void, 'score', 0)) )
	};

	makeEmptyError = function { ( new(Array) ) };

	joinErrors = function {
		args(@prior, @current);
		joined = new(Array);
		inject(prior, 0, [prior].n, joined, 0);
		inject(current, 0, [current].n, joined, [joined].n);
		( joined )
	};

	errorToString = function {
		args(@err);
		e = [err][0];
		calcLineAndColumn(cushySource, [[e].node].begin, @line, @column);
		s = bake("{[e].message} {[e].score} at line: {line}, column: {column}");
		for (i = 1; i < [err].n; ++i) { e = [err][i]; s #= bake("\n  or {[e].message} {[e].score}"); };
		( s )
	}	
} else if (true) {
	makeError = function {
		( new(Array, new(Container, 'message', $0, 'node', $1, 'score', 0)) )
	};

	makeEmptyError = function { ( new(Array) ) };

	NO_ERROR = void;
	MISSING_VALUE_ERROR = makeError('missing value', void);

	joinErrors = function {
		args(@prior, @current);
		if ([prior].n == 0) {
			( current )
		} else if ([[current][0]].score > [[prior][0]].score) {
//print(errorToString(current));
//print("  has higher prio than:  ");
//print(errorToString(prior));
//print("");
			( current )
		} else if ([[current][0]].score < [[prior][0]].score) {
//print(errorToString(current));
//print("  has lower prio than:  ");
//print(errorToString(prior));
//print("");
			( prior )
		} else {
//print(errorToString(current));
//print("  has same prio as:  ");
//print(errorToString(prior));
//print(" == ");
			joined = new(Array);
			inject(prior, 0, [prior].n, joined, 0);
			inject(current, 0, [current].n, joined, [joined].n);
//print(errorToString(joined));
//print("");
			( joined )
		}
	};

	errorToString = function {
		args(@err);
		e = [err][0];
		calcLineAndColumn(cushySource, [[e].node].begin, @line, @column);
		s = bake("{[e].message} {[e].score} at line: {line}, column: {column}");
		for (i = 1; i < [err].n; ++i) { e = [err][i]; s #= bake("\n  or {[e].message} {[e].score}"); };
		( s )
	}	
};

countMembers = function { n = 0; foreach($0, >++n); ( n ) };
countTrue = function { n = 0; foreach($0, >if ($2) ++n); ( n ) };

// crossList will contain true or false for every property *found* and checked in the validating struct, false = one or several validations (not guaranteed all) on this property has failed
validateKVAlts = function {
	args(@schema, @node, @elem, @crossList);
	error = makeEmptyError();

	alts = [elem].seqs;
	bestCount = 0;
	for ({ i = 0; n = [alts].n }; i < n && error != NO_ERROR; ++i) {
		foreach(@altCrossList, >[$0] = false);	// all found properties from last attempt is now considered invalid (but still found for slightly better error reports)
		thisError = validateKVSequence(schema, node, [alts][i], @altCrossList);
		error = (if (thisError == NO_ERROR) NO_ERROR else joinErrors(error, thisError));
	};
	clone(@altCrossList, crossList);
	( error )
};

validateKVOpt = function {
	args(@schema, @node, @elem, @crossList);
	error = validateKVSequence(schema, node, [elem].seq, @optCrossList);
	if (error == NO_ERROR) {
		clone(@optCrossList, crossList);
	} else if (countMembers(@optCrossList) == 0) {
		error = NO_ERROR;
	};
	( error )
};

validateUnmatched = function {
	args(@schema, @node, @elem, @crossList);

	error = NO_ERROR;
	foreach([node].value, >if (error == NO_ERROR && !exists(@[crossList][$1])) {
		error = validateValue(schema, $2, [elem].template);
		[crossList][$1] = (error == NO_ERROR);
	});
	( error )
};

validateKV = function {
	args(@schema, @node, @elem, @crossList);

	key = [elem].key;
	if (!exists(r = @[[node].value][key])) {
		( makeError(bake("missing '{key}'"), node) )
	} else {
		error = validateValue(schema, [r], [elem].value);
		[crossList][key] = (error == NO_ERROR);
		( error )
	}
};

map(@KV_SEQ_VALIDATORS
		, 'kv', validateKV
		, 'opt', validateKVOpt
		, 'alts', validateKVAlts
		, 'unmatched', validateUnmatched);

validateKVSequence = function {
	args(@schema, @node, @sequence, @crossList);
	error = NO_ERROR;
	for ({ i = 0; n = [sequence].n }; i < n && error == NO_ERROR; ++i) {
		elem = [sequence][i];
		error = KV_SEQ_VALIDATORS[[elem].kind](schema, node, elem, crossList);
	};
if (error != NO_ERROR) {
asdfasdf = countTrue(crossList);
for (z = 0; z < [error].n; ++z) [[ error ][z]].score = asdfasdf;
};
	( error )
};

validateStruct = function {
	args(@schema, @node, @rule);
	if (node == void) ( MISSING_VALUE_ERROR )
	else if ([node].type !== 'struct') {
		( makeError(bake("expected struct (not {TYPE_DESCS[[node].type]})"), node) )
	} else {
		error = validateKVSequence(schema, node, [rule].seq, @crossList);
		if (error == NO_ERROR) {
			foreach([node].value, >{
				if (error == NO_ERROR && (!exists(@crossList[$1]) || !crossList[$1])) {
					error = makeError(bake("unrecognized or irrelevant property: '{$1}'"), node);
		[[ error ][0]].score = countTrue(@crossList);
				}
			})
		};
		( error )
	}
};

validateList = function {
	args(@schema, @node, @rule);
	if (node == void) ( MISSING_VALUE_ERROR )
	else if ([node].type !== 'array') {
		( makeError(bake("expected array (not {TYPE_DESCS[[node].type]})"), node) )
	} else {
		a = [node].value;
		v = [rule].values;
		n = [v].n;
		if ([a].n > n) {
			error = makeError(bake("expected max {n} array elements (got {[a].n})"), node);
		} else {
			error = NO_ERROR;
			for (i = 0; i < n && error == NO_ERROR; ++i) {
				e = [v][i];
				// FIX : sep loops
				if (i >= [a].n) {
					if (validateValue(schema, void, e, @dummy) != NO_ERROR) {
						error = makeError(bake("missing array element(s)"), node);
					}
				} else {
					error = validateValue(schema, [a][i], e)
				}
			}
		};
		( error )
	}
};

validateArray = function {
	args(@schema, @node, @rule);
	if (node == void) ( MISSING_VALUE_ERROR )
	else if ([node].type !== 'array') {
		( makeError(bake("expected array (not {TYPE_DESCS[[node].type]})"), node) )
	} else {
		a = [node].value;
		t = [rule].template;
		error = NO_ERROR;
		for ({ i = 0; n = [a].n }; i < n && error == NO_ERROR; ++i) {
			error = validateValue(schema, [a][i], t);
		};
		( error )
	};
};

validateRule = function { ( validateValue($0, $1, [[$0].rules][[$2].name]) ) };

validatePeg = function {
	args(@schema, @node, @rule);
	if (node == void) ( MISSING_VALUE_ERROR )
	else if ([node].type !== [rule].type) {
		( makeError(bake("expected {TYPE_DESCS[[rule].type]} (not {TYPE_DESCS[[node].type]})"), node) )
	} else if ([rule].peg == void
			|| ([schema].pegParsers([node].value, @dummy, @offset, [rule].peg)
			&& offset >= length([node].value))) {
		( NO_ERROR )
	} else {
		( makeError(bake("expected valid '{[rule].peg}' (not '{[node].value}')"), node) )
	}
};

validateOpt = function {
	args(@schema, @node, @rule);
	(if (node == void) NO_ERROR else validateValue(schema, node, [rule].value))
};

validateAlts = function {
	args(@schema, @node, @rule);
	alts = [rule].values;
	error = makeEmptyError();
	for ({ i = 0; n = [alts].n }; i < n && error != NO_ERROR; ++i) {
		thisError = validateValue(schema, node, [alts][i]);
		error = (if (thisError == NO_ERROR) NO_ERROR else joinErrors(error, thisError));
	};
	( error )
};

map(@TYPE_DESCS, 'string','quoted string', 'text','unquoted text', 'struct','struct'
		, 'array','array', 'void','void / no value');

validateLiteral = function {
	args(@schema, @node, @rule);
	if (node == void) ( MISSING_VALUE_ERROR )
	else if ([node].type !== [rule].type) {
		( makeError(bake("expected {TYPE_DESCS[[rule].type]} (not {TYPE_DESCS[[node].type]})"), node) )
	} else if ([node].value !== [rule].literal) {
		( makeError(bake("expected '{[rule].literal}' (not '{[node].value}')"), node) )
	} else {
		( NO_ERROR )
	}
};

validateAny = function {
	args(@schema, @node, @rule);
	if (node == void) ( MISSING_VALUE_ERROR )
	else ( NO_ERROR )
};

/*
#	Value =
#		{ kind: 'struct', seq: KVSequence }			// numbstrict type must be struct
#		| { kind: 'array', template: Value }		// numbstrict type must be array (0 or more matches)
#		| { kind: 'list', values: [ Value, ... ] }	// numbstrict type must be array (exact length or less if last items are optional)
#		| { kind: 'rule', name: string }
#		| { kind: 'literal', literal: string }		// numbstrict type must be string or text
#		| { kind: 'text', peg: peg|void }			// numbstrict type must be text, void = match any
#		| { kind: 'string', peg: peg|void }			// numbstrict type must be string, void = match any
#		| { kind: 'opt', value: Value }
#		| { kind: 'alts', values: [ Value, ... ] }
#		| { kind: 'any' }							// anything goes!
*/


map(@VALIDATORS
		, 'struct', validateStruct
		, 'array', validateArray
		, 'list', validateList
		, 'rule', validateRule
		, 'literal', validateLiteral
		, 'peg', validatePeg
		, 'opt', validateOpt
		, 'alts', validateAlts
		, 'any', validateAny
		);

validateValue = function { ( VALIDATORS[[$2].kind]($0, $1, $2) ) };

schema = void;
parsedCushy = void;
gc();
schema = createSchemaParser();

cushySource = load(::run.root # 'test.cushy');

print('Compiling Numbstrict parser...');
numbstrictSource = load(::run.root # 'numbstrictMeta.ppeg');
ok = ppeg.compileFunction(numbstrictSource, @numbstrictParser, @offset);
if (!ok) {
	throw(formatError(numbstrictSource, offset, bake("Error compiling Numbstrict parser")));
};

print("Parsing Numbstrict...");
ok = numbstrictParser(cushySource, @parsedCushy, @offset);
if (!ok) {
	throw(formatError(cushySource, offset, bake("Error parsing Numbstrict")));
};
gc();

print("Validating...");
error = validateValue(schema, parsedCushy, [[schema].rules].root);
if (error != NO_ERROR) {
	print('!!!! ' # errorToString(error));
} else {
	print('Validation OK');
};
gc();
