/*
	Everything are objects (incl. player, places etc) that are contained in other objects.
	Top object is world.
	Recursive (container that indirectly contains itself) is naturally not allowed.
	There is a container relationship that can be e.g. "inside", "attached", "holding".
	
	statement 1. Also statement 2.
	compound statement 1, statement 2, statement 3
	e.g.: if <object> is <attribute> then statement1, statement 2. Also statement 3.
	
	<object> is [not] <attribute>
	<object>'s <property> is <attribute>
	<object> is [not] (inside|attached to|held by) <object>
	
	if <condition> then [always] <statement>
	
	always <sub-statement> (defines a global rule, applied in every location)
	say "<string>"
	go to <location>
	put <object> inside <object>
	
	[always] same as <word(s)> (defines word aliasing)
*/


map(@PREPOSITIONS
		, 'I', 'in' // e.g. in the clearing
		, 'O', 'on'
		, 'C', 'inside' // contained inside
		, 'A', 'attached to'
		, 'H', 'held by');

if (!exists(@objects.n)) {
	objects.n = 2;
	map(@objects[0]
			, 'name', 'World');
	map(@objects[1]
			, 'name', 'Player'
			, 'owner', 2
			, 'preposition', 'C');
	map(@objects[2]
			, 'name', 'Small Hut'
			, 'describe', 'You are inside a small shabby hut consisting of one small room. There is a fireplace here and a table.'
			, 'owner', 0
			, 'preposition', 'C');
	map(@objects[3]
			, 'name', 'Table'
			, 'description', 'The table is old, cracked and torn.'
			, 'owner', 2
			, 'preposition', 'C');
		
	objects[0].name = 'Player';
	objects[0].owner = 1;
	objects[0].preposition = 'I';
	objects[1].name = 'Entrance';
	objects[1].
};

say = print;
