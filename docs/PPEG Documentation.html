<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
  <head>
	<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
	  <meta http-equiv="Content-Style-Type" content="text/css">
		<title>PikaScript</title>
		<style type="text/css">
		  table, th, td { border: 1px solid black; padding: 5px; border-collapse:collapse; }
		  th { text-align: left }
		  img { border: 0 none }
		html {background:#faf8f3;}body {min-width:650px;max-width:960px;_width:650px;color:#000;margin:0;font-family:'Cambria',Georgia,'Times New Roman',Times,serif;height:100%;overflow:visible;padding:36px;}table {line-height:18px;margin-bottom:17px;border:1px solid #ccc;border-collapse:collapse;border-bottom-color:#aaa;border-radius:2px;box-shadow:0px 1px 0 #ddd;-moz-border-radius:2px;-moz-box-shadow:0px 1px 0 #ddd;-webkit-box-shadow:0px 1px 0 #ddd;}tr { background:#fff;vertical-align:top;}th,tr:nth-child(even) { background:#eee;}td {border:1px dotted #ccc;padding:2px 18px 4px 9px;font-size:0.9em;}th {background:#ddd;border:1px solid #bbb;color:#000;font-weight:normal;padding:4px 18px 4px 9px;text-align:left;font-size:0.85em;}tr:nth-child(1) th {background:-webkit-gradient(linear, 0% 0%, 0% 100%, from(#ccc), to(#bbb));background:-moz-linear-gradient(top, #ccc, #bbb);border:1px solid #aaa;border-bottom-color:#999;border-top-color:#bbb;box-shadow:0px 1px 1px #ccc;-moz-box-shadow:0px 1px 1px #ccc;-webkit-box-shadow:0px 1px 1px #ccc;color:#333;padding:8px 18px 8px 9px;text-shadow:0 1px #ddd;}tt {color:#5d5d5d;padding-right:4px;padding-left:4px;}pre {border:1px solid #d0d0d0;overflow:auto;color:#5f5f5f;padding:0.4em;}ul {list-style-type:disc;padding-left:14px;list-style-position:inside;}h1,h2,h3,h4,h5,h6 {font-weight:bold;margin-bottom:18px;}h1,h2 { line-height:36px; }h3,h4 { line-height:18px; }h1 { font-size:2.0em; }h2 { font-size:1.5em; }h3 { font-size:1.3em; }h4 { font-size:1.2em; }h5 { font-size:1.1em; }h6 { font-size:1.0em; }a { text-decoration:none; }a[href]:hover { text-decoration:underline; }a sup{ font-size:0.7em; }	
		</style>
	  </head>
	  <body>
<h1><a name="PPEG">PPEG</a></h1>
<h2><a name="What_is_PPEG?">What is PPEG?</a></h2>
<p>PPEG is a parser generator written in PikaScript. It consumes grammars described using Parsing Expression Grammars (PEG) and produces parser functions. All related files live in the <tt>tools/ppeg</tt> folder. The runtime interface <tt>ppeg.pika</tt> loads the generated <tt>initPPEG.pika</tt> and exposes the <tt>PPEG</tt> class used to build parsers. The folder also holds the grammar sources and an <tt>updatePPEG.pika</tt> script for regenerating <tt>initPPEG.pika</tt>.</p>
<h2><a name="Global_vs_Local_Compilers">Global vs Local Compilers</a></h2>
<p>The project provides two self-hosted grammars:</p>

<ul>
<li><tt>tools/ppeg/ppegGlobal.ppeg</tt> &#8211; builds parser functions stored in whatever dictionary <tt>ppeg.$compileTo</tt> points at. This variant uses global variables and is what regenerates PPEG itself (<tt>initPPEG.pika</tt>).
<br><br></li>
<li><tt>tools/ppeg/ppegLocal.ppeg</tt> &#8211; returns a self-contained parsing function. It relies on no globals and is easier to embed in other projects.
</li>
</ul>
<h2><a name="Running_the_Compilers">Running the Compilers</a></h2>
<p>Build the command line tool used to run scripts:</p>
<pre>bash tools/PikaCmd/SourceDistribution/BuildPikaCmd.sh       # or BuildPikaCmd.cmd on Windows<br></pre>
<p>Run the regression test that exercises both compiler variants from the repository root:</p>
<pre>output/PikaCmd tests/ppegTest.pika<br></pre>
<p>The test first uses the <b>global</b> compiler and then the <b>local</b> one. Both must compile themselves successfully for the test to pass.</p>
<h2><a name="Regenerating_the_PPEG_Implementation">Regenerating the PPEG Implementation</a></h2>
<p>After changing a grammar, refresh <tt>initPPEG.pika</tt> with:</p>
<pre>output/PikaCmd tools/ppeg/updatePPEG.pika<br></pre>
<p>The same script can be run to experiment directly with the compilers. It rebuilds both variants and writes the new implementation to <tt>initPPEG.pika</tt> if everything succeeds.</p>
<h2><a name="Example:_Using_the_Local_Compiler">Example: Using the Local Compiler</a></h2>
<p>Below is a minimal example that compiles <tt>examples/digits.ppeg</tt> into a local parsing function and runs it. The script locates both <tt>ppeg.pika</tt> and <tt>digits.ppeg</tt> relative to its own path so it works no matter which directory it is launched from:</p>
<pre>include('systools.pika');<br>include('stdlib.pika');<br>include(run.root # '../tools/ppeg/ppeg.pika');<br><br>src = load(run.root # 'digits.ppeg');<br>parseDigits = ppeg.compileFunction(src);<br><br>assert(&gt; parseDigits('12345'));<br>assert(&gt; !parseDigits('12a45'));<br></pre>
<h2><a name="compileFunction">compileFunction</a></h2>
<h3><a name="Syntax">Syntax</a></h3>
<pre>parser = ppeg.compileFunction(source [, @outFunc [, dd [, iref [, rule = 'root']]]])<br></pre>
<h3><a name="Description">Description</a></h3>
<p>Converts &lt;code&gt;source&lt;/code&gt; into a parser function. If &lt;code&gt;@outFunc&lt;/code&gt; is supplied, <br>
the generated parser is stored there and the call returns &lt;code&gt;true&lt;/code&gt;; otherwise it <br>
returns the new parser.</p>
<p>&lt;code&gt;dd&lt;/code&gt; and &lt;code&gt;iref&lt;/code&gt; establish the default dictionary container and index <br>
reference for the parser. They let callers provide an external container and position <br>
variable that each rule will update. The optional &lt;code&gt;rule&lt;/code&gt; parameter selects the <br>
starting rule and defaults to &lt;code&gt;'root'&lt;/code&gt;.</p>
<h2><a name="PikaScript_Actions">PikaScript Actions</a></h2>
<p>PPEG grammars may attach PikaScript code to an expression. The code is written <br>
inside braces <tt>{}</tt> and always succeeds because it ends with <tt>;true</tt>. Before the <br>
block runs, <tt>$$</tt> already contains the value produced by the expression. The <br>
action can inspect or modify this value directly.</p>
<p>The following helpers are available inside an action:</p>

<ul>
<li><tt>$$</tt> &#8211; current result container. Use <tt>$$=</tt> before an expression to capture<br>the substring it consumes.
<br></li>
<li><tt>$$s</tt> &#8211; the source string being parsed.<br></li>
<li><tt>$$i</tt> &#8211; index within <tt>$$s</tt> for the next character.<br></li>
<li><tt>$$parser</tt> &#8211; dictionary holding all generated parser functions.</li>
</ul>
<p>These identifiers let actions look at the input, build data structures, or <br>
report errors via <tt>ppeg.fail()</tt>.</p>
<h2><a name="Tags_and_Captures">Tags and Captures</a></h2>
<p>Every rule takes <tt>$$</tt> as its input and also returns it. Untagged <br>
subexpressions therefore share one container and may update it in place. A <br>
tagged expression <tt>name:expr</tt> temporarily binds <tt>$$</tt> to <tt>$name</tt> while <tt>expr</tt> <br>
runs. When the expression finishes, <tt>$name</tt> contains the produced value and <br>
<tt>$$</tt> again refers to the outer container so the rule can decide how to use the <br>
new data.</p>
<p>A capture <tt>name=expr</tt> (or <tt>$$=expr</tt>) grabs the substring consumed by <tt>expr</tt> <br>
before any action executes. The action can then convert this text or store it.</p>
<p>The grammar below builds a dictionary from colon-separated pairs:</p>
<pre>root &lt;- "{" _            { $$ = new(Container) }<br>         pair ("," _ pair)* "}" _ !.<br><br>pair &lt;- key:ident ":" _ val:number { [$$][$key] = $val }<br><br>ident &lt;- $$=[a-zA-Z]+ _<br>number &lt;- digits=[0-9]+ { $$ = evaluate('+' # digits) } _<br>_ &lt;- [ \t\r\n]*<br></pre>
<p><tt>pair</tt> tags the identifier and number so the action can read <tt>$key</tt> and <br>
<tt>$val</tt>. <tt>number</tt> captures the digits in <tt>$digits</tt> before converting <br>
them. Tagged variables remain available until the rule returns.</p>
<h2><a name="Working_with_Custom_Fields">Working with Custom Fields</a></h2>
<table>
<tr>
<td colspan=4>Grammars often pass context in <tt>$$</tt>.</td><td>The monolithic JSON parser</td>
</tr>
<tr>
<td colspan=5>writes results into the container referenced by <tt>$$.target</tt>:</td>
</tr>
<tr>
<td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td>
</tr>
<tr>
<td>&nbsp;</td><td>root</td><td colspan=3>&lt;- _ { $$parser.null = coalesce(@$$.null, &lt;null&gt;); }</td>
</tr>
<tr>
<td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>(object / array) !.</td><td>&nbsp;</td>
</tr>
</table>
<pre>object &lt;- "{"_ ( member (","_ member)* )? "}"_<br><br>member &lt;- id:string ":"_            { $v.target = @[$$.target][undotify($id)] }<br>           v:value<br><br>value  &lt;- string                     { [$$.target] = $$ }<br>           / number                  { [$$.target] = $$ }<br>           / "true" _               { [$$.target] = true }<br>           / "false" _              { [$$.target] = false }<br>           / "null" _               { [$$.target] = $$parser.null }<br>           / object<br>           / array<br></pre>
<p>Initialize <tt>$$.target</tt> before parsing; each rule stores its result in <br>
that field.  Because <tt>target</tt> is just a member of <tt>$$</tt>, all nested <br>
rules see it until the current rule finishes.</p>

	</body>
</html>
