PikaScript
##########

NAME(S)         :   PikaScript, PikoScript, YoctoScript
DESCRIPTION     :   Mind-boggingly tiny C-style scripting language implementation
YEAR            :   2008
STRENGTHS       :   Tiny, only standard C++, multi-threadable (out of the box), easy to integrate
WEAKNESSES      :   Slow (100% interpreting), no heap = no automatic garbage collection on references
USED            :   not yet
SVN             :   svn://svn.elysian.se:7404/NuEdgeSVN/lab/trunk/ScriptLab/PikaScript
DOXYGEN         :   http://www.nuedge.net/doxygen/PikaScript
LIBRARY HELP    :   http://www.nuedge.net/doxygen/PikaScript/Library

History
=======

At some point I started realizing that NuXScript was becoming quite complex, and that it would take me several months to finish it and then even more time to maintain and guarantee it's stability. So I decided to try to implement the tiniest and most minimalistic language conceivable.

I developed a super-basic version (called PicoScript) in about three days. It had all the basic C expressions and statements (although traditional C statements were interpreted as expressions as well). Variables were represented using strings only (variables of string type were stored in quoted "escaped"* form to distinguish them from symbols). I then added references to variables (&x) and did a poor implementation first (a system where the relative "call frame distance" to the referenced variable was maintained with a number of ^ after the &). When I realized that it would never work with storing such references in "globals", I made an implementation (PikoScript) where each frame would have a number equivalent to its calling depth (0 being the global frame). The frame number would be injected into all pointer values (e.g. &:3:myVariable) and functions (to denote closure frame). Checks were added so that you could never use or store a reference to a higher frame in a lower frame. At this point variables were implemented using a true variant type (i.e. a union of bool, double and a string object buffer where strings would be "placement newed" and deleted).

However, complexity started to increase, and I was drifting away from my original intention of doing a super-minimalistic language, so I reworked all the code yet another time, into YoctoScript. This time dropping all frame-references (in practice, only allowing references to global variables). I also reduced the expression set by dropping ternary ? : (if else does the same thing), while and do while (for can do the same thing). Local variables would be prefixed with $, all other variables were global. Values where represented by strings only again, but string values weren't "escaped" (I implemented lvalue and rvalue distinction with a separate bool inside the parser instead).

Naturally, I soon realized that I wanted something better than this (global variables suck!) and I came up with what is now called PikaScript, which is something in between Piko and Yocto. Frame identifiers were added to references and functions again, but they are guaranteed to be unique for every frame created, and thus no "up and down referencing checks" are necessary any more. Furthermore variable listing was added so that we could implement a foreach function, there is a ^ prefix that you can use to sneak into the caller's frame and make a mess and a lot of other small changes.

* With escaped form I mean that special characters were escaped like in C string literals, e.g. "\n"

Future
======

Multiple global frames

One thing that became quite clear when Pika was implemented into Synplant was that a single global scope really doesn't cut it very well in 2008. In Synplant we needed globals that were common for all plug-in instances but also globals that were specific to each plug-in instance. We ended up with a Q&D solution where we mix two different global scopes so that if a symbol exist in the instance-specific global frame, it is used. Otherwise it is looked up in the super-global frame. This solution works alright but it is quite obscure. E.g., you can't decide from looking at the code that uses the global whether that global is per plug-in instance or not.

A better solution would be if it was possible to create new global frames. We could prefix all local frames with '$' and other frames have global space. In the Synplant example above we could have something like :gui:x for the "per-instance frame". We could even expand the idea and let named views have their own frames for attaching data and code to it. Named frames could be a step towards better integration with OO-designs.

Follow up (20090526): I am not so sure about this idea any more, although I don't rule it out, I don't consider it vital for the first version of PikaScript. In Synplant I am experimenting with a different solution where a global 'w' is set to reference the unique window. Thus, [w].something is local to the window while ::something is global for all windows.

No macros
---------

Templatization is another issue for the future. PikaScript shouldn't really depend on global macros that decide which string class it will use etc. It would be better if the entire engine was a template, so that we could plug different implementations into it. It doesn't necessarily mean that the client would need to include the entire PikaScript implementation in a header-file (which is something that I dislike with templates). Look at how nicely we managed to hide away implementation in a separate .h file in NuXPixels for example.

Follow up (20090526): Implemented.

Destructors
-----------

Destructors would be nice. Some way to hook in functions that get called when a frame is being destroyed. Example: let us pose we wish for more advanced file handling than "load" and "save", with functions to read and write arbitrary ranges etc. Alternatives are:

Let open files be accessed through handles and have functions for opening and closing them etc. For example: { f = openFile('myfile.dat'); writeFile(f, 'hej du file'); closeFile(f); }. Disadvantage: nothing enforces closing files when the job is over, not exception friendly etc.
Use various higher-order functions that opens the file in question and calls your code which performs some specific file operation, then close it. For instance reading lines: readLines('myfile.dat', >print($0)). Disadvantage: can't work on more than one file at a time.
Use a higher-order function again but this time you are allowed to call difference functions on the file. For example: withFile('myfile.dat', >{ append('myfile.dat', 'hej du fule'); }); Disadvantage: you can never leave files open.
Construct an object for the open file with methods to operate on it. Example: { f = new(OpenFile, 'myfile.dat'); [f].append('hej du fule'); [f].close(); }. Disadvantage: without proper destruction mechanisms in Pika, there is nothing to prevent a file being left open.
Follow up (20090526): Implemented in the native interface (e.g. the Native destructor is called when the frame destructs). PikaScript destructors are not available, and it is not a showstopper for 1.0.

Debugger
--------

Some hooks for implementing a debugger would be nice. I started out trying to do a simple debugger in PikaScript by evaluating statement by statement, but it turned out quite impossible. I almost needed to implement the entire PikaScript interpretor in PikaScript for that to work. I guess the only alternative is to have some form of callback (C++ or PikaScript), for example at every ';'.

Follow up (20090526): Implemented tracing mechanism.

.n convention

I am not sure it is super-brilliant. For example, foreach will include the .n member, which is rarely desired. One idea is to use the parent variable, e.g. myArray (for myArray.0, myArray.1 etc) for holding the count. But it is a big change, and I need to make certain I don't want to use it for anything else, like object type string or something.

 

Follow up (20090526): I think it will have to do.

 

argument names
--------------

As it is now, functions do not have argument names and we use the 'args' function to assign args to named vars... well, not unsurprisingly, when performing some simple sampling profiling on the chess-game I discovered that most time is spent in the 'args' function. Either we could have a new operator that replaces the args function (e.g. /left, top, right, bottom/) or we could support real arg names, optionally (e.g. function(left, top, right, bottom) { left + top + right + bottom }).

 

Follow up (20090526): naaah.

Motivation
==========

Goals
-----

*)

Non-goals
---------

*)

Documentation
=============

Syntax
------

 PikaScript syntax borrows heavily from C. This documentation assumes that the reader has at least a basic understanding
of the C language (or of any of the languages it has influenced such as C++, C#, Java, Javascript, Perl, PHP etc etc).

Variables
---------

 In order to minimize code complexity and make the interface to Pika minimal and easy, all Pika variables are
represented internally by strings. Unlike many dynamically typed languages, there is no distinct variable type coupled
with the values. Instead, the interpretation of a value (and its type) is determined by the context in which it is used.
For example, there is no distinction between `10 / 2` and `"10" / "2"`. Both result in the value `"5"`. Similiarly,
`10 + 2` and `'10' + '2'` are equivalent and the result is `"12"`. (If you want to perform string concatention you use
the special `#` operator instead.) This approach is usually referred to as /weak typing/.

 Despite the lack of strong types in Pika, you can distinguish seven different /value classes/ by how they are handled
by the various expressions, operators and library functions:

 Class      Source example              Internal representation     Comments
 -----      --------------              -----------------------     --------
 void       `void`                                                  The "no value" value, always represented internally by an empty string.
                                                                        
 boolean    `false`                     `false`                     The input and output of logical expressions (such as `&&` and `||`).
            `true`                      `true`                      Always represented by a lowercase `false` or `true`.
 
 number     `23`                        `23`                        Numerical value. Numbers must begin with a digit (or `+` or `-`) and end with a digit. (Except for `infinity` of course.)
            `-0x94`                     `-148`                      E.g, ".3" and "3." are not considered valid numbers. 
            `0.00000003`                `3e-8`                      They may contain an exponential prefixed with `e`.
            `5.930e-77`                 `5.93e-77`                  Numerical literals are "normalized" so that identical numbers are also identical strings
            `infinity`                  `infinity`                  (e.g. 1.00, 1e0, 0x01 and 1 are all normalized to `1`).
 
 string     `'orange'`                  `orange`                    As said, all values are stored internally in string format, so in practice all values are valid strings.
            `'I "love" Pika'`           `I "love" Pika`             String literals are enclosed in either single quote (') or double quote (").
            `"line1\nline2"`            `line1<lf>line2`            Strings within double quotes may use the standard C escape codes (e.g. "\n", "\x10").
                                                                    Strings within single quotes are interpreted literally character by character (sometimes called raw strings).
 
 reference  `@myvar`                    `:<frame>:myvar`            Variable / element references.
            `@myelem[i]`                `:<frame>:myelem.<i>`       Internal representation starts with the frame label (see motivation in References).
 
 function   `function { /* code */ }`   `{ /* code */ }`            Functions (and /lambda expressions/).
            `>($0 + $1)`                `>($0 + $1)`                Internal representation begins with a leading `{` or `>`.
 
 native     `<print>`                   `<print>`                   Native C / C++ function (or object).
                                                                    Always starts with `<` and ends with `>`.

 Pika is pretty strict with the kind of values it allows for many operations. For example, `true` and `false` are the
only legal values for logical expressions (such as `if` and `for`). Functions and /lambda expressions/ are the only
legal targets for function calls and numbers are the only acceptable values for arithmetic operations.

 In Pika you simply declare variables by assigning them values (in fact, this is the only way to create new variables).
Unless a variable is global (prefixed with `::`), it will be destroyed when the function wherein it is declared returns.
Read more about variable scopes under Functions.

Operators
---------

 Since everything counts as expressions in Pika, you will find that quite a few of the standard C / C++ statements (such
as `if` and `for`) are actually operators rather than statements. See Expressions for more on this.

(*TODO : document new system with "artificial" precedence levels for "ticks"*)

Operator                    Prec.   Comment
--------                    -----   -------
function { x }              21      Function with body `x`. See Functions for more info. (* TODO : MOVE TO TOP *)
x([a][,b][,c]...)           20      Function call. (All arguments are optional and will be void if omitted.)
x.y                         20      Element operator (`y` must be a valid symbol literal).
x[y]                        20      Subscript operator.
x{[o]:[l]}                  20      Substring operator. Returns a sub-string of `l` characters from `x` starting at offset `o` .*
x++                         20      Postfix increment. Value is that of `x` before the increment. `x` must be an integer /lvalue/ .**
x--                         20      Postfix decrement. Value is that of `x` before the decrement. `x` must be an integer /lvalue/ .**
@x                          19      Reference operator. See References for more info.
!x                          19      Logical not (`false` -> `true` and vice versa). (`!!x` can be used to assert that `x` is a boolean.)
~x                          19      Bitwise not (only works on integers) (`~~x` can be used to assert that `x` is an integer value.)
+x                          19      Prefix plus, verifies that `x` is a number and "normalizes" it. (`+x` can be used to assert that `x` is a number.)
-x                          19      Negate, only works on numbers.
++x                         19      Prefix increment, `x` must be an integer /lvalue/ .** (Use += for floating point numbers.)
--x                         19      Prefix decrement, `x` must be an integer /lvalue/ .** (Use -= for floating point numbers.)
x * y                       18      Multiplication (only works on numbers).
x / y                       18      Division (only works on numbers).
x % y                       18      Modulo (only works on numbers). (Result is platform dependent if `x` is negative.)
x + y                       17      Addition (only works on numbers).
x - y                       17      Subtraction (only works on numbers).
x << y                      16      Bit-shift left (only works on positive integers).
x >> y                      16      Bit-shift right (only works on positive integers).
x # y                       15      String concatenation.
x < y                       14      `true` if `x` is less than `y`. Numbers are considered lesser than all non-numerical strings.
x <= y                      14      `true` if `x` is less or equal to `y`. Numbers are considered lesser than all non-numerical strings.
x >= y                      14      `true` if `x` is greater or equal to `y`. Numbers are considered lesser than all non-numerical strings.
x > y                       14      `true` if `x` is greater than `y`. Numbers are considered lesser than all non-numerical strings.
x === y                     13      `true` if `x` is literally equal to `y` (character by character).
x == y                      13      `true` if `x` is equal to `y`, numerically (if both `x` and `y` are valid numbers) or literally.
x !== y                     13      `true` if `x` is not literally equal to `y` (character by character).
x != y                      13      `true` if `x` is not equal to `y`, numerically (if both `x` and `y` are valid numbers) or literally.
x & y                       12      Bitwise and (only works on positive integers).
x ^ y                       11      Bitwise xor (only works on positive integers).
x | y                       10      Bitwise or (only works on positive integers).
x && y                      9       Logical and. `y` is only evaluated if `x` is `true`.
x || y                      8       Logical or. `y` is only evaluated if `x` is `false`.
x = y                       7       Assignment (right to left associative, e.g. `a = b = 3` is ok.)
*= /= %=
+= -=
<<= >>= #=
&= ^= |=                    7       Assignment by operation, e.g. `a += 3` adds 3 to `a`.
(x)                         6       Parenthesis, groups sub-expressions.
[x]                         6       Dereferences `x`. E.g. `[@x]` is the same as `x`. See References for more info.
{[a[;b][;c]...]}            3       Compound expression. Evaluates sub-expressions sequentially. Final result is that of last sub-expression.
>x                          3       Lambda expression of `x`. E.g. `(>x)()` is the same as `x`. See Functions for more info.
for ([a];b;[c]) [x]         3       First evaluates `a`, then if `b` is `true`, `x` and `c` are repeated until `b` is `false`. Final result is that of `x` (or unchanged if first `b` is `false` or `x` is omitted).
if (x) a [else b]           3       Evaluates `a` if `x` is `true` (or optionally evaluates `b` if `x` is `false`). Final result is that of `a`, `b` or unchanged. (Can be /lvalue/ or /rvalue/.)

 * You must specify either `o`, `l` or both. If `o` is omitted, the first `l` characters of the source string `x` are
returned. If `l` is omitted, the sub-string from offset `o` to the end of the source string is returned. Negative values
and values greater than the length of `x` are valid for both `o` and `l`. For example, `'hello'{-2:6}` returns `'hell'`
(the first two negative character positions are considered empty for this purpose).

 ** An /lvalue/ is an addressed value, such as a variable or element in an array (as opposed to a literal number,
string etc). An /rvalue/ is the opposite: an actual value. /rvalues/ can be assigned to /lvalues/, but not the other
way around.

Expressions
-----------

 As said, Pika borrows it's syntax from C, although in Pika, there is no distinction between statements and expressions.
Every piece of code results in a value, so everything counts as an expression. For example, `if` can be written and used
(almost) like you would in C, but you can also use it to generate a conditional value. The following is valid Pika code:

    x = if (y < 0) -1 else 1;

 For this reason, the decision was taken not to support the ternary `? :` conditional operator. Even the "for loop" can
be used as an expression. The resulting value is that of the last "increment" operation. Thus, the following is valid
code for finding a value in an array:

    index = for (i = 0; i < n && a[i] != x; ++i);

 As if that wasn't odd enough, code enclosed within `{` and `}` can also be used as expressions (so called /compound
expressions/). The result is that of the last expression evaluated within the compound. For example, this is perfectly
valid syntax:

    print( if (y < 10) { ++y; 'incremented' } else 'not incremented' );

 In consequence, there is no return statement in Pika. Instead, the return value of a function is that of the last
expression evaluated. If you do not wish for a function to return a value, simply put void as the last expression in the
function.

 Within compounds, you are required to separate all expressions with semicolons (the last semicolon before the
terminating `}` is optional). This use of semicolon is similar, but still different to C / C++ which uses semicolons for
terminating statements. The implication is that semicolons are often required also after `}` in Pika, as illustrated by
this example:

    {
        welcome = function {
            print("Hello!");
        };                                      // Semicolon required here!
        if (true) {
            welcome();
        };                                      // And here!
        print("Goodbye")                        // But not required here.
    }

 At other times, the semicolon is *not* allowed, such as before `else` in a conditional expression. For example:

    {
        if (test()) print('Test succeeded!')
        else print('Test failed!')              // "else" belongs to the "if" expression, therefore no semicolon here.
    }

Arrays
------

 You may have noticed that there were no array or object class in the class table earlier, but don't despair, there is
support for associative arrays in Pika, it is just that they are not what you normally call /first class objects/. That
is, they are not stored in variables in a self-contained manner. Instead, each individual array element is an individual
variable with a distinct naming convention where periods delimit its element keys. E.g. `myArray[5]` actually resolves
to `myArray.5`. Likewise, `phoneNumber["John"]["Doe"]` will resolve to `phoneNumber.John.Doe`.

 There are no restrictions on what strings you can use for element names, but in case the string is not a valid symbol
name (for example if it contains spaces, starts with a leading digit etc) you must use the subscript operator `[]`.
E.g. `x = myArray.5` and `x = myArray.two words` are not valid expression syntaxes but `myArray[5]` and
`myArray["two words"]` are. Also `.` is actually an operator, so surrounding spaces will not matter. `myArray . myKey`
is the same as `myArray.myKey`.

 While this approach might seem a bit strange and limiting at first, it simplifies the language a lot. It is actually
quite similiar to how array handling in C works. Pika supports creating references to individual array elements as well
as to entire arrays and also allows the subscript / element operators to work on dereferenced array references. Read
more about this in the References section.

 For arrays with numerical indices there is a convention in Pika to include a member `n` that simply contains the number
of elements for the array. E.g. to construct a three element array and then loop through the elements one could write:

    {
        myArray[0] = 'first';
        myArray[1] = 'second';
        myArray[2] = 'last'; 
        myArray.n = 3;
        for (i = 0; i < myArray.n; ++i) print(myArray[i]);
    }

Functions
---------

 Functions are /first class objects/, meaning that you can create them in run-time, assign them to variables (local or
global) and pass them as arguments. In fact, just like any other data type, functions are just strings (containing the
function body in clear text format). There are two types of functions which differ in how access to local variables is
resolved*:

 *) The /ordinary function/ which creates a new local variable scope on each call. E.g. `function { /* code */ }`
 *) The /lambda expression/ is a function that shares the variable scope with the function that created it. E.g. `>(a+b)`

 The following example illustrates the difference between these two variants:

    f = function {
        localVariable = 'abcd';			// localVariable is created in the local variable scope of this function, it will be destroyed on function exit.
        print(exists(@outerVariable));	// Will print false, because outerVariable is not reachable from here.
    };

    l => {								// Notice that l => { is interpreted as l = >{, but it looks neater in this form.
        newVariable = outerVariable;	// outerVariable is accessible here.
    };

    outerVariable = 'reach me';
    f();
    l();
    print(newVariable);					// Will print 'reach me'.
    print(exists(@localVariable));		// Will print false, because localVariable from f does not exist in this scope.

 Lambda expressions are very powerful, allowing practical use of so called higher-order functions, i.e. functions that
take other functions as arguments (or returns new functions). For example, the `foreach` function (part of the standard
library) takes an array as first argument and a function / lambda expression as second argument which is then applied to
each element found in the array. Like this:

    a[0] = 'q';
    a[1] = 'w';
    a[2] = 'e';
    count = 0;
    foreach(@a, >++count);				// count will now be 3.

 Function arguments are not accessed by name in Pika, but by index. The first argument is number 0 and is accessed with
`$0`. `$n` is a special variable containing the number of arguments passed to the function. Notice that you can modify
the contents of the arguments in the function, but it will not affect any source variables passed to the function since
arguments are passed by value. If you want to modify variable content in the caller's variable scope you should
explicitly pass a reference to this variable from the caller to the function, e.g. a swap function could be implemented
like this:

    swap = function { temp = [$0]; [$0] = [$1]; [$1] = temp; }
	
    left = 'stuff';
    right = 'cool';
    swap(@left, @right);			// left is now 'cool' and right is 'stuff'.

(See References section for more information on references.)

 Arguments are available for lambda expressions just as for ordinary functions. Furthermore, you may create arbitrary
new variables prefixed with the dollar sign to create a temporary variable that is only visible to the current
function / lambda. (Thus, $ variables in lambda expressions are similiar to non-$ variables in ordinary functions.)

 The subscript operator `[]` can be appended to a single `$` to access arguments by index. For example, the following
code iterates through each function argument and prints it:

    printAll = function {
        for (i = 0; i < $n; ++i) {
            print($[i]);
        };
    };
	
    printAll(1, 2, 3, 4); // Will print 1, 2, 3 and 4.

 There is a global variable scope that is accessible from everywhere. Global variables are not destroyed until the
entire language context is destroyed by the host. Prefix the symbol with the `::` operator to access this scope. E.g.,
`::myGlobal = 'hello world'` will create a global `myGlobal` that can be accessed from any function. It is quite common
to declare functions in the global scope, e.g `::newCoolFunction = function { /* do something nice */ }`.

 Finally, the special variable prefix `^` allows you to "sneak" into a function caller's frame and access variables
there. You rarely need to use this operator, but there are some special circumstances where it is useful. E.g. `^$0` is
the first argument of the caller (as opposed to the first argument of this function), `^^$0` is the first argument of
the caller's caller and so on. An example of how this feature can come in handy is the `args` function (from the
standard library) which assigns arguments to named variables. Here is an illustration of how it was implemented and how
you might use it:

    // Definition of ::args from the standard libary.
	
    ::args = function {
		if (^$n != $n) throw(if (^$n > $n) "Too many arguments" else "Too few arguments");
		for (i = 0; i < $n; ++i) [$[i]] = ^$[i];
	};
	
    // Never mind if that was complicated. It is easy to use:
	
    repeat = function {
        args(@string, @count);
        for (i = 0; i < count; ++i) output #= string;
        output;
    };
	
    print(repeat('All work and no play makes Jack a dull boy. ', 1000));

 * There is actually a third type of function as well, which is the native function. It is described in the C++ Interface
section below.

References
----------

 You can create references to variables, individual array elements and entire arrays in Pika using the reference
operator `@` .* References may be stored in variables or passed as arguments in function calls. As mentioned earlier,
references are very important in Pika because of how arrays are implemented. Since arrays cannot be stored directly in
variables you cannot simply pass them as arguments either. Instead you need to pass references to arrays. E.g., this is
*not* valid code:

    a[0] = 'q';
    a[1] = 'w';
    a[2] = 'e';
    sumArray(3, a);

 This will just result in a missing variable error because `a` isn't actually declared (but `a.0`, `a.1` and `a.2` are).
Instead the last line needs to look like this:

    sumArray(3, @a);

The difference here being that we pass a reference to `a` instead of trying to pass its value. We may then use this
reference inside of the `sumArray` function together with the element operator `[]` to access the individual elements
under `a`.

 Dereferencing is done with the dereferencing operator which also happens to be `[]` .* For example, the `sumArray`
function from the previous example may be implemented as follows:

    sumArray = function {         // This is how you declare a function in Pika.
        count = $0;               // $0 is the first argument.
        array = $1;
        
        sum = 0;
        for (i = 0; i < count; ++i) {
            sum += [array][i];    // Dereferencing [array] and addressing its element [i].
        };
        
        sum;                      // The return value is the result of the last expression, in this case just the value of sum.
    }

 The internal representation of a reference starts with a /frame identifier/ (enclosed in colons) followed by the
variable name. For example, printing the reference `@xwing` may display something like: `:a93:xwing`, where `:a93:`
would be the unique identifier for the frame where the variable was declared. The global frame identifier is always
`::`.

 Notice that although you are allowed to return a reference to a local variable from a function, it will be useless to
the caller since the frame is destroyed when the function returns (unless the function is a /lambda expression/ that
shares the same variable scope as the caller of course). Here is an illustrative example:

    myFunction = function { @myLocal };    // returning reference to myLocal.
    myReference = myFunction();            // this is ok, but myReference will be pretty useless.
    [myReference] = 'not ok';              // here you will get a "frame does not exist" error.
    
    myLambda => { @myLocal };              // this is different, myLocal is located in the same frame as myLambda.
    [myLambda()] = 'ok';                   // this is ok, myLocal will now exist in the current scope.

 * The primary reason why `@` and `[]` were chosen as reference and dereference operators and not `&` and `*` (which
would be more consistent with C / C++) is that Pika references are radically different to C / C++ pointers. For example,
you are allowed to create references to variables that do not even exist. More importantly, unlike C / C++ pointers,
references to arrays need to be dereferenced in order to access their elements, and the `[]` syntax was found more
elegant for this purpose compared to using a prefix `*` operator like in C. For example, dereferencing an element in an
array referenced by `array_ref` looks like this: `[[array_ref][index]]`. The intention of this expression is clearer
than `*(*array_ref[index])` and more compact than `*((*array_ref)[index])`.

Standard Library
================

C++ Interfacing
===============

Research: object orientation with Pika isn't bona fide. I've been trying to figure out how to best interface with native C++ classes. You cannot simply register a native function into a sub-element of an object like I naively thought at first. E.g. it is not possible to do registerNative(MyObject["myMethod"], ...). The reason being that MyObject["myMethod"] might become :frame:MyObject.myMethod, which is the syntax for putting a native function into a non-global frame. If we would simply strip the leading :frame:, different objects in different sub-frames (with the same name) would collide.

These are the alternatives I've come up with so far:

If we introduce the option to allow several named global scopes (see Future above) we could let each C++ object be it's own Frame. Check the Frame class and you'll see that everything we would need to interface is there. The disadvantage is that concepts like "construct" and "new" would have to be reworked since we should now create new frames for new instances. Also, there cannot be function local objects.
Resolve the frame of the target object and register the native into that frame. Like this: { Value that = frame.get("$this"); Frame& target = frame.resolveFrame(that); target.registerNative(that[String("method")], newUnaryFunctor(std::bind1st(std::mem_fun(&TestClass::method), x))); return Value(); };
Each native method in an object is a unique allocated function. The name of the native can be made from the allocated address. The disadvantage is that we are treating native methods a bit different from Pika methods. We are not using $this to identify the object the method works on. For example, you cannot copy a native method from one instance to another. Example code:

static void registerMethod(Pika::STLFrame& frame, const Pika::Value& base, const Pika::String& identifier, Pika::Native* native)
{
Pika::String nativeName = (Pika::String(STR("$")) += Pika::int2string(reinterpret_cast<intptr_t>(native), 16));
bool inserted = frame.natives.insert(Pika::STLFrame::NativeMap::value_type(nativeName, native)).second;
assert(inserted);
frame.set(base[identifier], (Pika::String(STR("<")) += nativeName) += Pika::String(STR(">")));
}
 
registerMethod(frame, base, Pika::String(STR("myMethod")), new Pika::CppMethod<MyObject, &MyObject::MyMethod>(this));
If we want to mimic the technique used for creating objects with Pika (i.e. utilizing the special $this variable etc) we could let a special sub-element of the object (or the "root element", i.e. [object]) point to a native allocated C++ object through some form of text representation of the pointer. All methods of a class would be registered at startup (e.g. named MyObject::myMethod) and they would obtain their class instance through the text-pointer in [$this]. We could add a std::set<MyObject*> to verify that the text-pointer is actually valid (to prevent crashing if it is tampered with). This technique would allow manipulation on native methods just like we can manipulate methods implemented as Pika functions. (E.g., copying a method from another instance.)
(20090526) I've come up with another solution that I think I'll go for. The Native object could be a dispatcher, receiving the method as an argument (or maybe add a $method argument). Each method element in PikaScript simply calls a function (implemented in Pika or native) that "sends the method" to the dispatcher.
