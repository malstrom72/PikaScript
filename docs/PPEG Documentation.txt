PPEG
####

What is PPEG?
=============

 PPEG is a parser generator written in PikaScript. It consumes grammars described using Parsing Expression Grammars
(PEG) and produces parser functions. All related files live in the `tools/ppeg` folder. The runtime interface
`ppeg.pika` loads the generated `initPPEG.pika` and exposes the `PPEG` class used to build parsers. The folder also
holds the grammar sources and an `updatePPEG.pika` script for regenerating `initPPEG.pika`.

Global vs Local Compilers
=========================

 The project provides two self-hosted grammars:

-  `tools/ppeg/ppegGlobal.ppeg` – builds parser functions stored in whatever dictionary `ppeg.$compileTo` points at.
  This variant uses global variables and is what regenerates PPEG itself (`initPPEG.pika`).

-  `tools/ppeg/ppegLocal.ppeg` – returns a self-contained parsing function. It relies on no globals and is easier to
  embed in other projects.

Running the Compilers
=====================

 Build the command line tool used to run scripts:
   
    bash tools/PikaCmd/SourceDistribution/BuildPikaCmd.sh       # or BuildPikaCmd.cmd on Windows

 Run the regression test that exercises both compiler variants from the repository root:

    output/PikaCmd tests/ppegTest.pika

 The test first uses the *global* compiler and then the *local* one. Both must compile themselves successfully for the
test to pass.

Regenerating the PPEG Implementation
====================================

 After changing a grammar, refresh `initPPEG.pika` with:

    output/PikaCmd tools/ppeg/updatePPEG.pika

 The same script can be run to experiment directly with the compilers. It rebuilds both variants and writes the new
implementation to `initPPEG.pika` if everything succeeds.

Example: Using the Local Compiler
=================================

 Below is a minimal example that compiles `examples/digits.ppeg` into a local parsing function and runs it. The script
locates both `ppeg.pika` and `digits.ppeg` relative to its own path so it works no matter which directory it is
launched from:

    include('systools.pika');
    include('stdlib.pika');
    include(run.root # '../tools/ppeg/ppeg.pika');

    src = load(run.root # 'digits.ppeg');
    parseDigits = ppeg.compileFunction(src);

    assert(> parseDigits('12345'));
    assert(> !parseDigits('12a45'));

PikaScript Actions
==================

 PPEG grammars can embed blocks of PikaScript that run when the preceding
 expression succeeds. These action blocks appear inside braces `{}` and end
 with a `;true` so the parser always continues after running the code.
 Before the action executes `$$` already holds the value produced by the
 expression. The code may read or modify this value in place.

 The following helper variables are available inside an action:

-  `$$` – current result container. Use `$$=` before an expression to capture
   the raw substring it consumes.
-  `$$s` – the source string being parsed.
-  `$$i` – the index within `$$s` where the next character will be read.
-  `$$parser` – dictionary holding all generated parser functions. Global
   grammars populate this dictionary while local compilers return it.

 These identifiers are expanded by the compiler so that actions can inspect
 the input, construct data structures or call helper functions. Use
 `ppeg.fail()` to abort parsing and report an error.

Tags and Captures
=================

 Each rule receives an object in `$$`. If you do not tag any
 expressions the same value flows through nested expressions and they may
 modify it directly. A tag `name:expr` binds `$$` to `$name` only while
 `expr` runs; when it succeeds `$name` keeps the result and `$$` reverts.
 Nothing is copied back automatically&#8212;store `$name` yourself if
 needed.

 `name=expr` or `$$=expr` saves the substring consumed by `expr` before
 actions execute. This is handy for converting digits or preserving the
 original text.

 The grammar below builds a dictionary from colon separated pairs:

     root <- "{" _            { $$ = new(Container) }
              pair ("," _ pair)* "}" _ !.

     pair <- key:ident ":" _ val:number { [$$][$key] = $val }

     ident <- $$=[a-zA-Z]+ _
     number <- digits=[0-9]+ { $$ = evaluate('+' # digits) } _
     _ <- [ \t\r\n]*

 `pair` tags the identifier and number so the action can read `$key` and
 `$val`. `number` captures the digits in `$digits` before converting
 them. Tagged variables remain available until the rule returns.

Working with Custom Fields
==========================

 Grammars often pass context in `$$`.  The monolithic JSON parser
 writes results into the container referenced by `$$.target`:

     root   <- _ { $$parser.null = coalesce(@$$.null, <null>); }
                (object / array) !.

     object <- "{"_ ( member (","_ member)* )? "}"_

     member <- id:string ":"_            { $v.target = @[$$.target][undotify($id)] }
                v:value

     value  <- string                     { [$$.target] = $$ }
                / number                  { [$$.target] = $$ }
                / "true" _               { [$$.target] = true }
                / "false" _              { [$$.target] = false }
                / "null" _               { [$$.target] = $$parser.null }
                / object
                / array

 Initialize `$$.target` before parsing; each rule stores its result in
 that field.  Because `target` is just a member of `$$`, all nested
 rules see it until the current rule finishes.
