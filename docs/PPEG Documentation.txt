PPEG
####

What is PPEG?
=============

 PPEG is a parser generator written in PikaScript. It consumes grammars described using Parsing Expression Grammars
(PEG) and produces parser functions. All related files live in the `tools/ppeg` folder. The runtime interface
`ppeg.pika` loads the generated `initPPEG.pika` and exposes the `PPEG` class used to build parsers. The folder also
holds the grammar sources and an `updatePPEG.pika` script for regenerating `initPPEG.pika`.

Global vs Local Compilers
=========================

 The project provides two self-hosted grammars:

-  `tools/ppeg/ppegGlobal.ppeg` – builds parser functions stored in whatever dictionary `ppeg.$compileTo` points at.
  This variant uses global variables and is what regenerates PPEG itself (`initPPEG.pika`).

-  `tools/ppeg/ppegLocal.ppeg` – returns a self-contained parsing function. It relies on no globals and is easier to
  embed in other projects.

Running the Compilers
=====================

 Build the command line tool used to run scripts:
   
    bash tools/PikaCmd/SourceDistribution/BuildPikaCmd.sh       # or BuildPikaCmd.cmd on Windows

 Run the regression test that exercises both compiler variants from the repository root:

    output/PikaCmd tests/ppegTest.pika

 The test first uses the *global* compiler and then the *local* one. Both must compile themselves successfully for the
test to pass.

Regenerating the PPEG Implementation
====================================

 After changing a grammar, refresh `initPPEG.pika` with:

    output/PikaCmd tools/ppeg/updatePPEG.pika

 The same script can be run to experiment directly with the compilers. It rebuilds both variants and writes the new
implementation to `initPPEG.pika` if everything succeeds.

Example: Using the Local Compiler
=================================

 Below is a minimal example that compiles `examples/digits.ppeg` into a local parsing function and runs it. The script
locates both `ppeg.pika` and `digits.ppeg` relative to its own path so it works no matter which directory it is
launched from:

    include('systools.pika');
    include('stdlib.pika');
    include(run.root # '../tools/ppeg/ppeg.pika');

    src = load(run.root # 'digits.ppeg');
    parseDigits = ppeg.compileFunction(src);

    assert(> parseDigits('12345'));
    assert(> !parseDigits('12a45'));

PikaScript Actions
==================

 PPEG grammars can embed blocks of PikaScript that run when the preceding
 expression succeeds. These action blocks appear inside braces `{}` and end
 with a `;true` so the parser always continues after running the code.
 Before the action executes `$$` already holds the value produced by the
 expression. The code may read or modify this value in place.

 The following helper variables are available inside an action:

-  `$$` – current result container. Use `$$=` before an expression to capture
   the raw substring it consumes.
-  `$$s` – the source string being parsed.
-  `$$i` – the index within `$$s` where the next character will be read.
-  `$$parser` – dictionary holding all generated parser functions. Global
   grammars populate this dictionary while local compilers return it.

 These identifiers are expanded by the compiler so that actions can inspect
 the input, construct data structures or call helper functions. Use
 `ppeg.fail()` to abort parsing and report an error.

Tags and Captures
=================

 Every rule receives a single argument in `$$`. Whatever the caller has
 placed there can be read and modified, so `$$` acts as both input and
 output. Unless you tag an expression the exact same object flows into
 each sub-expression and any changes they make remain visible. Tagging
 an expression with `name:expr` temporarily rebinds `$$` to `$name` while
 `expr` runs. When it succeeds `$name` keeps the produced value and `$$`
 reverts to its previous binding. Nothing is automatically merged back
 into the caller&#8217;s `$$`&nbsp;&mdash;&nbsp;store the value yourself if
 needed.

 Prefixing an expression with `name=` or `$$=` captures the exact text
 that the expression consumes before any actions run.  This is useful for
 converting the substring to another datatype or keeping it for later
 inspection.

 The following small grammar demonstrates these features by building a
 dictionary from colon separated pairs:

     root <- "{" _            { $$ = new(Container) }
              pair ("," _ pair)* "}" _ !.

     pair <- key:ident ":" _ val:number { [$$][$key] = $val }

     ident <- $$=[a-zA-Z]+ _
     number <- digits=[0-9]+ { $$ = evaluate('+' # digits) } _
     _ <- [ \t\r\n]*

 Here `pair` tags the identifier and number so its action can access them
 as `$key` and `$val`.  The `number` rule captures the raw digits in
 `$digits` before converting them to a numeric value.  Tagged and
 captured variables remain available until the current rule finishes,
allowing later actions to read or modify them.

Working with Custom Fields
==========================

 More elaborate grammars often store helper information in `$$` so that
 multiple rules can share it.  The monolithic JSON example distributes
 values into a pre-existing container designated by `$$.target`:

     root   <- _ { $$parser.null = coalesce(@$$.null, <null>); }
                (object / array) !.

     object <- "{"_ ( member (","_ member)* )? "}"_

     member <- id:string ":"_            { $v.target = @[$$.target][undotify($id)] }
                v:value

     value  <- string                     { [$$.target] = $$ }
                / number                  { [$$.target] = $$ }
                / "true" _               { [$$.target] = true }
                / "false" _              { [$$.target] = false }
                / "null" _               { [$$.target] = $$parser.null }
                / object
                / array

 The caller initializes `$$.target` to a container and each rule stores
 its result at that location.  Because `target` is just a field inside
 `$$` it is visible to all sub-expressions until the rule returns.
