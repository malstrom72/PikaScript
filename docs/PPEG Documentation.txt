PPEG
####

What is PPEG?
=============

 PPEG is a parser generator written in PikaScript. It consumes grammars described using Parsing Expression Grammars
(PEG) and produces parser functions. All related files live in the `tools/ppeg` folder. The runtime interface
`ppeg.pika` loads the generated `initPPEG.pika` and exposes the `PPEG` class used to build parsers. The folder also
holds the grammar sources and an `updatePPEG.pika` script for regenerating `initPPEG.pika`.

Global vs Local Compilers
=========================

 The project provides two self-hosted grammars:

-  `tools/ppeg/ppegGlobal.ppeg` – builds parser functions stored in whatever dictionary `ppeg.$compileTo` points at.
  This variant uses global variables and is what regenerates PPEG itself (`initPPEG.pika`).

-  `tools/ppeg/ppegLocal.ppeg` – returns a self-contained parsing function. It relies on no globals and is easier to
  embed in other projects.

Running the Compilers
=====================

 Build the command line tool used to run scripts:
   
    bash tools/PikaCmd/SourceDistribution/BuildPikaCmd.sh       # or BuildPikaCmd.cmd on Windows

 Run the regression test that exercises both compiler variants from the repository root:

    output/PikaCmd tests/ppegTest.pika

 The test first uses the *global* compiler and then the *local* one. Both must compile themselves successfully for the
test to pass.

Regenerating the PPEG Implementation
====================================

 After changing a grammar, refresh `initPPEG.pika` with:

    output/PikaCmd tools/ppeg/updatePPEG.pika

 The same script can be run to experiment directly with the compilers. It rebuilds both variants and writes the new
implementation to `initPPEG.pika` if everything succeeds.

Example: Using the Local Compiler
=================================

 Below is a minimal example that compiles `examples/digits.ppeg` into a local parsing function and runs it. The script
locates both `ppeg.pika` and `digits.ppeg` relative to its own path so it works no matter which directory it is
launched from:

    include('systools.pika');
    include('stdlib.pika');
    include(run.root # '../tools/ppeg/ppeg.pika');

    src = load(run.root # 'digits.ppeg');
    parseDigits = ppeg.compileFunction(src);

    assert(> parseDigits('12345'));
    assert(> !parseDigits('12a45'));

compileFunction
===============

Syntax
------

    parser = ppeg.compileFunction(source [, @outFunc [, dd [, iref [, rule = 'root']]]])

Description
-----------

 Converts <code>source</code> into a parser function. If <code>@outFunc</code> is supplied,
 the generated parser is stored there and the call returns <code>true</code>; otherwise it
 returns the new parser.

 <code>dd</code> and <code>iref</code> establish the default dictionary container and index
 reference for the parser. They let callers provide an external container and position
 variable that each rule will update. The optional <code>rule</code> parameter selects the
 starting rule and defaults to <code>'root'</code>.


PikaScript Actions
==================

 PPEG grammars may attach PikaScript code to an expression. The code is written
 inside braces `{}` and always succeeds because it ends with `;true`. Before the
 block runs, `$$` already contains the value produced by the expression. The
 action can inspect or modify this value directly.

 The following helpers are available inside an action:

-  `$$` – current result container. Use `$$=` before an expression to capture
   the substring it consumes.
-  `$$s` – the source string being parsed.
-  `$$i` – index within `$$s` for the next character.
-  `$$parser` – dictionary holding all generated parser functions.

 These identifiers let actions look at the input, build data structures, or
 report errors via `ppeg.fail()`.

Tags and Captures
=================

 Every rule takes `$$` as its input and also returns it. Untagged
 subexpressions therefore share one container and may update it in place. A
 tagged expression `name:expr` temporarily binds `$$` to `$name` while `expr`
 runs. When the expression finishes, `$name` contains the produced value and
 `$$` again refers to the outer container so the rule can decide how to use the
 new data.

 A capture `name=expr` (or `$$=expr`) grabs the substring consumed by `expr`
 before any action executes. The action can then convert this text or store it.

 The grammar below builds a dictionary from colon-separated pairs:

     root <- "{" _            { $$ = new(Container) }
              pair ("," _ pair)* "}" _ !.

     pair <- key:ident ":" _ val:number { [$$][$key] = $val }

     ident <- $$=[a-zA-Z]+ _
     number <- digits=[0-9]+ { $$ = evaluate('+' # digits) } _
     _ <- [ \t\r\n]*

 `pair` tags the identifier and number so the action can read `$key` and
 `$val`. `number` captures the digits in `$digits` before converting
 them. Tagged variables remain available until the rule returns.

Working with Custom Fields
==========================

 Grammars often pass context in `$$`.  The monolithic JSON parser
 writes results into the container referenced by `$$.target`:

     root   <- _ { $$parser.null = coalesce(@$$.null, <null>); }
                (object / array) !.

     object <- "{"_ ( member (","_ member)* )? "}"_

     member <- id:string ":"_            { $v.target = @[$$.target][undotify($id)] }
                v:value

     value  <- string                     { [$$.target] = $$ }
                / number                  { [$$.target] = $$ }
                / "true" _               { [$$.target] = true }
                / "false" _              { [$$.target] = false }
                / "null" _               { [$$.target] = $$parser.null }
                / object
                / array

 Initialize `$$.target` before parsing; each rule stores its result in
 that field.  Because `target` is just a member of `$$`, all nested
 rules see it until the current rule finishes.
