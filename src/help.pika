/*
	help.pika v0.941

	PikaScript is released under the "New Simplified BSD License". http://www.opensource.org/licenses/bsd-license.php
	
	Copyright (c) 2009-2013, NuEdge Development / Magnus Lidstroem
	All rights reserved.
*/

include('stdlib.pika');

prune(@help);

describe = function {
	vargs(@category, @page, @syntax,, @description, @examples, @seealso);
	if (exists(@::help[page])) throw('Help page ' # escape(page) # ' already described');
	::help._categories[category][page] = page;
	::help[page].category = category;
	::help[page].syntax = syntax;
	::help[page].description = coalesce(@description);
	::help[page].examples = coalesce(@examples);
	::help[page].seealso = coalesce(@seealso);
	full = 'SYNTAX' # LF # syntax # LF # LF # 'CATEGORY' # LF # category;
	if (exists(@description)) full #= LF # LF # 'DESCRIPTION' # LF # description;
	if (exists(@examples)) full #= LF # LF # 'EXAMPLE(S)' # LF # examples;
	if (exists(@seealso)) full #= LF # LF # 'SEE ALSO' # LF # seealso;
	::help[page] = full;
	::help._isdirty = true;
};

help._isdirty = false;
help._lookup = function {
	if (help._isdirty) {
		::help._isdirty = false;
		::help['#categories'] = 'Defined help categories:' # LF # LF;
		lastCategory = '';
		foreach(@::help._categories, >{
			i = find($1, '.');
			thisPage = $1{(i + 1):};
			thisCategory = $1{:i};
			if (lastCategory !== thisCategory) {
				if (lastCategory !== '') ::help[lastCategory] = pageList{:length(pageList) - 2};
				lastCategory = thisCategory;
				pageList = 'The category ' # thisCategory # ' contains the following help pages:' # LF # LF;
				::help['#categories'] #= thisCategory # ', ';
			};
			pageList #= thisPage # ', ';
		});
		if (lastCategory !== '') ::help[lastCategory] = pageList{:length(pageList) - 2};
		::help['#pages'] = 'Available help pages:' # LF # LF;
		foreach(@::help, >if ($1{0} !== '_' && find('.', $1) != 0) ::help['#pages'] #= $1 # ', ');
		::help['#categories'] = ::help['#categories']{:length(::help['#categories']) - 2};
		::help['#pages'] = ::help['#pages']{:length(::help['#pages']) - 2};
	};
	page = coalesce(@$0, 'help');
	if (page{0} === '/') {
		searchFor = lower(page{1:});
		searchLen = length(searchFor);
		surroundChars = max(30 - (searchLen >> 1), 10);
		found = 0;
		foreach(@::help, >{
			if ($1{0} !== '_' && find('.', $1) != 0 && (i = search(lower($2), searchFor)) < length($2)) {
				$line = $2{i - surroundChars:surroundChars} # '--->' # $2{i:searchLen}
						# '<---' # $2{i + searchLen:surroundChars};
				if (found == 0) print("The following pages contains the search string (showing only the first match for each page):\n");
				print($1 # repeat(' ', 12 - length($1)) # ':  ' # replace($line, "\t\n", ' ', find, 1));
				++found;
			}
		});
		if (found == 0) print("No page contained the search string");
	} else if (exists(@::help[page])) print(repeat('=', 20) # LF # help[page] # LF # repeat('=', 20))
	else print('No help page called ' # escape(page) # ". Type help('#pages') to list all available pages.");
	( void )
};

help = function { /****    Type help() to get started.    ****/        invoke('help._lookup', , @$) };
	
describe('#containers', 'ascend',	"@parent = ascend(@child)",						"Returns a reference to the \"parent container\" of @child (i.e. the variable or element that contains the sub-element referred to by @child). If @child is a top-level variable, void is returned.", "ascend(@x['3']) === @x\nascend(@x.y.z) === @x.y\nascend(@x) === void");
describe('#containers', 'clone',	"@target = clone(@source, @target)",			"Makes a \"deep copy\" of the container @source to @target, meaning that all elements under the source and any sub-elements that they may have (and so on) will be copied to the target. If there is a variable directly at @source it will also be copied to @target. The returned value is the input @target reference.\n\nNotice that this function does not erase any existing elements under @target. You may want to consider calling prune() on @target first.", "clone(@originalData, @myCarbonCopy)", 'copy, prune');
describe('#containers', 'foreach',	"foreach(@map, >doThis)",						"Traverses all elements under @map (and any sub-elements that they may have and so on) and calls >doThis once for every encountered element. (An alternative description of foreach() is that it calls >doThis for every found variable that begins with the value of @map # '.') Three arguments will be passed to >doThis:\n\n$0 will be the full reference to the found element (e.g. \"::zoo.elephant\")\n$1 will be the name of the element (e.g. \"elephant\")\n$2 will be the value of the element.\n\nThe order with which elements are processed is undefined and depends on the implementation of PikaScript. Any modifications to @map while running foreach() will not be reflected in the calls to >doThis. Notice that you normally would not use foreach() on arrays since it would also include the 'n' element (the element count). Use iterate() or a simple for-loop instead.", "foreach(map(@a, 'Asia', 4157, 'Africa', 1030, 'Americas', 929, 'Europe', 739, 'Oceania', 35), >print($1 # '=' # $2))", 'iterate');
describe('#containers', 'map',		"@map = map(@map, ['keys', <values>, ...])",	"Creates a \"map\" under @map by assigning sub-elements to @map for each key / value pair passed to the function. The returned value is the input @map reference.\n\nNotice that this function does not erase any existing elements under @map so you may call this function repeatedly to incrementally build a map. Use prune on @map to delete it.\n\nA creative use of this function is to create efficient \"switch statements\" something that is otherwise missing in PikaScript by mapping keys to functions / lambda expressions. You could then execute the switch like this: mySwitch[theKey].", "map(@userInfo['magnus'], 'fullName','Magnus Lidstroem' , 'birthDate','31 march 1972' , 'favoriteColor','#3333FF')\nmap(@actions, 'hi',>print('Good day sir!') , 'spin',>{ for (i = 0; i < 360; ++i) print('Spun ' # i # ' degrees') } , 'quit',>doQuit = true)\n[map(@temp, 'zero',0 , 'one',1 , 'two',2 , 'three',3)]['two'] == 2", 'foreach, prune, set');
describe('#containers', 'prune',	"+count = prune(@reference)",					"Deletes the variable referenced to by @reference as well as all its sub-elements. Use prune() to delete an entire \"plain old data\" container (e.g. an \"array\" or \"map\"). Use destruct() instead for deleting an \"object\" to have its destructor called before it is deleted. prune() returns the number of variables that were deleted.", "prune(@myArray)", 'delete, destruct');
describe('#containers', 'redotify',	"'zzz...' = redotify('zzz%2e%2e%2e')",			"Decodes an \"undotified\" string as returned from undotify(). See help for \"undotify\" for further explanation and examples.", "redotify('nearly 50%25 use google%2ecom daily') === 'nearly 50% use google.com daily'", 'undotify');
describe('#containers', 'set',		"@set = set(@set, ['keys', ...])",				"Creates a \"set\" under @set by assigning sub-elements with the value true for each key. The returned value is the input @set reference.\n\nNotice that this function does not erase any existing elements under @set so you may call this function repeatedly to incrementally build a set. Use prune() on @set to delete it.\n\nOne practical use for sets is to efficiently check if a value belongs to a group of values. Initially you create the group of values with this function and later you can call exists(@set[key]).", "set(@validColors, 'red', 'green', 'blue', 'yellow')\nexists(@[set(@smallPrimes, 2, 3, 5, 7, 11, 13, 17, 19)][13])", 'foreach, map, prune');
describe('#containers', 'undotify',	"'zzz%2e%2e%2e' = undotify('zzz...')",			"Simply replaces all '.' with '%2e' and all '%' with '%25'. The purpose of this function is to allow arbitrary strings to work as keys in multi-dimensional arrays / deep containers. Without \"undotifying\" keys, any '.' in the keys would be interpreted as separators. E.g. \"files['name.ext'].size\" is the same as \"files.name.ext.size\", which is probably not what you want. Instead use \"files[undotify('name.ext')].size\". To return the original key from an \"undotified\" key, use redotify().", "undotify('nearly 50% use google.com daily') === 'nearly 50%25 use google%2ecom daily'\nredotify(undotify('a.b.c%d.e.f')) === 'a.b.c%d.e.f'", 'redotify');

describe('#arrays', 'append',	"@array = append(@array, [<elements>, ...])",		"Appends <elements> to @array. If [@array].n does not exist it will be initialized to 0 and this routine will in practice work like compose(). Unlike compose() however, all element argument must be present. The returned value is the input @array reference.\n\nNotice that calling this function on a \"double-ended queue\" also works.", "append(@myArray, 5, 6, 7, 8)\nequal(append(compose(@temp1, 'a', 'b', 'c'), 'd', 'e', 'f'), compose(@temp2, 'a', 'b', 'c', 'd', 'e', 'f')) == true", 'compose, insert');
describe('#arrays', 'compose',	"@array = compose(@array, [<elements>, ...])",		"Creates an array of indexed elements under @array initialized with the values of the remaining arguments (<element>). The first element will have an index of zero (e.g. \"array[0]\"). The special element 'n' (e.g. \"array.n\") will contain the number of indexed elements in the array. If an element argument is omitted the corresponding element will not be initialized, possibly making the array \"non-contiguous\". The returned value is the input @array reference.\n\nNotice that this function does not erase any existing elements under @array. You may want to consider calling prune() on @array before composing a new array.", "compose(@myArray, 1, 2, 3, 4)\ncompose(@holy, 'nextIsEmpty', , 'previousWasEmpty')\n[compose(@temp, 'zero', 'one', 'two', 'three')][2] === 'two'", 'append, decompose, map, prune');
describe('#arrays', 'copy',		"@target = copy(@source, +offset, +count, @target, +index)", "Copies +count elements from the @source array beginning at +offset into @target at +index, replacing any already existing elements at the target indices. The element count of the @target array (i.e. [@target].n) may be incremented to fit the new elements.\n\nThe @source array must be contiguous. If the output +index is greater than [@target].n (or (+index) + (+count) < 0), the resulting array will become non-contiguous.\n\nOnly direct elements under the arrays will be affected. Any sub-elements that they in turn may have are ignored. @source and @target may reference the same array. The returned value is the input @target reference.", "copy(@myArray, 10, 5, @myArray, 13)\nequal(copy(compose(@temp1, 'a', 'b', 'c', 'd'), 1, 2, compose(@temp2, 'e', 'f', 'g', 'h'), 3), compose(@temp3, 'e', 'f', 'g', 'b', 'c')) == true", 'clone, inject, remove');
describe('#arrays', 'decompose',"decompose(@array, [@variables, ...])",				"Decomposes an array by storing the indexed elements under @array one by one into the given references. If an argument is left empty, the corresponding element index will be skipped.", "decompose(@breakMe, @first, @second, @third, , @noFourthButFifth)", 'compose');
describe('#arrays', 'equal',	"?same = equal(@arrayA, @arrayB)",					"Returns true if the arrays @arrayA and @arrayB are the same size and all their elements are identical. Both arrays must be contiguous (i.e. all their elements must be defined). Only direct elements under the arrays will be tested. Any sub-elements that they in turn may have are silently ignored.", "equal(@firstArray, @secondArray)\nequal(compose(@temp1, 1, 10, 100, 'one thousand'), compose(@temp2, 1, 10, 100, 'one thousand')) == true");
describe('#arrays', 'fill',		"@array = fill(@array, +offset, +count, <value>)",	"Fills a range of +count elements in @array with <value> starting at +offset, replacing any existing elements. If the target @array does not exist (i.e. [@array].n is not defined) it is created. The element count (i.e. [@array].n) may be incremented to fit the new elements.\n\nOnly direct elements under the arrays will be affected. The returned value is the input @array reference.", "equal(fill(@a, 0, 5, 'x'), compose(@b, 'x', 'x', 'x', 'x', 'x'))", 'copy, inject, insert, remove');
describe('#arrays', 'inject',	"@target = inject(@source, +offset, +count, @target, +index)", "Inserts +count elements from the @source array beginning at +offset into @target at +index, relocating any elements at and after +index to make room for the inserted elements. Both arrays must be contiguous and the target +index must be between 0 and [@target].n. Only direct elements under the arrays will be affected. Any sub-elements that they in turn may have are ignored. @source and @target should not reference the same array. The returned value is the input @target reference.", "inject(@myArray, 10, 5, @myArray, 13)\nequal(inject(compose(@temp1, 'a', 'b', 'c', 'd'), 1, 2, compose(@temp2, 'e', 'f', 'g', 'h'), 3), compose(@temp3, 'e', 'f', 'g', 'b', 'c', 'h')) == true", 'copy, fill, insert, remove');
describe('#arrays', 'iterate',	"iterate(@array, >doThis)",							"Iterates all elements in @array (as determined by [@array].n) and calls >doThis once for every encountered element in ascending index order. Three arguments will be passed to >doThis:\n\n$0 will be the full reference to the found element (e.g. \"::highscores.3\")\n$1 will be the element index (e.g. 3)\n$2 will be the value of the element.\n\niterate() is the equivalent to foreach() for arrays. Any change to [@array].n while running iterate() will not be accounted for. The array must be contiguous. Only direct elements under the array will be iterated.", "iterate(compose(@a, 0, 'one', 2, true), >print($1 # '=' # $2))", 'foreach');
describe('#arrays', 'insert',	"@array = insert(@array, +offset, [<elements>, ...])",	"Inserts one or more elements into @array before the index +offset. The array must be contiguous. Only direct elements under the array will be moved to make room for the new elements. Any sub-elements that they in turn may have remain unaffected. +offset must be between 0 and the element count of @array (or an exception will be thrown). [@array].n must be defined prior to calling this routine. The returned value is the input @array reference.", "insert(@myArray, 10, 'insert', 'three', 'strings')\nequal(insert(compose(@temp1, 'a', 'b', 'f'), 2, 'c', 'd', 'e'), compose(@temp2, 'a', 'b', 'c', 'd', 'e', 'f')) == true", 'inject, remove');
describe('#arrays', 'remove',	"@array = remove(@array, +offset, [+count = 1])",	"Removes +count number of elements from @array beginning at +offset, relocating any elements after the removed elements so that the array remains contiguous. (Only direct elements under the array are moved. Any sub-elements under these elements will be left untouched.)\n\nIf +offset and / or +count are negative, this function still yields predictable results (e.g. an +offset of -3 and +count of 6 will remove the three first elements). Likewise, it is allowed to remove elements beyond the end of the array (but naturally it will have no effect). The returned value is the input @array reference.", "remove(@removeNumberThree, 3)\nremove(@drop1and2, 1, 2)\nequal(remove(compose(@temp1, 'a', 'b', 'c', 'd', 'e'), 1, 3), compose(@temp2, 'a', 'e')) == true", 'copy, fill, inject, insert, prune');
describe('#arrays', 'rsort',	"@array = rsort(@array)",							"Sorts the elements of @array in descending order. The returned value is the input @array reference. To sort in ascending order, use sort(). If you need greater control over the sorting (e.g. how elements are compared), use the lower level function qsort() instead.", "rsort(@myArray)\nequal(rsort(compose(@temp1, 1.1, -5, 1.5, 17, 0x10, 'xyz', 'a', 'def', 'a')), compose(@temp2, 'xyz', 'def', 'a', 'a', 17, 0x10, 1.5, 1.1, -5)) == true", 'qsort, sort');
describe('#arrays', 'qsort',	"qsort(+from, +to, >compare, >swap)",				"This is an abstract implementation of the quicksort algorithm. qsort() handles the logic of the sorting algorithm (the bones) while you provide the functions >compare and >swap that carries out the concrete operations on the data being sorted (the meat).\n\n+from and +to defines the sorting range (+to is non-inclusive).\n\n>compare is called with two sorting indices and you should return a negative value if the data for the first index ($0) should be placed before the data for the second index ($1). Return a positive non-zero value for the opposite and return zero if the data is identical. (You can use the global ::compare function to easily implement this.)\n\n>swap is also called with two indices in $0 and $1 ($0 is always less than $1). The function should swap the data for the two indices. (You can use the global ::swap function to easily implement this.)\n\nThe functions sort() and rsort() use this function to implement sorting of entire arrays (ascending and descending respectively).  ", "qsort(0, myArray.n, >myArray[$0] - myArray[$1], >swap(@myArray[$0], @myArray[$1]))\nqsort(0, scrambleMe.n, >random(2) - 1, >swap(@scrambleMe[$0], @scrambleMe[$1]))", 'compare, rsort, sort');
describe('#arrays', 'sort',		"@array = sort(@array)",							"Sorts the elements of @array in ascending order. The returned value is the input @array reference. To sort in descending order, use rsort(). If you need greater control over the sorting (e.g. how elements are compared), use the lower level function qsort() instead.", "sort(@myArray)\nequal(sort(compose(@temp1, 1.1, -5, 1.5, 17, 0x10, 'xyz', 'a', 'def', 'a')), compose(@temp2, -5, 1.1, 1.5, 0x10, 17, 'a', 'a', 'def', 'xyz')) == true", 'qsort, rsort');

describe('#queues', 'resetQueue',	"resetQueue(@queue)",							"Initializes the \"double-ended queue\" referenced to by @queue for use with pushBack(), popFront() etc by setting the sub-elements [@queue].m and [@queue].n to 0.\n\n[@queue].m is the index of the first element on the queue and it is decremented on pushFront() and incremented on popFront(). [@queue].n is one greater than the index of the last element on the queue and it is incremented on pushBack() and decremented on popBack(). (The 'm' and 'n' identifiers were chosen to make queue() compatible with some of the array functions such as append().)", "resetQueue(@dq)", 'popBack, popFront, pushBack, pushFront, queueSize');
describe('#queues', 'queueSize',	"+count = queueSize(@queue)",					"Returns the count of elements in the double-ended queue @queue. The count is defined by [@queue].n - [@queue].m (see resetQueue() for an explanation). (@queue must have been initialized with resetQueue() prior to calling this routine.)", "count = queueSize(@dq)", 'popBack, popFront, pushBack, pushFront, resetQueue');
describe('#queues', 'popBack',		"<value> = popBack(@queue)",					"Pops <value> from the back of the double-ended queue @queue. If @queue is empty an exception will be thrown. (@queue must have been initialized with resetQueue() prior to calling this routine.)", "lastIn = popBack(@dq)", 'popFront, pushBack, pushFront, queueSize, resetQueue');
describe('#queues', 'pushBack',		"@queue = pushBack(@queue, <value>)",			"Pushes <value> to the back of the double-ended queue @queue. The returned value is the input @queue reference. (@queue must have been initialized with resetQueue() prior to calling this routine.)\n\nIt is also legal to call append() to push several elements at once to a queue.", "pushBack(@dq, 'lastIn')", 'append, popBack, popFront, pushFront, queueSize, resetQueue');
describe('#queues', 'popFront',		"<value> = popFront(@queue)",					"Pops <value> from the front of the double-ended queue @queue. If @queue is empty an exception will be thrown. (@queue must have been initialized with resetQueue() prior to calling this routine.)", "firstOut = popFront(@dq)", 'popBack, pushBack, pushFront, queueSize, resetQueue');
describe('#queues', 'pushFront',	"@queue = pushFront(@queue, <value>)",			"Pushes <value> to the front of the double-ended queue @queue. The returned value is the input @queue reference. (@queue must have been initialized with resetQueue() prior to calling this routine.)", "pushFront(@dq, 'firstOut')", 'popBack, popFront, pushBack, queueSize, resetQueue');

describe('#debug', 'assert',	"assert(?testResult|>testMe, ['description'])",		"Asserts are used to check for programming errors in run-time. Until you run \"debug.pika\", asserts are disabled which means this function will do absolutely nothing (it is defined as an empty function in \"stdlib.pika\"). Running \"debug.pika\" will enable asserts by redefining this function. When enabled, it either checks the boolean ?testResult or executes >testMe and checks the result.\n\nTwo things differ depending on the choice of passing a boolean or a function / lambda expression. If you pass a boolean, e.g. assert(myfunc() == 3), and assertions are disabled, the argument will still be evaluated, i.e. myfunc() will still be called. Furthermore, if 'description' is omitted, the exception on an assertion failure will simply contain 'true' or 'false'. \n\nIf you pass a function / lambda expression, e.g. assert(>myfunc() == 3), the argument will only be evaluated if assertions are enabled and the exception will contain the full expression. In most cases you will want to use this variant.", "assert(>(0 <= $0 <= 100))\nassert(alwaysCallMe(), 'alwaysCallMe() failed miserably')");
describe('#debug', 'trace',		"trace([>tracer], [+level = 2])",					"Sets or resets the tracer function. The tracer function is called at various points in the PikaScript interpreter code. For example, you can use it for tracing caught exceptions, function calls and even implement debuggers and profilers.\n\n+level ranges from 0 (no tracing) to 21 (maximum tracing) and determines which events that will trigger a callback. The default trace level of 2 calls the trace function on each function entry and exit. Other useful levels are 1 for tracing caught errors and 3 to trace every interpreted statement. (Please see \"PikaScriptImpl.h\" for a complete listing of all levels.)\n\nThe >tracer function will be called with the following arguments:\n\n$0 = the source code being executed\n$1 = the offset into the source code\n$2 = whether $3 is an lvalue or an rvalue (lvalue = identifier, rvalue = actual value)\n$3 = the result from the last operation\n$4 = trace level\n$5 = false for \"entry\", true for \"exit\" (e.g. function call entry / exit).\n\nCall trace() without arguments to stop all tracing.", "trace()\ntrace(function { print((if ($5) '} ' else '{ ') # if (exists(@^$callee)) ^$callee else '????') })");

describe('#help', 'help',		"help('page'|'/search')", "Prints a help page or searches the help database for text. Function syntax is documented with the following conventions:\n\n- Arguments in [ ] brackets are optional and default values may be documented like this: [arg = value]\n- Vertical bar | is used to separate alternatives\n- ... means repeat 0 or more times\n- \"Type classes\" can be identified as follows: ?boolean, +number, 'string', >function, @reference, <arbitrary>\n\nType help('#categories') for a list of valid categories. help('#pages') lists all available help pages. You can also search the entire help database for a string with help('/search')", "help('#categories')\nhelp('#pages')\nhelp('#utils')\nhelp('args')\nhelp('/delete')");
describe('#help', 'describe',	"describe('category', 'page', 'syntax', ['description'], ['examples'], ['seealso'])", "Adds a help page to the database.", "describe('#mine', 'countIf', '+count = countIf(@array, <value>)', 'Counts the number of items in @array that is equal to <value>.', \"n = countIf(@fruits, 'apple')\")");

describe('#math', 'abs',	'+y = abs(+x)',				'Returns the absolute value of +x.', "abs(3.7) == 3.7\nabs(-3.7) == 3.7\nabs(-infinity) == +infinity", 'sign');
describe('#math', 'acos',	'+y = acos(+x)',			"Returns the arccosine of +x (which should be in the range -1 to 1 or the result will be undefined). The returned value is in the range 0 to PI.\n\nInverse: cos().", "acos(0.0) == PI / 2\nacos(0.73168886887382) == 0.75\nacos(cos(0.6)) == 0.6", 'asin, atan, cos');
describe('#math', 'asin',	'+y = asin(+x)',			"Returns the arcsine of +x (which should be in the range -1 to 1 or the result will be undefined). The returned value is in the range -PI / 2 to PI / 2.\n\nInverse: sin().", "asin(0.0) == 0.0\nasin(0.69613523862736) == 0.77\nasin(sin(0.5)) == 0.5", 'acos, atan, sin');
describe('#math', 'atan',	'+y = atan(+x)',			"Returns the arctangent of +x. The returned value is in the range -PI / 2 to PI / 2.\n\nInverse: tan().", "atan(0.0) == 0.0\natan(0.93159645994407) == 0.75\natan(tan(0.5)) == 0.5", 'acos, asin, atan2, tan');
describe('#math', 'atan2',	'+z = atan2(+y, +x)',		'Returns the arctangent of +y/+x with proper handling of quadrants. The returned value is in the range -PI to PI.', "atan2(0.0, 1.0) == 0.0\natan2(1.0, 0.0) == PI / 2\natan2(sin(0.5), cos(0.5)) == 0.5", 'atan');
describe('#math', 'cbrt',	'+y = cbrt(+x)',			"Returns the cube root of +x.\n\nInverse: cube(+y).", "cbrt(0.0) == 0.0\ncbrt(0.421875) == 0.75\ncbrt(cube(-0.7)) == -0.7", 'sqr');
describe('#math', 'ceil',	'+y = ceil(+x)',			'Returns the ceiling of value +x. Ceil() rounds both positive and negative values upwards.', "ceil(0.0) == 0.0\nceil(-0.99999) == 0.0\nceil(1000.00001) == 1001.0", 'floor, round, trunc');
describe('#math', 'cos',	'+y = cos(+x)',				"Returns the cosine of +x. The returned value is in the range -1 to 1.\n\nInverse: acos().", "cos(0.0) == 1.0\ncos(0.72273424781342) == 0.75\ncos(acos(0.5)) == 0.5", 'acos, sin, tan');
describe('#math', 'cosh',	'+y = cosh(+x)',			'Returns the hyperbolic cosine of +x.', "cosh(0.0) == 1.0\ncosh(0.9624236501192069) == 1.5", 'sinh, tanh');
describe('#math', 'cube',	'+y = cube(+x)',			"Returns the cube of +x.\n\nInverse: cbrt(+y).", "cube(0.0) == 0.0\ncube(0.90856029641607) == 0.75\ncube(cbrt(-0.7)) == -0.7", 'cbrt, sqr');
describe('#math', 'exp',	'+y = exp(+x)',				"Returns the exponential of +x. I.e, the result is e to the power +x.\n\nInverse: log().", "exp(0.0) == 1.0\nexp(1.0) == 2.718281828459\nexp(-0.28768207245178) == 0.75\nexp(log(0.6)) == 0.6", 'log, log2, log10, pow');
describe('#math', 'factorial',	'+y = factorial(+x)',	'Returns the factorial of value +x. +x should be an integer in the range of 1 to 170.', "factorial(10) == 3628800");
describe('#math', 'floor',	'+y = floor(+x)',			'Returns the floor of value +x. Floor() rounds both positive and negative values downwards.', "floor(0.0) == 0.0\nfloor(-0.99999) == -1.0\nfloor(1000.00001) == 1000.0", 'ceil, round, trunc');
describe('#math', 'log',	'+y = log(+x)',				"Returns the natural logarithm of +x (i.e. the logarithm with base e). +x should be positive or the result will be undefined.\n\nInverse: exp().", "log(0.0) == -infinity\nlog(1.0) == 0.0\nlog(2.7182818284591) == 1.0\nlog(exp(0.6)) == 0.6", 'exp, log2, log10, logb, nroot, pow');
describe('#math', 'log2',	'+y = log2(+x)',			"Returns the base-2 logarithm of +x. +x should be positive or the result will be undefined.\n\nInverse: pow(2, +y).", "log2(0.0) == -infinity\nlog2(1.0) == 0.0\nlog2(65536.0) == 16.0\nlog2(pow(2, 1.3)) == 1.3", 'exp, log, log10, logb, nroot, pow');
describe('#math', 'log10',	'+y = log10(+x)',			"Returns the base-10 logarithm of +x. +x should be positive or the result will be undefined.\n\nInverse: pow(10, +y).", "log10(0.0) == -infinity\nlog10(1.0) == 0.0\nlog10(10000.0) == 4.0\nlog10(pow(10, 0.6)) == 0.6", 'exp, log, log2, logb, nroot, pow');
describe('#math', 'logb',	'+y = logb(+b, +x)',		"Returns the logarithm of +x with base +b. +x should be positive or the result will be undefined. Equivalent to log(+x) / log(+b).\n\nInverses: +x = pow(+b, +y), +b = nroot(+y, +x).", "logb(20, 1.0) == 0.0\nlogb(20, 8000) == 3", 'exp, log, log2, log10, nroot, pow');
describe('#math', 'nroot',	'+x = nroot(+y, +z)',		"Returns the nth (+y) root of +z.\n\nInverse: +z = pow(+x, +y).", "nroot(11, pow(17, 11)) == 17", 'exp, log, log2, logb, log10, pow');
describe('#math', 'pow',	'+z = pow(+x, +y)',			"Returns +x raised to the power of +y.\n\nInverses: +y = log(+z) / log(+x) or logb(+x, +z), +x = pow(+z, 1.0 / +y) or nroot(+y, +z).", "pow(0.0, 0.0) == 1.0\npow(10.0, 4.0) == 10000.0\npow(10.0, log10(0.8)) == 0.8\npow(pow(2.8, 9.8), 1.0 / 9.8) == 2.8", 'exp, log, log2, logb, log10, nroot');
describe('#math', 'random',	'+y = random(+x)',			'Returns a pseudo-random number between 0 and +x.', 'random(100.0)');
describe('#math', 'round',	'+y = round(+x)',			'Rounds the value of +x to the nearest integer. If the decimal part of +x is exactly 0.5, the rounding will be upwards (e.g. -3.5 rounds to 3.0).', "round(1.23456) == 1\nround(-1.6789) == -2\nround(3.5) == 4.0\nround(-3.5) == -3.0\nround(1000.499999) == 1000.0", 'ceil, floor, trunc');
describe('#math', 'sign',	'+y = sign(+x)',			"Returns -1 if +x is negative, +1 if +x is positive or 0 if +x is zero.", "sign(0.0) == 0.0\nsign(12.34) == 1\nsign(-infinity) == -1", 'abs');
describe('#math', 'sin',	'+y = sin(+x)',				"Returns the sine of +x. The returned value is in the range -1 to 1.\n\nInverse: asin().", "sin(0.0) == 0.0\nsin(0.84806207898148) == 0.75\nsin(asin(0.5)) == 0.5", 'asin, cos, tan');
describe('#math', 'sinh',	'+y = sinh(+x)',			'Returns the hyperbolic sine of +x.', "sinh(0.0) == 0.0\nsinh(0.61958958372348) == 0.66", 'cosh, tanh');
describe('#math', 'sqr',	'+y = sqr(+x)',				"Returns the square of +x.\n\nInverse: sqrt(+y).", "sqr(0.0) == 0.0\nsqr(0.86602540378444) == 0.75\nsqr(sqrt(0.75)) == 0.75", 'cube, sqrt');
describe('#math', 'sqrt',	'+y = sqrt(+x)',			"Returns the square root of +x. +x should be positive or the result will be undefined.\n\nInverse: sqr(+y).", "sqrt(0.0) == 0.0\nsqrt(0.5625) == 0.75\nsqrt(sqr(0.7)) == 0.7", 'sqr');
describe('#math', 'tan',	'+y = tan(+x)',				"Returns the tangent of +x.\n\nInverse: atan(+y).", "tan(0.0) == 0.0\ntan(0.603982978253) == 0.69\ntan(atan(0.3)) == 0.3", 'atan, cos, sin');
describe('#math', 'tanh',	'+y = tanh(+x)',			'Returns the hyperbolic tangent of +x.', "tanh(0.0) == 0.0\ntanh(0.9729550745276566) == 0.75", 'cosh, sinh');
describe('#math', 'trunc',	'+y = trunc(+x, [+n = 0])',	'Truncates the value of +x leaving up to +n decimal places intact. If +n is omitted, all decimals are truncated. Truncation rounds positive values downwards and negative values upwards.', "trunc(1.23456) == 1\ntrunc(-1.23456) == -1\ntrunc(1.23456, 2) == 1.23\ntrunc(1.5, 10) == 1.5", 'ceil, floor, precision, round');

describe('#objects', 'construct',		"@object = construct(@object, >constructor, [<arguments>, ...])",		"Constructs", "", 'destruct, new, newLocal, this');
describe('#objects', 'destruct',		"+count = destruct(@object)",											"Destructs", "", 'construct, delete, prune');
describe('#objects', 'gc',				"+count = gc()",														"Garbage collect.", "", 'new, newLocal');
describe('#objects', 'invokeMethod',	"<result> = invokeMethod(@object, 'method', @args, [+offset = 0], [+count])",	"Like invoke() but for methods.", "", 'invoke');
describe('#objects', 'method',			"'method' = method()",													"Method called.", "", 'this');
describe('#objects', 'new',				"@object = new(>constructor, [<arguments>, ...])",						"Allocates and constructs.", "", 'construct, gc, newLocal');
describe('#objects', 'newLocal',		"@object = newLocal(>constructor, [<arguments>, ...])",					"Allocates and constructs on local heap.", "", 'construct, gc, new');
describe('#objects', 'this',			"@object = this()",														"Object called.", "", 'method');

describe('#strings', 'char',		"'character' = char(+code)",						"Returns the character represented by +code as a string. +code is either an ASCII or Unicode value (depending on how PikaScript is configured). If +code is not a valid character code the exception 'Illegal character code: {code}' will be thrown.\n\nInverse: ordinal('character').", "char(65) === 'A'\nchar(ordinal('å')) === 'å'", 'ordinal');
describe('#strings', 'chop',		"'chopped' = chop('string', +count)",				"Removes the last +count number of characters from 'string'. This function is equivalent to 'string'{:length('string') - +count}. If +count is zero or negative, the entire 'string' is returned. If +count is greater than the length of 'string', the empty string is returned. (There is no function for removing characters from the beginning of the string because you can easily use 'string'{+count:}.)", "chop('abcdefgh', 3) === 'abcde'\nchop('abcdefgh', 42) === ''", 'length, right, trim');
describe('#strings', 'bake',		"'concrete' = bake('abstract', ['escape' = \"{\"], ['return' = \"}\"])",	"Processes the 'abstract' string by interpreting any text bracketed by 'escape' and 'return' as PikaScript expressions and injecting the results from evaluating those expressions. The default brackets are '{' and '}'. The code is evaluated in the caller's frame. Thus you can inject local variables like this: '{myvar}'.", "bake('The result of 3+7 is {3+7}') === 'The result of 3+7 is 10'\nbake('Welcome back {username}. It has been {days} days since your last visit.')", 'evaluate');
describe('#strings', 'escape',		"'escaped' = escape('raw')",						"Depending on the contents of the source string 'raw' it is encoded either in single (') or double (\") quotes. If the string contains only printable ASCII chars (ASCII values between 32 and 126 inclusively) and no apostrophes ('), it is enclosed in single quotes with no further processing. Otherwise it is enclosed in double quotes (\") and any unprintable ASCII character, backslash (\\) or quotation mark (\") is encoded using C-style escape sequences (e.g. \"line1\\nline2\").\n\nYou can use unescape() to decode an escaped string.", "escape(\"trivial\") === \"'trivial'\"\nescape(\"it's got an apostrophe\") === '\"it''s got an apostrophe\"'\nescape(unescape('\"first line\\n\\xe2\\x00tail\"')) === '\"first line\\n\\xe2\\x00tail\"'", 'unescape');
describe('#strings', 'find',		"+offset = find('string', 'chars')",				"Finds the first occurrence of any character of 'chars' in 'string' and returns the zero-based offset (i.e. 0 = first character). The search is case-sensitive. If no characters in 'chars' exist in 'string', the length of 'string' is returned. Use rfind() to find the last occurrence instead of the first. Use span() to find the first occurrence of any character not present in 'chars'. Use search() to find sub-strings instead of single characters.", "find('abcd', 'd') == 3\nfind('abcdcba', 'dc') == 2\nfind('nomatch', 'x') == 7", 'mismatch, rfind, search, span');
describe('#strings', 'length',		"+count = length('string')",						"Returns the character count of 'string'.", "length('abcd') == 4");
describe('#strings', 'lower',		"'lowercase' = lower('string')",					"Translates 'string' character by character to lower case. Notice that the standard implementation only works with characters having ASCII values between 32 and 126 inclusively.", "lower('aBcD') === 'abcd'", 'upper');
describe('#strings', 'mismatch',	"+offset = mismatch('first', 'second')",			"Compares the 'first' and 'second' strings character by character and returns the zero-based offset of the first mismatch (e.g. 0 = first character). If the strings are identical in contents, the returned value is the length of the shortest string. As usual, the comparison is case sensitive.", "mismatch('abcd', 'abcd') == 4\nmismatch('abc', 'abcd') == 3\nmismatch('abCd', 'abcd') == 2", 'find, search, span');
describe('#strings', 'ordinal',		"+code = ordinal('character')",						"Returns the ordinal (i.e. the character code) of the single character string 'character'. Depending on how PikaScript is configured, the character code is an ASCII or Unicode value. If 'character' cannot be converted to a character code the exception 'Value is not single character: {character}' will be thrown.\n\nInverse: char(+code).", "ordinal('A') == 65\nordinal(char(211)) == 211", 'char');
describe('#strings', 'precision',	"'string' = precision(+value, +precision)",			"Converts +value to a decimal number string (in scientific E notation if required). +precision is the maximum number of digits to include in the output. Scientific E notation (e.g. 1.3e+3) will be used if +precision is smaller than the number of digits required to express +value in decimal notation. The maximum number of characters returned is +precision plus 7 (for possible minus sign, decimal point and exponent).", "precision(12345, 3) === '1.23e+4'\nprecision(9876, 8) === '9876'\nprecision(9876.54321, 8) === '9876.5432'\nprecision(-0.000000123456, 5) === '-1.2346e-7'\nprecision(+infinity, 1) === '+infinity'", "radix, trunc");
describe('#strings', 'radix',		"'string' = radix(+value, +radix, [+minLength])",	"Converts the integer +value to a string using a selectable radix between 2 (binary) and 16 (hexadecimal). If +minLength is specified and the string becomes shorter than this, it will be padded with leading zeroes. May throw 'Radix out of range: {radix}' or 'Minimum length out of range: {minLength}'.", "radix(0xaa, 2, 12) === '000010101010'\nradix(3735928559, 16) === 'deadbeef'\nradix(0x2710, 10) === 10000", 'precision');
describe('#strings', 'repeat',		"'repeated' = repeat('repeatme', +count)",			"Concatenates 'repeatme' +count number of times.", "repeat(' ', 5) === '     '\nrepeat('-#-', 10) === '-#--#--#--#--#--#--#--#--#--#-'");
describe('#strings', 'replace',		"'processed' = replace('source', 'what', 'with', [>findFunction = search], [+dropCount = length(what)], [>replaceFunction = >$1])",	"Replaces all occurrences of 'what' with 'with' in the 'source' string.\n\nThe optional >findFunction allows you to modify how the function finds occurrences of 'what' and +dropCount determines how many characters are replaced on each occurrence. The default >findFunction is ::search (and +dropCount is the number of characters in 'what'), which means that 'what' represents a substring to substitute. If you want this function to substitute any occurrence of any character in 'what', you can let >findFunction be ::find and +dropCount be 1. Similarly, you may use ::span to substitute occurrences of all characters not present in 'what'.\n\nFinally, >replaceFunction lets you customize how substrings should be replaced. It will be called with two arguments, the source substring in $0 and 'with' in $1, and it is expected to return the replacement substring.", "replace('Barbazoo', 'zoo', 'bright') === 'Barbabright'\nreplace('Barbalama', 'lm', 'p', find, 1) === 'Barbapapa'\nreplace('Bqaxrbzzabypeillme', 'Bbarel', '', span, 1) === 'Barbabelle'\nreplace('B03102020', '0123', 'abmr', find, 1, >$1{$0}) === 'Barbamama'", "bake, find, search, span");
describe('#strings', 'reverse',		"'backwards' = reverse('string')",					"Returns 'string' reversed.", "reverse('stressed') === 'desserts'");
describe('#strings', 'rfind',		"+offset = rfind('string', 'chars')",				"As find(), but finds the last occurrence of any character of 'chars' instead of the first. -1 is returned if no character was found (unlike find() which returns the length of 'string').", "rfind('abcd', 'd') == 3\nrfind('abcdcba', 'dc') == 4\nrfind('nomatch', 'xyz') == -1", 'find, rsearch, rspan');
describe('#strings', 'right',		"'ending' = right('string', +count)",				"Returns the last +count number of characters from 'string'. This function is equivalent to 'string'{length('string') - +count:}. If +count is greater than the length of 'string', the entire 'string' is returned. If +count is zero or negative, the empty string is returned. (There is no \"left\" function because you can easily use 'string'{:+count}.)", "right('abcdefgh', 3) === 'fgh'\nright('abcdefgh', 42) === 'abcdefgh'", 'chop, length, trim');
describe('#strings', 'rsearch',		"+offset = rsearch('string', 'substring')",			"As search(), but finds the last occurrence of 'substring' in 'string' instead of the first. A negative value is returned if 'substring' was not found (unlike search() which returns the length of 'string').", "rsearch('abcdabcd', 'cd') == 6\nrsearch('nomatch', 'xyz') == -3", 'rfind, rspan, search');
describe('#strings', 'rspan',		"+offset = rspan('string', 'chars')",				"As span(), but finds the last occurrence of a character not present in 'chars' instead of the first. -1 is returned if the entire 'string' consists of characters in 'chars (unlike span() which returns the length of 'string').", "rspan('abcd', 'abc') == 3\nrspan('abcdcba', 'ab') == 4\nrspan('george bush', 'he bugs gore') == -1", 'rfind, rsearch, span');
describe('#strings', 'search',		"+offset = search('string', 'substring')",			"Finds the first occurrence of 'substring' in 'string' and returns the zero-based offset (e.g. 0 = first character). The search is case-sensitive. If 'substring' does not exist in 'string', the length of 'string' is returned. Use rsearch() to find the last occurrence instead of the first. Use find() to find the first occurrence of any character in a set of characters instead of a sub-string.", "search('abcdabcd', 'cd') == 2\nsearch('nomatch', 'x') == 7", 'find, mismatch, rsearch, span');
describe('#strings', 'span',		"+offset = span('string', 'chars')",				"Finds the first occurrence of a character in 'string' that is not present in 'chars' and returns the zero-based offset (i.e. 0 = first character). The search is case-sensitive. If the entire 'string' consists of characters in 'chars', the length of 'string' is returned. Use rspan() to find the last occurrence instead of the first. Use find() to find the first occurrence of any character in 'chars'.", "span('abcd', 'abc') == 3\nspan('abcdcba', 'ab') == 2\nspan('george bush', 'he bugs gore') == 11", 'find, mismatch, rspan, search');
describe('#strings', 'tokenize',	"tokenize('source', >processor, ['delimiters' = \"\\n\"])",			"Divides the 'source' string into tokens separated by any character in 'delimiters' (linefeed by default). For every extracted token, >processor is called, passing the token as the single argument $0 (not including the delimiter). The final delimiter at the end of the string is optional. For example, tokenize() can be useful for reading individual lines from a text file, parsing tab or comma-separated data and splitting sentences into separate words.", "tokenize(\"First line\\nSecond line\\nLast line\\n\", >append(@lines, $0))\ntokenize('Eeny, meeny, miny, moe', >print(trim($0)), ',')\ntokenize('Data is not information, information is not knowledge, knowledge is not understanding, understanding is not!wisdom.', >if ($0 !== '') append(@words, $0), \" \\t\\r\\n,.!?&\\\"/;:=-()[]{}\")", "parse, trim, wildmatch");
describe('#strings', 'trim',		"'trimmed' = trim('string', ['leading' = \" \\t\\r\\n\"], ['trailing' = \" \\t\\r\\n\"])", "Trims the source 'string' from leading and / or trailing characters of choice. The default characters are any white space character. If you pass void to 'leading' or 'trailing' you can prevent the routine from trimming leading respectively trailing characters.", "trim(\"  extractme\\t\") === 'extractme'\ntrim(\"\\n    keep trailing spaces  \\n\", , void) === \"keep trailing spaces  \\n\"\ntrim(\"--- keep me ---\", '-', '-') === ' keep me '", "replace");
describe('#strings', 'unescape',	"'raw' = unescape('escaped')",						"Converts a string that is either enclosed in single (') or double (\") quotes. If the single (') quote is used, the string between the quotes is simply extracted \"as is\" with the exception of pairs of apostrophes ('') that are used to represent single apostrophes. If the string is enclosed in double quotes (\") it can use a subset of the C-style escape sequences. The supported sequences are: \\\\ \\\" \\' \\a \\b \\f \\n \\r \\t \\v \\xHH \\uHHHH \\<decimal>. If the string cannot be successfully converted an exception will be thrown.\n\nInverse: escape('raw').", "unescape(\"'trivial'\") == 'trivial'\nunescape('\"it''s got an apostrophe\"') == \"it's got an apostrophe\"\nunescape(escape(\"first line\\n\\xe2\\x00tail\")) == \"first line\\n\\xe2\\x00tail\"", 'escape, evaluate');
describe('#strings', 'upper',		"'uppercase' = upper('string')",					"Translates 'string' character by character to upper case. Notice that the standard implementation only works with characters having ASCII values between 32 and 126 inclusively.", "upper('aBcD') === 'ABCD'", 'lower');
describe('#strings', 'wildfind',	"+offset|void = wildfind('source', 'pattern', +from, +to, @captureQueue)",	"This is a low-level subroutine used by wildmatch() to match the full or partial 'pattern' in 'source' between the offsets +from and +to (inclusively). The returned value is either the offset where the first match was found or void if no match was found. @captureQueue should be initialized with resetQueue() prior to calling this routine. \"Captured ranges\" will be pushed to this \"queue\" as pairs of offsets and lengths. Pop these with popFront().\n\nSee the documentation for wildmatch() for a description of the pattern syntax and more.", "wildfind('abcdef', 'def', 0, 6, @c) == 3\nwildfind('abcdef', '[def]', 0, 6, @c) == 5\nwildfind('abcdef', '[def]*', 0, 6, @c) == 3\nwildfind('abcdef', '[^def]', 4, 6, @c) == void", "popFront, resetQueue, wildmatch");
describe('#strings', 'wildmatch',	"?matched = wildmatch('source', 'pattern', [@captures, ...])",		"Tries to match the 'source' string with 'pattern' (which may contain \"wild card\" patterns). true is returned if there is a match. You may also capture substrings from 'source' into the @captures variables. The pattern syntax is inspired by the \"glob\" standard (i.e. the syntax used for matching file names in most operating systems). However, a lot of additional features have been added, making the complexity of the syntax somewhere between glob and \"regular expressions\". It is easiest to describe with some examples:\n\n*           any string (including the empty string)\n?           a single arbitrary character\n~           an optional arbitrary character\nsmurf       the string 'smurf' exactly (comparison is always case sensitive)\n*smurf*     'smurf' anywhere in the source\n????~~~~    between four and eight arbitrary characters\n[a-zA-Z]    any single lower or upper case letter between 'a' and 'z'\n[^a-zA-Z]   any single character that is not between 'a' and 'z' (case insensitive)\n[*]         matches a single asterisk\n[^]         a single ^ character only\n[[]]        [ or ]\n[]^]        ] or ^\n[x-]        x or -\n[0-9]*      a string consisting of zero or more digits\n[0-9]????   exactly four digits\n[0-9]?*     a string consisting of one or more digits\n[0-9]??~~   between two and four digits\n[0-9]?[]*   a single digit and then an arbitrary string\n{*}smurf    captures everything before 'smurf' into the next @captures variable\n\nNotice that the * and ~ quantifiers are always non-greedy (i.e. they match as little as they possibly can). (This is a limitation of the current implementation, there are plans to let double ** mark a greedy match instead.) If you want to perform case insensitive matching for the entire pattern, use lower() or upper() on the source string. There is also a low-level routine called wildfind() if you need greater control over the matching.", "wildmatch('readme.txt', '*.txt')\nwildmatch('myfile.with.extension', '{[^<>:\"/\\|?*]*}.{[^<>:\"/\\|?*.]*}', @filename, @extension) && filename === 'myfile.with' && extension === 'extension'\nwildmatch(LF # \"skip line\\n\\n\\tmatch : me \\nthis:is the rest\" # LF, \"*\\n[ \\t]*{[^ \\t]?*}[ \\t]*:*{[^ \\t]?[]*}[ \\t]*\\n{*}\", @key, @value, @theRest) && key === 'match' && value === 'me'", "lower, tokenize, upper, wildfind");

describe('#utils', 'args',		'args([@variables, ...])',							'Assigns arguments to named variables. Pass a reference to a local variable for each argument your function expects. The caller of your function must pass exactly this number of arguments or an exception will be thrown.', 'args(@x, @y)', 'vargs');
describe('#utils', 'classify',	"'class' = classify(<value>)",						"Examines <value> and tries to determine what \"value class\" it belongs to:\n\n- 'void' (empty string)\n- 'boolean' ('true' or 'false')\n- 'number' (starts with a digit, '+' or '-' and is convertible to a number)\n- 'reference' (starting with ':' and containing at least one more ':')\n- 'function' (enclosed in '{ }' or begins with '>:' and contains one more ':')\n- 'native' (enclosed in '< >')\n- 'string' (if no other match)\n\nNotice that since there are no strict value types in PikaScript the result of this function should be considered a \"hint\" only of what type <value> is. For example, there is no guarantee that a value classified as a 'function' actually contains executable code.", "classify(void) === 'void'\nclassify('false') === 'boolean'\nclassify(123.456) === 'number'\nclassify(@localvar) === 'reference'\nclassify(function { }) === 'function'\nclassify(>lambda) === 'function'\nclassify('<print>') === 'native'\nclassify('tumbleweed') === 'string'");
describe('#utils', 'coalesce',	'<value> = coalesce(<values>|@variables, ...)',		"Returns the first <value> in the argument list that is non-void, or the contents of the first @variables that exists (whichever comes first). void is returned if everything else fails.\n\nA word of warning here, if a string value happens to look like a reference (e.g. '::') it will be interpreted as a such which may yield unexpected results. E.g. coalesce('::uhuh', 'oops') will not return 'oops' if a global variable named 'uhuh' exists.", "coalesce(@gimmeVoidIfNotDefined)\ncoalesce(maybeVoid, perhapsThisAintVoid, 'nowIAmDefinitelyNotVoid')", 'defaults, exists');
describe('#utils', 'compare',	'<diff> = compare(<a>, <b>)',						'Returns 0 if <a> equals <b>, -1 if <a> is less than <b> and 1 if <a> is greater than <b>. This function is useful in sorting algorithms.', "compare('abc', 'def') < 0\ncompare('def', 'abc') > 0\ncompare('abc', 'abc') == 0", 'qsort, swap');
describe('#utils', 'defaults',	'defaults([@variable, <value>, ...])',				'Assigns each <value> to each @variable if it does not exist. This function is useful for initializing global variables and optional function arguments.', "defaults(@name, 'Smith')\ndefaults(@first, 'a', @last, 'z')", 'coalesce');
describe('#utils', 'delete',	"?deleted = delete(@variable)",						"Deletes the variable referenced to by @variable and returns true if the variable existed and was successfully deleted.\n\nNotice that this function can only delete a single variable at a time. This means only a single \"element\" in a \"container\" as well. Use prune() to delete an entire \"plain old data\" container and destruct() to delete an object.", "delete(@begone)\ndelete(@hurray[1972])", 'destruct, exists, prune');
describe('#utils', 'evaluate',	"<result> = evaluate('code', [@frame])",			"Evaluates 'code' and returns the result. You can decide which frame should execute the code by supplying a reference in @frame. Without @frame, code is executed in its own frame just as if you would call a function. Only the \"frame identifier\" of @frame is used.\n\nYou may for example pass @$ to execute in the current frame, or @^$ to execute in the caller's frame (the '$' is there to reference the correct frame even if it is a lambda expression), or @:: to execute in the global frame.", "evaluate('3 + 3') == 6\nevaluate('x = random(1)', @x)", 'bake, invoke, parse, run, sourceFor, toSource');
describe('#utils', 'exists',	"?found = exists(@variable)",						"Returns true if the variable referenced to by @variable is defined. Notice that this function does not \"fall back\" to the global frame if a local variable does not exist. Therefore you should always prefix the variable name with '::' if you want to check for the existance of a global variable or function.", "exists(@::aglobal)\nexists(@users['magnus lidstrom'])", 'coalesce, defaults, delete');
describe('#utils', 'include',	"include('filePath')",								"Runs a PikaScript source file as with run() but only if 'filePath' has not been \"included\" before. The function determines this by checking the existance of a global ::included[filePath]. It defines this global after completing execution the first time. (run() does not define or use this global.) Use include() with source files that defines library functions and constants, e.g. 'stdlib.pika'.", "include('stdlib.pika')", 'run');
describe('#utils', 'input',		"'answer' = input('question')",						"Prints 'question' and returns a line read from the standard input stream (excluding any terminating line feed characters). May throw 'Unexpected end of input file' or 'Input file error'.", "name = input(\"What's your name? \")", 'print');
describe('#utils', 'invoke',	"<result> = invoke(['callee'], [>body], @args, [+offset = 0], [+count])",	"Calls 'callee' (or >body) with the argument list @args. The difference between using 'callee' or >body is that the former should be a string with a function name, while the latter should be an actual function body. If both arguments are present, >body will be executed, but the called function's $callee variable will be set to 'callee'. For debugging purposes it is recommended that you use the 'callee' argument.\n\n+offset can be used to adjust the element index for the first argument. +count is the number of arguments. If it is omitted, [@args].n is used to determine the count.\n\nMay throw 'Too few array elements'.", "invoke('max', , @values)\ninvoke('(callback)', $0, @$, 1, 4)", "evaluate, invokeMethod, run");
describe('#utils', 'load',		"'contents' = load('filePath')",					"Loads a file from disk and returns it as a string. The standard implementation uses the file I/O of the standard C++ library, which takes care of line ending conversion etc. It can normally only handle ASCII text files. May throw 'Cannot open file for reading: {filePath}' or 'Error reading from file: {filePath}'.", "data = load('myfolder/myfile.txt')", 'save');
describe('#utils', 'max',		'<m> = max(<x>, <y>, [<z>, ...])',					'Returns the largest value of all the arguments.', "max(5, 3, 7, 1, 4) == 7\nmax('Sleepy', 'Grumpy', 'Happy', 'Bashful', 'Dopey', 'Sneezy', 'Doc') === 'Sneezy'\nmax('Zero', '10', '5') === 'Zero'", 'min');
describe('#utils', 'min',		'<m> = min(<x>, <y>, [<z>, ...])',					'Returns the smallest value of all the arguments.', "min(5, 3, 7, 1, 4) == 1\nmin('Sleepy', 'Grumpy', 'Happy', 'Bashful', 'Dopey', 'Sneezy', 'Doc') === 'Bashful'\nmin('Zero', '10', '5') === '5'", 'max');
describe('#utils', 'parse',		"+offset = parse('code', ?literal)",				"Parses 'code' (without executing it) and returns the number of characters that was successfully parsed. 'code' is expected to start with a PikaScript expression or in case ?literal is true, a single literal (e.g. a number). If ?literal is false, the parsing ends when a semicolon or any unknown or unexpected character is encountered (including unbalanced parentheses etc). The resulting expression needs to be syntactically correct or an exception will be thrown.\n\nYou can use this function to extract PikaScript code (or constants) inlined in other text. You may then evaluate the result with evaluate() and continue processing after the extracted code. Pass true for ?literal in case you want to evaluate a single constant and prevent function calls, assignments etc to be performed. Valid literals are: 'void', 'false', 'true', numbers (incl. hex numbers and 'infinity' of any sign), escaped strings (with single or double quotes), natives (enclosed in '< >'), function or lambda definitions.", "parse('3+3', false) == 3\nparse('3+3', true) == 1\nparse('1 + 2 * 3 ; stop at semicolon', false) == 10\nparse(' /* leading comment */ code_here /* skip */ /* trailing */ /* comments */ but stop here', false) == 74\nparse('stop after space after stop', false) == 5\nparse('x + x * 3 ) * 7 /* stop at unbalanced ) */', false) == 10\nparse('+infinity', true) == 9\nparse('\"stop after the \\\", but before\" this text', true) == 31", 'escape, evaluate, run, tokenize');
describe('#utils', 'print',		"print('textLine')",								"Prints 'textLine' to the standard output, appending a newline character. (Sorry, but standard PikaScript provides no means for outputting text without the newline.)", "print('Hello world!')", 'input');
describe('#utils', 'run',		"<result> = run('filePath', [<args>, ...])",		"Loads and executes a PikaScript source file. The code is executed in the \"closure\" of the global frame, which means that variable assignments etc work on globals. The code can still use temporary local variables with the $ prefix. The passed <args> are available in $1 and up. $0 will be 'filePath'. The returned value is the final result value of the executed code, just as it would be for a function call. The first line of the source code file may be a \"Unix shebang\" (in which case it is simply ignored). Use include() if you wish to avoid a file from running more than once.", "run('chess.pika')\nhtmlCode = run('makeHTML.pika', 'Make This Text HTML')", 'evaluate, include, invoke');
describe('#utils', 'save',		"save('filePath', 'contents')",						"Saves 'contents' to a file (replacing any existing file). The standard implementation uses the file I/O of the standard C++ library, which takes care of line ending conversion etc. It can normally only handle ASCII text files. May throw 'Cannot open file for writing: {filePath}' or 'Error writing to file: {filePath}'.", "save('myfolder/myfile.txt', 'No, sir, away! A papaya war is on!')", 'load');
describe('#utils', 'sourceFor', "'code' = sourceFor(@variable|@container, ['prefix' = ''])",		"*** WARNING, THIS FUNCTION IS SLIGHTLY BROKEN AND MAY BE REMOVED. USE AT OWN RISK! ***\n\nCreates source code for recalling the definition of @variable or @container (with all its sub-elements). The created code can be used with evaluate() to recall the definition in any given frame. For example: evaluate('code', @$) would recreate variables in the current local frame and evaluate('code', @::) would create them in the global frame.\n\nEach output line will be prefixed with 'prefix'.", "save('AllGlobals.pika', sourceFor(@::))\nevaluate(sourceFor(@wildmatch)) == wildmatch\nevaluate(sourceFor(@::globalToLocalPlease), @$)\nprint(sourceFor(@myFunction, \"\\t\\t\"))", "dump, evaluate, toSource");
describe('#utils', 'system',	"+exitCode = system('command')",					"Tries to execute 'command' through the operating system's command interpreter. +exitCode is the return value from the command interpreter (a value of 0 usually means no error). May throw 'Error executing system command: {command}'.");
describe('#utils', 'swap',		"swap(@a, @b)",										"Swaps the contents of the variables referenced to by @a and @b. This function is useful in sorting algorithms.", "swap(@master, @slave)", 'compare, qsort');
describe('#utils', 'time',		"+secs = time()",									"Returns the system clock as \"epoch time\", i.e. the number of seconds that has passed since a specific reference date (usually January 1 1970).", "elapsed = time() - lastcheck");
describe('#utils', 'throw',		"throw('error')",									"Throws an exception. 'error' should describe the error in human readable form. Use try() to catch errors. (PikaScript exceptions are standard C++ exceptions. It is up to the host application how uncaught exceptions are handled.)", "throw('Does not compute')", 'try');
describe('#utils', 'toSource',	"'literal' = toSource(<value>)",					"*** WARNING, THIS FUNCTION IS SLIGHTLY BROKEN AND MAY BE REMOVED. USE AT OWN RISK! ***\n\nReturns the source code literal for <value>. I.e. 'literal' is formatted so that calling evaluate('literal') would bring back the original <value>.", "toSource('string theory') === \"'string theory'\"\ntoSource('') === 'void'\ntoSource('{ /* get funcy */ }') === 'function { /* get funcy */ }'\nevaluate(toSource(@reffy)) == @reffy\nevaluate(toSource(>lambchop), @$) == (>lambchop)", "dump, evaluate, sourceFor");
describe('#utils', 'try',		"'exception' = try(>doThis)",						"Executes >doThis, catching any thrown exceptions and returning the error string of the exception. If no exception was caught, void is returned. The returned value of >doThis is discarded. (Although PikaScript exceptions are standard C++ exceptions you can only catch PikaScript errors with this function.)", "error = try(>data = load(file))\ntry(>1+1) === void\ntry(>1+'a') === \"Invalid number: 'a'\"\ntry(>throw('catchme')) === 'catchme'", 'throw');
describe('#utils', 'vargs',		'vargs([@arguments, ...], , [@optionals, ...])',	'As args() but you may define arguments that are optional. The caller of your function must pass all required arguments or an exception will be thrown. An exception will also be thrown if the caller passes more optional arguments than present in vargs(). An easy way to assign default values for optional arguments is with the default() function. Alternatively you may want to use coalesce().', 'vargs(@required1, @required2, , @optional1, @optional2)', 'args, coalesce, defaults');
describe('#utils', 'VERSION',	"'v' = VERSION",									'VERSION is a global variable containing the PikaScript engine version as a human readable text string.');
