realToComplex = function {
	args(@a);
	for (i = [a].n - 1; i >= 0; --i) {
		[a][i * 2 + 0] = [a][i];
		[a][i * 2 + 1] = 0;
	};
	[a].n <<= 1;
};

complexToReal = function {
	args(@a);
	for (i = 0; i < [a].n >> 1; ++i) {
		[a][i] = [a][i * 2 + 0];
	};
	[a].n >>= 1;
};

// on complex signal
powerSpectra = function {
	args(@a, @b);
	n = [b].n = [a].n \ 4;
	for (i = 0; i < n; ++i) [b][i] = sqrt(sqr([a][i * 2 + 0]) + sqr([a][i * 2 + 1])) / n;
};

fft = function {
	args(@data);
	
    // reverse-binary reindexing
    n = [data].n;
	nn = n >> 1;
    j = 1;
    for (i = 1; i < n; i += 2) {
        if (j > i) {
            swap(@[data][j - 1], @[data][i - 1]);
            swap(@[data][j], @[data][i]);
        };
        m = nn;
        for (; m >= 2 && j > m; ) {
            j -= m;
            m >>= 1;
        };
        j += m;
    };
 
    // here begins the Danielson-Lanczos section
    for (mmax = 2; mmax < n; mmax <<= 1) {
        theta = -2 * PI / mmax;
        wtemp = sin(0.5 * theta);
        wpr = -2.0 * wtemp * wtemp;
        wpi = sin(theta);
        wr = 1.0;
        wi = 0.0;
        istep = mmax << 1;
        for (m = 0; m < mmax; m += 2) {
            for (i = m; i < n; i += istep) {
                j = i + mmax;
                tempr = wr * [data][j] - wi * [data][j + 1];
                tempi = wr * [data][j + 1] + wi * [data][j];
                [data][j] = [data][i] - tempr;
                [data][j + 1] = [data][i + 1] - tempi;
                [data][i] += tempr;
                [data][i + 1] += tempi;
            };
            wtemp = wr;
            wr += wr * wpr - wi * wpi;
            wi += wi * wpr + wtemp * wpi;
        }
    }
}

// test: generate(@a, 257, >cos(4*PI*$0),0,1); a.n=256; realToComplex(@a); plot(@a);fft(@a);powerSpectra(@a, @b);plot(@b)
// generate(@a, 1025, function { x = $0; if (x < 1) w(x) * 256/8 else 0 }, 0, 512/8); a.n=1024; plot(w,0,1); realToComplex(@a); fft(@a);powerSpectra(@a, @b);transform(@b, toDecibel);plot(@b,,,-140,0,,,80)
