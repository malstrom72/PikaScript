<h2><a name="Symbiosis">Symbiosis</a></h2>
<table>
<tr>
<th>
FIX
</th><td>
add something about adding frameworks
</td>
</tr>
<tr>
<th>
IDEA
</th><td>
add some super-short instructions to .cpp file
</td>
</tr>
<tr>
<th>
FIX
</th><td>
IMPORTANT : If you are building an Intel or "universal binary" version of Symbiosis (or any AU), you need to either define i386_YES and/or ppc_YES (define both to build a universal binary). Alternatively, to make this selection depend on the architectures settings in XCode, add the following definition for OTHER_REZFLAGS to the project configuration: -d ppc_$ppc -d i386_$i386
</td>
</tr>
<tr>
<th>
TODO
</th><td>
step-by-step should really be step-by-step, it is a bit confusing right now
</td>
</tr>
<tr>
<th>
FIX
</th><td>
when doing Cockatoo I needed to add a "build resourcemanager" phase for the .r file, is that always necessary?
</td>
</tr>
<tr>
<th>
TODO
</th><td>
suggest copy scripts
</td>
</tr>
<tr>
<th>
TODO
</th><td>
symbols hidden by default makes au not functioning although vst functions, write something? fix something?
</td>
</tr>
</table>
<h3><a name="What is Symbiosis?">What is Symbiosis?</a></h3>
<p>
Symbiosis is a developer tool for adapting Mac OS X VST plug-ins to the AudioUnit (AU) standard. The project is released free with source code. It essentially consists of a single C++ file that you compile into your VST project to make the plug-in compatible with the AudioUnit protocol. Optionally, you may choose to use a pre-built "wrapper plug-in" for adapting your existing VST plug-in to the AU standard without even having to recompile any source code.
</p>
<h3><a name="How does it work?">How does it work?</a></h3>
<p>
Although the VST and AudioUnit SDKs differ greatly in implementation, the purpose and functions of the two standards are virtually identical. Both protocols provide means for querying plug-in info and capabilities, processing floating-point audio, reading and writing automation parameters, serializing the plug-in state for total recall and managing GUI interaction.
</p>
<p>
The close affinity of the two standards makes it possible to create a "wrapper" that works on "binary level", meaning that it translates messages to and from the AU host and VST plug-in in real-time.
</p>
<p>
The translation works transparently for perhaps 90% of the AudioUnit functionality. Where the AU and VST standards differ greatly or where the former offers valuable features not found in the latter, Symbiosis offer configuration files and optional code extensions that allow you to create feature-complete AudioUnits, true to the philosophies and principles of the architecture.
</p>
<h3><a name="Who is it for?">Who is it for?</a></h3>
<p>
This is a tool for developers. It was not designed to be used by end-users. The idea is that Symbiosis is packaged into the final product, either compiled into the product on source-code level (see ??? below) or as a "wrapper" that bridges to your VST.<br>	<br>Symbiosis will be of great interest to you if you already have a VST plug-in running under Mac OS X and you now wish to support the AudioUnit format. With Symbiosis, you will not need to learn and implement the AudioUnit interface by yourself. Although plenty of documentation and examples are available for learning the art of AudioUnit coding, it is far from trivial to understand all aspects and details of this fairly complex API; add to this the continuous work of supporting and maintaining the source code for two different plug-in interfaces and the advantage of using Symbiosis should be obvious.
</p>
<p>
The availability of Symbiosis may also make VST a good choice as a first plug-in format for the beginner Mac developer who one day plan to port his plug-in to the VST-dominant environment of Windows.
</p>
<h3><a name="What does it cost?">What does it cost?</a></h3>
<p>
This is the best part: nothing. I (Magnus Lidström) developed Symbiosis partly because I needed such a tool for own use, but also because I felt that all developers would benefit from a unified plug-in world with a single standard API. We will probably never be able to change the fact that certain hosts only work with certain plug-in formats, but at least, Symbiosis will make it feasible to support two of these formats with a minimal amount of overhead in code, work and continuous support.
</p>
<p>
My only request if you find this tool useful is that you spread the word, preferably by adding an acknowledgment in your product documentation, "about box" or any other promotional material. For example, "AudioUnit version implemented using Symbiosis from NuEdge Development."
</p>
<p>
My dear friends over at Bitplant have also designed a very stylish logo that I would be thrilled if you would like to use. 
</p>
<p>
??? Something about no guarantees, no support, as is etc... ???
</p>
<h3><a name="What are the prerequisites?">What are the prerequisites?</a></h3>
<p>
??? Something about familiarity with VST ???
</p>
<p>
The minimum requirement is that you have the Apple OS X development tools and the CoreAudio SDK installed. (Configuring Symbiosis for your product requires at least using the "Rez" tool in order to compile the required AU "component resources".)
</p>
<p>
If you wish to compile the Symbiosis "wrapper plug-in" project, you will need XCode 2.1 or later. The VST SDK from Steinberg is required as well, but due to licensing restrictions, the source files from this SDK are not included in this distribution but must be obtained from Steinberg and added to the project manually.
</p>
<p>
It is also advisable that you download the latest audio validation tool (auval) from Apple (??? Link ???). Some hosts will not load your AudioUnit if it does not pass the AU validation without errors. Although Symbiosis will do its best to make sure that your adapted VST passes validation, there is no guarantee that your VST code is 100% compatible without modification. (There are also a few tweakable configuration settings and vendor-specific VST extensions that may affect the outcome of the validation.)
</p>
<h3><a name="What are the major differences between VST and AU? ???">What are the major differences between VST and AU? ???</a></h3>

<ul>
<li>
VST bundle, AU component with component-resources (=different scanning)
</li>
<li>
AU GUI = carbon control / HIView, VST = Window
</li>
<li>
AU parameters have IDs, ranges, types and value strings for discrete params
</li>
<li>
AUPresets instead of FXB / FXP
</li>
<li>
No program "slots"
</li>
<li>
Factory presets read-only in memory
</li>
<li>
Conversion to and from arbitrary parameter values and strings
</li>
<li>
Silent buffer optimizations
</li>
<li>
Same plug-in, different number of inputs / outputs
</li>
</ul>
<h3><a name="Wrapping alternatives">Wrapping alternatives</a></h3>
<p>
So, you have a VST plug-in that you want to metamorphose into an AudioUnit. How do you begin? First, you need to decide how you wish to wrap your VST. There are four alternatives:
</p>

<ol>
<li>
Using the pre-built wrapper AU component and connecting it to the VST through an alias that you put inside the wrapper component bundle.
<br>

   
<br>

   The advantage of this solution is that the same physical binary is used for both the VST and AU version. This means that your plug-in will be smaller to download and will take up less space on the users disk once it has been installed. It also simplifies version handling as you will only need to build and update one single binary for both formats. The disadvantage is that the AU-version is not 100% self-contained and an end-user can break it if he / she uninstalls or throws away the VST. (Nevertheless, this approach may be the best choice during development even if you choose to wrap the final product using one of the other solutions.)
<br>

   
<br>
</li>
<li>
Using the pre-built wrapper AU component and putting a copy of your VST inside the wrapper component bundle.
<br>

   
<br>

   This approach is almost identical to alternative number 1 except that the VST bundle is physically duplicated inside the AU bundle. The advantage of choosing this solution is that the AU-version becomes self-contained. If your plug-in is small, this alternative should be preferred to alternative number 1, at least when you are packaging the final product.
<br>

   
<br>
</li>
<li>
Adding the Symbiosis C++ source code to your VST project.
<br>

   
<br>

   By simply adding the Symbiosis source code to your VST project (plus adding a component resource file and modifying your Info.plist-file), the compiled VST binary will be compatible with both the VST and the AU standards simultaneously. Ain't that amazing? However, you will still need separate physical copies of the bundle on disk since AU and VST hosts have different requirements on the location and extension of the plug-in. The advantages and disadvantages of choosing this solution are practically the same as for alternative number 2. The difference is that the Symbiosis wrapper gets compiled into the product binary (with the same build options etc as your own code). (To keep the versions in sync, you can add a final build step that copies the "unisex" plug-in to a .vst-file in Library/Audio/Plug-Ins/VST and to a .component-file in Library/Audio/Plug-Ins/Components.)
<br>

   
<br>
</li>
<li>
Creating a specific build target for the AudioUnit version.
<br>

   
<br>

   This alternative is identical to number 3, but instead of having a single "unisex" target you create specific targets for the VST and the AU versions and include the Symbiosis source code only to the AU target. The disadvantage is that the build-time practically doubles if you wish to build both formats. The only reason for choosing this alternative over number 3 is if you need to treat the AU version differently on source code level (for instance with preprocessor macros). I would recommend avoiding this solution though. Keeping the number of different binary versions down to a minimum is always good for build times, debugging, support and maintenance. If you need to treat the AU differently from the VST during run-time you can always check if the VST host is "Symbiosis" through the "getHostProductString" VST call.
<br>
</li>
</ol>
<h3><a name="Wrapping the VST step by step">Wrapping the VST step by step</a></h3>
<p>
Alright, you have now chosen one of the wrapping alternatives and want to proceed. What is the next step?
</p>
<p>
Naturally, if you have chosen wrapping alternative 1 or 2 (using the pre-built wrapper) the first step would be to duplicate one of the pre-built wrappers (called ???), rename it and add an alias to or duplicate your VST plug-in inside the bundle. This file (or alias) should be put under Contents/Resources/ in the wrapper bundle.
</p>
<p>
Use the "development" version of the pre-built wrapper during development, the "beta" version during beta testing and the "release" version for the release. The "development" and "beta" versions contain tracing and assertions that you can observe in the standard "console.log" (with the "Console" application). (Notice that standard assertion handling in C++ simply aborts the entire application. When this happens, always check "console.log" for the reason.)
</p>
<p>
If you have chosen one of the other two wrapping alternative (including the Symbiosis source in your project) you should start by adding the following files to your project: ???
</p>
<p>
As described earlier AudioUnits are based on the component API (as used by QuickTime) and components are identified by the operating system using classic Mac resources. Therefore, the next step is to create and compile these resources for your AU by editing the sample "rez"-file that is included in the distribution ("Symbiosis.r"). Open up a copy of this file and modify it according to the instructions in the comments.
</p>
<p>
If you have chosen wrapping alternative 1 or 2 you need to manually compile "Symbiosis.r" into "Symbiosis.rsrc" by running the "Rez" tool. There is a script included in the distribution called ??? that helps you with this step. First put your modified "Symbiosis.r" file (don't rename it!) into Contents/Resources/ of your AU-wrapper bundle, open up a shell prompt, go to the mentioned directory (cd ???) and run the script (./???). Look for Symbiosis.rsrc. Found it? Done. (And don't rename Symbiosis.rsrc!)
</p>
<p>
(If you are using wrapping alternative 3 or 4 you simply add the .r-file to your project and it will be compiled into the end-product automatically.)
</p>
<p>
Next step is to configure the OS X Info.plist file and add a few Symbiosis-specific configuration options. If you are using wrapping alternative 1 or 2 this file is located inside your wrapper bundle under <i>Contents</i>. If you are using alternative 3 or 4 you should modify the Info.plist that you already have for your project. (Again, you can find a sample Info.plist-file in the distribution called ??? with comments on how to configure this file.)
</p>
<h3><a name="Running your AU for the first time">Running your AU for the first time</a></h3>
<p>
If you have installed "auval" you can check that your AU has been registered properly by running "auval -a" (from a shell command-line) and look for your unique AU signature. If not, you may need to restart the computer for the OS to recognize the new AU. If this still fails, something has seriously gone wrong with your wrapping. Start over from square 1. :-)
</p>
<p>
Now let us fire up the engines and take your AU for a spin. A good idea for the first tour would be to validate it with "auval -v".
</p>
<p>
Important! When you run the AU for the first time, the wrapper automatically creates a few configuration files under <i>Contents/Resources</i> as well as .aupresets for the default VST program bank.
</p>
<p>
??? about these files ???
</p>
<h3><a name="Advanced porting options ???">Advanced porting options ???</a></h3>
<p>
??? details of parameters.txt<br>??? vendor-specific extensions
</p>
<h3><a name="Requirements on the VST implementation">Requirements on the VST implementation</a></h3>
<p>
??? User pane control ???<br>??? ProcessReplacing ???<br>??? what else, look up ???
</p>
<h3><a name="VST and AU messages implementation chart ???">VST and AU messages implementation chart ???</a></h3>
<h3><a name="References and links ???">References and links ???</a></h3>
<h3><a name="Trademarks and stuff ???">Trademarks and stuff ???</a></h3>
