include('debug.pika');
qsortTest = function {
	stack.n = 1;
	stack[0].low = $0;
	stack[0].high = $1;
	for (; stack.n > 0; ) {
		::maxDepth = max(::maxDepth, stack.n);
		stack.n--;
		outerLow = stack[stack.n].low;
		outerHigh = stack[stack.n].high;
		for (; outerLow < outerHigh; ) {
			for ({ $l = outerLow; $h = outerHigh; $m = ($l + $h) \ 2 }; $l < $h; ) {
				for (; $l <= $h && $2($l, $m) <= 0 && $2($h, $m) >= 0; { ++$l; --$h });
				for (; $l <= $h && $2($h, $m) > 0; --$h);
				for (; $l <= $h && $2($l, $m) < 0; ++$l);
				if ($m == $l || $m == $h) $m ^= $h ^ $l;
				if ($l < $h) $3($l, $h);
			};
			map(@stack[stack.n++], 'low', outerLow, 'high', $l - 1);
			outerLow = $l;
		};
	};
};
sortTest = function { args(@a); ::maxDepth = 0; qsortTest(0, [a].n - 1, >compare([a][$0], [a][$1]), >swap(@[a][$0], @[a][$1]), 0); ( a ) };

prune(@a); for (i = 0; i < 10000; ++i) append(@a, i);
clock(>sortTest(@a));
for (i = 1; i < 10000; ++i) assert(> a[i] >= a[i - 1]);
print("ascending ok (depth " # maxDepth # ")");

prune(@a); for (i = 0; i < 10000; ++i) append(@a, 10000-i);
clock(>sortTest(@a));
for (i = 1; i < 10000; ++i) assert(> a[i] >= a[i - 1]);
print("descending ok (depth " # maxDepth # ")");

prune(@a); for (i = 0; i < 100000; ++i) append(@a, random(2));
clock(>sortTest(@a));
for (i = 1; i < 100000; ++i) assert(> a[i] >= a[i - 1]);
print("random float ok (depth " # maxDepth # ")");

prune(@a); for (i = 0; i < 100000; ++i) append(@a, trunc(random(10)));
clock(>sortTest(@a));
for (i = 1; i < 100000; ++i) assert(> a[i] >= a[i - 1]);
print("random int ok (depth " # maxDepth # ")");

prune(@a); for (i = 0; i < 99999; ++i) append(@a, trunc(random(10)));
clock(>sortTest(@a));
for (i = 1; i < 99999; ++i) assert(> a[i] >= a[i - 1]);
print("random int odd length ok (depth " # maxDepth # ")");
