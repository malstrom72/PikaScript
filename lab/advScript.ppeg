{
	$$parser.replace = >{
		map(@$$parser.replaceList[$$parser.replaceList.n], 'from', $0, 'to', $1, 'with', $2);
		++$$parser.replaceList.n;
	};
}

root 				<-																{ $$ = ''; $$parser.replaceList.n = 0; $$.isGlobal = false }
						_ (ALWAYS (_ ":")? __										{ $$.isGlobal = true }
						)? commandAlso _ ('.' _)? !.								{
																						$s = $$s;
																						$lf = +infinity;
																						$a = @$$parser.replaceList;
																						for ($i = [$a].n - 1; $i >= 0; --$i) {
																							$e = @[$a][$i];
																							$f = [$e].from;
																							$t = [$e].to;
																							assert($t <= $lf);
																							$lf = $f;
																							$s = $s{:$f} # [$e].with # $s{$t:};
																						};
																						$$.updatedSource = $s;
																					}

commandAlso			<-	commandAnd (((__ / _ ',' _) ALSO __ / _ '.' _ / [ \t]* [\r\n]+ _ ) commandAnd)*

commandAnd			<-	command ((__ AND_THEN __ / _ ',' _ (AND_THEN __)?) command)*

command				<-	c:(goto / write / change / iff / describe / do)				{ $$ = (if ($$ != '') $$ # ';') # $c }

goto				<-	GO __ (TO __ ((THE __)? LOCATION __)?)? s:stringNoAndAlso	{
																						$number = [::compiler].resolveLocation($s, @$updatedName);
																						if (lower($s) != lower($updatedName)) $$parser.replace($s.from, $s.to, quote($updatedName));
																						$$ = bake("[::executor].goto({$number})");
																					}

write				<-	WRITE __ s:stringWithPeriods					     		{ $$ = bake("[::executor].write({escape($s)})"); }

change				<-	(CHANGE __ (THE __)? v:stringNoTo __ TO
						/ MAKE __ (THE __)? v:stringOneWord
						/ NOTE __ (THAT __)? (THE __)? v:stringNoIs __ IS
						)															{ $$.v = lower($v); $$ = ''; }
						__ randomStrings											{ $$ #= ')'; }

randomStrings		<-	oneRandomString ((_ ',' _ / __ OR __) oneRandomString)*

oneRandomString		<-	s:stringNoAndAlsoOr											{
																						$s = lower($s);
																						[::compiler].resolveVar($$.v, $s, @$updatedVar, @$updatedState);
																						if ($updatedVar != $$.v) $$parser.replace($$.v.from, $$.v.to, quote($updatedVar));
																						if ($updatedState != $s) $$parser.replace($s.from, $s.to, quote($updatedState));
																						if ($$ === '') $$ = bake("[::executor].update({escape($updatedVar)}");
																						$$ #= bake(", {escape($updatedState)}");
																					}

describe			<-	DESCRIBE (__ (THE __)? LOCATION)?							{ $$ = "[::executor].describe()" }

iff					<-	IF __ 														{ $o = bake("if(") }
						comparison													{ $o #= $$ }
						(
							op=((AND / BUT)											{ $o #= '&&' }
							/ OR													{ $o #= '||' }
							) __ (IF __)? comparison								{ $o #= $$ }
						)*
						(THEN __)? 													{ $o #= "){"; $$=""; }
						commandAnd													{ $o #= $$ # '}'; $$=""; }
						(__ OTHERWISE __ commandAnd									{ $o #= "else{" # $$ # "}" }
						)?															{ $$ = $o }

comparison			<-	(THE __)? v:stringNoIsNot __
							(ISNOT													{ $eq = '!==' }
							/ IS													{ $eq = '===' }
							) __
						s:stringNoAndOrThenEtc										{
																						$v = lower($v);
																						$s = lower($s);
																						[::compiler].resolveVar($v, $s, @$updatedVar, @$updatedState);
																						if ($updatedVar != $v) $$parser.replace($v.from, $v.to, quote($updatedVar));
																						if ($updatedState != $s) $$parser.replace($s.from, $s.to, quote($updatedState));
																						$$ = bake("::vars[{escape($updatedVar)}]{$eq}{escape($updatedState)}");
																					}
						((__ OR __ / _ ',' _ (OR __ / !andOrThenEtc))
							s:stringNoIsAndOrEtc !(__ (ISNOT / IS))					{
																						if ($${0} !== '(') $$ = '(' # $$;
																						$s = lower($s);
																						[::compiler].resolveVar($v, $s, @$updatedVar, @$updatedState);
																						if ($updatedState != $s) $$parser.replace($s.from, $s.to, quote($updatedState));
																						$$ #= bake("{if ($eq === '===') '||' else '&&'}::vars[{escape($updatedVar)}]{$eq}{escape($updatedState)}");
																					}
						)*															{
																						if ($${0} === '(') $$ #= ')';
																					}
						(_ ',' _ / __)

do					<-	(SAME_AS __)? s:stringNoAndAlso								{
																						$s = lower($s);
																						$reaction = [::compiler].resolveReaction($s);
																						if (lower($reaction) != $s) $$parser.replace($s.from, $s.to, quote($reaction));
																						$$ = bake("[::executor].do({escape($reaction)})");
																					}

stringOneWord		<-	(															{ $$.from = $$i }
						quotedString
						/															{ $$ = '' } 
						word														{ $$ = chop($$, 1) }
						)															{ $$.to = $$i }

stringNoTo			<-	(															{ $$.from = $$i }
						quotedString
						/															{ $$ = '' } 
						(!(_ TO __) word)+											{ $$ = chop($$, 1) }
						)															{ $$.to = $$i }

stringNoIs			<-	(															{ $$.from = $$i }
						quotedString
						/															{ $$ = '' } 
						(!(_ IS __) word)+											{ $$ = chop($$, 1) }
						)															{ $$.to = $$i }

stringNoIsNot		<-	(															{ $$.from = $$i }
						quotedString
						/															{ $$ = '' } 
						(!(_ (ISNOT / IS) __) word)+								{ $$ = chop($$, 1) }
						)															{ $$.to = $$i }

stringNoAndAlso		<-	(															{ $$.from = $$i }
						quotedString
						/															{ $$ = '' } 
						(!(_ (AND / OTHERWISE / ALSO) __) word)+					{ $$ = chop($$, 1) }
						)															{ $$.to = $$i }

stringNoAndAlsoOr	<-	(															{ $$.from = $$i }
						quotedString
						/															{ $$ = '' } 
						(!(_ (AND / OTHERWISE / ALSO / OR) __) word)+				{ $$ = chop($$, 1) }
						)															{ $$.to = $$i }

stringWithPeriods	<-	(															{ $$.from = $$i }
						quotedString
						/															{ $$ = '' } 
						(!(_ (AND / OTHERWISE / ALSO) __) wordWithPeriods)+			{ $$ = chop($$, 1) }
						)															{ $$.to = $$i }

stringNoAndOrThenEtc <-	(															{ $$.from = $$i }
						quotedString
						/															{ $$ = '' } 
						(!(_ andOrThenEtc __) word)+								{ $$ = chop($$, 1) }
						)															{ $$.to = $$i }

stringNoIsAndOrEtc <-	(															{ $$.from = $$i }
						quotedString
						/															{ $$ = '' } 
						(!(_ (ISNOT / IS / andOrThenEtc) __) word)+					{ $$ = chop($$, 1) }
						)															{ $$.to = $$i }

andOrThenEtc 		<-  AND / BUT / OR / THEN / GO / WRITE / CHANGE
						/ MAKE / NOTE / SAME_AS / DESCRIBE

escapeCode			<-	"\\" ( ["'\\/bfnrt] / 'u' HEX HEX HEX HEX )

escapeChar			<-	[\\/bfnrt]

quotedString		<-	$$=(('"' ( !["\\\0-\37] . / escapeCode )* '"')
						/ ("'" ( !['\\\0-\37] . / escapeCode )* "'"))				{ $$ = unescape($$) }

wordWithPeriods		<-	_ w=(![ \t\r\n] .)+											{ $$ #= $w # ' ' }

word				<-	_ w=(![ \t\r\n.,;] .)+										{ $$ #= $w # ' ' }

_					<-	[ \t\r\n]*

__					<-	[ \t\r\n]+

ALWAYS				<- "always" / "alltid" / "Always" / "Alltid"
GO					<- "go" / "gå" / "Go" / "Gå"
TO					<- "to" / "till"
ALSO				<- "also" / "dessutom" / "samt" / "Also" / "Dessutom" / "Samt"
AND_THEN			<- "and" (__ "then")? / "then" / "och" (__ "sen")? / "sen"
AND    				<- "and" / "och"
BUT    				<- "but" / "men"
OR					<- "or" / "eller"
WRITE				<- "write" / "skriv" / "Write" / "Skriv"
CHANGE				<- "change" / "set" / "ändra" / "sätt" / "Change" / "Set" / "Ändra" / "Sätt"
SAME_AS				<- ((THE __)? ("same" / "Same") __ "as") / (("samma" / "Samma") __ "som")
THE					<- "the"
MAKE				<- "make" / "gör" / "Make" / "Gör"
DESCRIBE			<- "describe" / "beskriv" / "Describe" / "Beskriv"
LOCATION			<- "location" / "platsen" / "plats"
IF					<- "if" / "om" / "If" / "Om"
THEN				<- "then" / "så"
OTHERWISE			<- "otherwise" / ("annars" (__ "så")?)
ISNOT				<- ("is" / "are") (__ "not" / "n't") / "inte" __ "är"
IS					<- "is" / "are" / "är"
NOTE				<- "notera" / "note" / "Notera" / "Note"
THAT				<- "that" / "att"
