/**
	Schema syntax reference

    ( )             : group
	[ ] 			: optional
	| 				: alternatives
	< > 			: use rule
	< > = 			: define rule
	<- 				: define peg
    ' '             : literal text
	" " 			: literal string
	* 				: any (unquoted) text
	*peg 			: any text validated by peg
	% 				: any (quoted) string
	%peg 			: any string validated by peg
	?				: any value
	{ k:v, k:v }	: structure
	{ k:v, *:v }	: structure, validate remaining fields against *
	{ v, v }		: list (exact match)
	{ v, ... }		: array (zero or more matches)
	\group\tag 		: collect and check against group rule
*/

/**
	PEGs
*/
integer				<-	intGroup _ ([-+*/] _ intGroup _)*
intGroup			<- 	('-' _)* ('(' _ integer ')' / [0-9]+ / '$') _
rectInt				<-	rectIntGroup _ ([-+*/] _ rectIntGroup _)*
rectIntGroup			<- 	('-' _)* ('(' _ rectInt ')' / [0-9]+ / [$tlwhrb]) _
float 				<-	floatGroup _ ([-+*/] _ floatGroup _)*
floatGroup			<-	('-' _)* ('(' _ float ')' / [0-9]+ ('.' [0-9]+)? / '$') _
_                 	<- 	[ \t\r\n]*
identifier 			<-	[a-zA-Z_$][a-zA-Z0-9_$.]*
hex32               <-  '0x' hex hex hex hex hex hex hex hex
hex                 <-  [0-9A-Fa-f]

/**
	Primitives
*/
<bool> = 'false'|'true'
<real> = *float
<percent> = <real>
<int> = *integer
<string> = %
<rect> = { *rectInt,*rectInt,*rectInt,*rectInt }
<var> = *identifier
<fps> = <int>
<secs> = <real>
<clickMask> = %
<action> = \actions\action
<params> = \actions\params
<cursorName> = %
<metaText> = %
<hex32> = *hex32
<chars> = %
<char> = %
<cursorNameWin> = %
<cursorNameMac> = %
<floatRect> = { <real>,<real>,<real>,<real> }

/*
"nop"|"reload"|"set"|"switch"|"batch"|"execute"|"alert"|"hint"|"popup"|"edit"|"launch"|"assert"
		|"changeParam"|"initPatch"|"copyPatch"|"pastePatch"|"exchangePatch"|"randomizePatch"|"openPatch"
		|"savePatch"|"choosePatch"|"switchPatch"|"chooseProgram"|"switchProgram"|"undo"|"redo"
		|"toggleVersionCheck"|"register"|"unitTest"*/

<actions> = <nop>|<set>|<switch>|<batch>|<popup>|<edit>|<launch>
				|<undo>|<redo>|<copyPatch>|<pastePatch>|<exchangePatch>|<randomizePatch>|<openPatch>|<savePatch>
				|<register>|<toggleVersionCheck>|<changeParam>

/**
	"nop" does nothing. Most useful to override default actions and stop clicks to pass through click view.
*/
<nop> = {
	action: "nop"
}

/**
    "reload" and reinitiate entire layout from disk.
*/
<reload> = {
    action: "reload"
}

/**
	"set" will be checked if <gui-variable> is (already) exactly <value>.
*/
<set> = {
    action: "set"
	params: { <var>, ? }
}

/**
	"switch" action
*/
<switch> = {
	action: "switch"
	params: {
		variable: <var>
		cases: {
			*: { <action>, [ <params> ] }
		}
		[ default: { <action>, [ <params> ] } ]
		[ checked: { ?, ... } ] // will be checked if variable is any of the values in the list
	}
}

/**
	A "batch" action will be enabled if any of its actions can be performed, but it will only be checked if all of its
	actions report checked state.
*/
<batch> = {
	action: "batch"
	params: {
		{ <action>, [ <params> ] }
		...
	}
}

/**
    Indirect execution of an action, action and / or params will be [var] expanded or may be retrieved from gui variables.
*/
<execute> = {
    action: "execute"
    params: {
        ( action: <action> | actionVariable: <var> )
        [ params: <params> | paramsVariable: <var> ]
    }
}

/**
	"popup" action

	TODO : in the future I don't think items should be text-processed,  it's just weird... the captions should be though. Text-processing is for UI texts.
	TODO : <var> items array, e.g. presetList[0].caption, presetList[0].action, presetList[0].params etc...
	TODO : Also, the entire "items" could be a gui-variable to be parsed instead
*/
<popup> = {
	action: "popup"
	params: {
		[
			offset: { <int>, <int> }
			| position: { <int>, <int> } 			// parent cushy-view coordiates
		]
		items: { 									// meta-text tags in items are processed before parsing, allowing group content
			{ <string>, <action>, [ <params> ] }	// notice: items with empty captions will be excluded from popup (but still counted by autoDisable and autoCheck)
			| '-'									// for divider
			...
		}
		[ storeAction: <var> ] 						// stores the chosen action into <var>, e.g. for use with "execute" action to repeat last command.
		[ storeParams: <var> ]
		[ autoDisable: <bool> ]						// will disable this action if all item actions are unavailable (i.e. grayed out)
		[ autoCheck: <bool> ] 						// will check this action if any item is checked
	}
}

/**
	"edit" action
*/
<edit> = {
	action: "edit"
	params: {
		// TODO : title: <window title>
		text: <metaText> 											// [var] expanded
		variable: <var>
		[ default: <metaText> /* default =[var]variable[/var] */ ] 	// [var] expanded
		[ reaction: { <action>, [ <params> ] } ]					// run on ok
	}
}

/**
	"launch" action
*/
<launch> = {
	action: "launch"
	params: <metaText> // file or url, [var] expanded, utf8 expected
}


/**
	"changeParam" either sets parameter to an absolute value ("to"), increases or decreases it by an amount ("by")
	or toggles between 0.0 and 1.0 ("toggle"). Automates changes in host. Do not prefix <name> with "params."
*/
<changeParam> = { action: "changeParam", params: { param: <string>, (to: <real> | by: <real> | toggle) } }

<undo> = { action: "undo" }
<redo> = { action: "redo" }
<copyPatch> = { action: "copyPatch" }				// copies patch to clipboard
<pastePatch> = { action: "pastePatch" }				// pastes patch from clipboard (if possible)
<exchangePatch> = { action: "exchangePatch" }		// exchanges patch <=> clipboard
<randomizePatch> = { action: "randomizePatch" }		// randomizes all parameters and name
<openPatch> = { action: "openPatch" }
<savePatch> = { action: "savePatch" }
<register> = { action: "register" }
<toggleVersionCheck> = { action: "toggleVersionCheck"}

/**
	Color spec
*/
<argb> = "aqua"|"black"|"blue"|"fuchsia"|"gray"|"green"|"lime"|"maroon"|"navy"|"olive"|"purple"|"red"|"silver"|"teal"|"white"|"yellow"|"transparent"
		| <hex32>		// pre-multiplied alpha (0xAARRGGBB), e.g. 0x80808080 is full white with 50% transparency
		| { <int>,<int>,<int>,<real> } // { r, g, b, a } where r, g, b are 0 -> 255 and a is 0.0 to 100.0 % (this is non-premultiplied syntax)

// Pen Style
<penStyle> =
	<argb> // stroke: 1, caps: butt, joints: bevel, quality: 1.0, no dashing
	|
	{
		color: <argb>
		stroke: <real>
		[ caps: "butt"|"round"|"square" ]
		[ (
			joints: "bevel"|"curve"
		) | (
			joints: "miter", [ miterLimit: <real> ]
		) ]
		[ quality: <real> ]			// default 1.0
		[ dash: "none"|<real> ]
		[ gap: <real> ]				// default = dash
		[ dashOffset: <real> ]		// max = dash + gap pixels
		// TODO : implement gamma
	}

/*

Image spec
==========

 Each unique image specification means a unique image in memory. The optional transformation specifiers (such as `gamma`
and `opacity`, but not `clip`) are "burned" into the image in memory. With the gamma tag you specify the desired
*target* gamma. I.e. 2.2 is good for PC. If source gamma value is found in image-file it will be used, otherwise a
source gamma of 2.2 will be assumed. If no gamma tag specified, no gamma conversion will be done.

 The `rle` variants (short for "run length encoded") are optimizations only. Bigger images with lots of transparency or
spans with identical pixel values will draw faster if the `rle` format is used. However, certain views (such as the
slider view) cannot use rle encoded images.

 If `clip` and/or `offset` is specified, at least one instance of the full picture will be loaded into memory (but
possibly shared). To calculate on the full source picture bounds you may use simple math expressions with the following
variables: '$', 'l', 't', 'w', 'h', 'r', 'b'. Notice that in case of UI scaling the loaded image will be scaled before
cropping and in case the clip rectangle is "unaligned" with the scaling factor this will cause misaligment and
"bleeding".

 `slices` (and `index`) is the way to go to get a single slice out of a "vertical film strip" (that has `slices` number
of frames). In this case, if UI scaling is active there will be no misalignment as with `clip`.

 (`clip` and `offset` cannot be used when specifying images for "films".)

*/

<image> = <string> | {
		name: <string>
		[format: "rle"|"mask"|"rlemask"]
		[gamma: <real>]
		[opacity: <percent>]
		[scale: <percent>]
		[pixelstrip: <int>]
		[slices: <int>, index: <int>]
		[clip: <rect>]
		[offset: { <int>, <int> }]
	}

<font> =
	{ [ face: <string> ], [size: <int>, bold: <bool>, italic: <bool>, underline: <bool>, color: <argb> /* no alpha! */ ] }
	|
	{ film: <image>, [ascent: <int> /* default: frame height */ ], [leading: <int>], [advance: <int>], [ (chars: <int>, first: <int>) | charset: <chars> ], [unknown: <char>] }
	|
	{ fnt: <string>, [color: <argb>], [gamma: <real>], [unknown: <char>] }
	|
	{ scfont: <string>, [scale: <int>], [submaps: <int>], [color: <argb> /* default: black */], [gamma: <real>], [unknown: <char>] }
	|
	{ ivgfont: <string>, [size: <real> /* default: 10 */], [color: <argb> /* default: black */], [gamma: <real>], [unknown: <char>] }

<root> = {
	bounds: <rect>
	[ autoRefresh: <fps> ]
	[ autoexecs: {
		{
			action: <action>
   		    [ params: <params> ]
			(
			  [ delay: <secs> ]
			  [ repeat: <secs> ]
			) | (
			  onChanged: ( <var> | { <var>, ... } )
			)
		}
		...
	} ]
	views: {
		<view>
		...
	}
}

<view> =	<subCushy>
			| <group>
			| <paged>
			| <transformed>
			| <caption>
			| <click>
			| <rectangle>
			| <raster>
			| <vector>
			| <button>
			| <slider>
			| <knob>

/*
	`cushy` can be used to dynamically inject a variable .cushy layout file
*/
<subCushy> = {
	type: "cushy"
	[ bounds: <rect> ]
	[ layoutVariable: <var>|<string> ]
	[ transitions: <bool> ]
	[ uiScaling: <bool> ]
}

/*
	 `group` can be used to simply group views together and offset them, or with the `varExpansion` option to create arbitrary view configurations in run-time
*/
<group> = {
	type: "group"
	[ bounds: <rect> ]
	[ autoRefresh: <fps> ]							// to have this view constantly update itself, e.g. for providing visual feedback.
	[ visibility: <bool>|<var> ]							// <var> should evaluate to "true" or "false" and shows / hides all sub-views (does not recreate views on change)
	[ offset: { <var>, <var> } ]					// sub-views are offsetted by this, changes do not recreate views
	(
		[ varExpansion: "false" ]
		views: { <view>, ... }
	) | (
		varExpansion: "true"							// can"t check views when varExpansion is in effect
		views: ?
	)
}

/*
	`paged` can be used to group views into pages that are shown one at a time.
*/
<paged> = {
	type: "paged"
	[ bounds: <rect> ]
	[ autoRefresh: <fps> ]							// to have this view constantly update itself, e.g. for providing visual feedback.
	index: <string>|<var>
	pages: {										// Notice that all pages are created on init, then shown / hidden as requested
		*: { <view>, ... }
	}
}

/*
	 If you just want to offset views, it is more efficient to use a group view. If you just want to change opacity of an image it (will in the future be) more efficient to use an animation view. You should also consider using a group view to change opacity if changes occur very rarely (will save a rendering pass).
	 If you just want to do transition animation, consider using the built-in transitions effects instead.
	 Also notice that transformed sub-views are actually rasterized first and then the resulting pixels are transformed.
	 Clicks on sub-views will be ignored (technical reason: we can"t do reliable mouse-tracking coordinate conversion with current view-system), but mouse-over (hints etc) work
*/			
<transformed> =	{
	type: "transformed"
	[ bounds: <rect> ]
	[ autoRefresh: <fps> ]							// to have this view constantly update itself, e.g. for providing visual feedback.
	[ opacity: <percent>|<var> ]
	[ scale: <percent>|<var> ]
	[ offset: { <var>, <var> } ]
	[ rotation: <real>|<var> ]							// degrees
	views: { <view>, ... }
}

<caption> =	{
	type: "caption"
	[ bounds: <rect> ]
	[ autoRefresh: <fps> ]							// to have this view constantly update itself, e.g. for providing visual feedback.
	[ font: <font> ]
	[
		align:	"left" | "center" | "right"
				| "top" | "middle" | "bottom"
				| "top left" | "top center" | "top right"
				| "middle left" | "middle center" | "middle right"
				| "bottom left" | "bottom center" | "bottom right"
	]
	[
		ellipsis: "none" | "left" | "right" | "both" | "middle"
		| ellipsis: { "none" | "left" | "right" | "both" | "middle", [<string>] }
	]
	[ offset: { <int>, <int> } ]
	text: <metaText> 									// Meta-text tags are processed (naturally).
}

<click> = {
	type: "click"									// Default click mask takes right-clicks too!!
	[ bounds: <rect> ]
	(
	  action: <action>
	  [ params: <params> ]
	  [ mask: <clickMask> ]							// See above
	) | (
	  actions: {
		{ <clickMask>, <action>, [ <params> ] }
		...
	  }
	)
	[ thru: <bool> ]
	[ hint: <metaText> ]								// Empty hint ("") is different from not declaring a hint at all since an empty hint blocks other hints from showing.
	[ 	// Cursor is only shown if action is enabled.
		cursor: <cursorName>|<var>
		| cursor: { [ windows: <cursorNameWin> ], [ mac: <cursorNameMac> ] }
	]
	[ mousePosition: <var> ] 						// will be updated to mouse position "<x>,<y>" on click and also continuously during mouse-tracking provided that there is an action defined with a matching "click mask" (can be "nop") *and* `thru` is false
}


<bubbleStyle> = {
	font: <font>
	[ offset: { <int>, <int> } ]
	[ frame: <penStyle>, [margin: <real>], [padding: <real>] ]
	[ lineHeight: <int> ]
	[ underline: <penStyle>, [offset: <real> ] ]
	[ typingRate: <real> ] 							// delay in secs per character
	[ align: "left" | "center" | "right" ]			// default: left
}

<bubble> = {
	type: "bubble"
	[ bounds: <rect> ] // initial bounds, can be changed with <move> tag in text
	[ fill: <argb> ]
	[ frame: <penStyle> ]
	[ margins: <rect> ]		// use negative values for right and bottom
	[ paddings: <rect> ]		// use negative values for right and bottom
	[ minHeight: <int> ]
	[ maxHeight: <int> ]
	[ corners: { <real>, <real> } ]
	[ tailSize: { <real>, <real> } ]
	[ tailPosition: <real> ]
	[ moveResize: { fps: <fps>, time: <secs>, curve: <real> } ]
	[ clickAction: <action>, [ clickParams: <params> ] ] // Notice that context-clicks are always "swallowed" by bubbles, standard clicks are not, so you need to specify `clickAction: nop` if you want standard clicks to not "go through".
	[ pageVariable: <int>|<var> ]
	[ typingRateVariable: <real>|<var> ] // <var> != void -> force this typing rate

	/*
		Valid tags are:
		
		<(style-name)> </(style-name)>
		<click action="(action)" params="(params)" [auto=<bool>]> </click>		// if auto is true, the action will be performed once when the word is shown (just like "do").
		<do action= params= /> 
		<move bounds="{ l, t, w, h }" [time=secs] [curve=] />		// curve value is from 0.0 to 1.0, 0.5 = linear, < 0.5 = slow start, > 0.5 = quick start
		<pause delay=secs />
		<br>
		
		Valid special chars are:
		
		&lt;
		&gt;
		&nbsp;
		&nbhp; (= no-break-hyphen)
	*/
	pages: {
		<metaText>,	// will be processed by the standard meta-text tag processor
		...
	}

	styles: {
		default: <bubbleStyle>
		*: <bubbleStyle>
	}
	// TODO : option to refresh bubble if any [var] changes
}

<rectangle> = {
	type: "rectangle"
	[ bounds: <rect> ]
	[ fill: <argb> ]
	[ rounded: <percent> /* =0 */ | { <real>, <real> } ]			// 100 percent = full ellipse form
	[ blend: "add" | "multiply" | "normal" ]
	[ opacity: <percent> ]
	[ frame: <penStyle> ]
}

<raster> = {
	type: "raster"
	[ bounds: <rect> ]
	image: <image>
	[ blend: "add" | "multiply" | "normal" ]
	[ opacity: <percent> ]
	[ frame: <penStyle> ]
}

<vector> = {
	type: "vector"
	[ bounds: <rect> ]
	( source: <string>
	| variable: <var>
	| file: <string>	// no extension
	)
	[ autoRefresh: <fps> ]
	[ guiVariables: <bool> ] // = false // allow access to GUI variables from IVG source (with standard $<variable-name>). Will automatically refresh on change to any of variable accessed during last re-paint. Notice that $ expansion in IMPD can be recursive, e.g. `x=[$x]; $x`. Thus, `source: $var` cannot be "safe" against arbitrary variable access by $var, but `variable: var` can be.
	[ scale: <percent> ] 
	[ blend: "add" | "multiply" | "normal" ]
	[ opacity: <percent> ]
	[
		defines: {
			{ <var>, ? }
			...
		}
	]
	// todo: param mapping so that one can reuse ivg file with different params
	// todo: animation support
}

<button> = {													// Default click mask is the standard button behavior, i.e. action on mouse-release within hit-box.
	type: "button"
	[ bounds: <rect> ]
	(
        action: <action>
        [ params: <params> ]
        [ mask: <clickMask> ]						// See above
	) | (
        actions: {
            { <clickMask>, <action>, [ <params> ] }
            ...
        }
	)
	[ caption: <metaText> | { text: <metaText>, offset: { <int>, <int> } } ]
	[ hint: <metaText> ]										// Empty hint ("") is different from not declaring a hint at all since an empty hint blocks other hints from showing.
	[ rounded: <percent> /* =0 */ | { <real>, <real> } ]			// 100 percent = full ellipse form
	[ 	// Cursor is only shown if action is enabled.
		cursor: <cursorName>|<var>
		| cursor: { [ windows: <cursorNameWin> ], [ mac: <cursorNameMac> ] }
	]
	[ standard:    { [ image: <image> ], [ fill: <argb> ], [ frame: <penStyle> ], [ font: <font> ], [ icon: <image> ], [ rect: <floatRect> ] } ] // "rect" adjusts the click rect and framed outline.
	[ checked:     { [ image: <image> ], [ fill: <argb> ], [ frame: <penStyle> ], [ font: <font> ], [ icon: <image> ], [ rect: <floatRect> ] } ] // Omitted attributes are "inherited" from "standard".
	[ down:        { [ image: <image> ], [ fill: <argb> ], [ frame: <penStyle> ], [ font: <font> ], [ icon: <image> ], [ rect: <floatRect> ] } ] // Omitted attributes are "inherited" from "standard".
	[ checkedDown: { [ image: <image> ], [ fill: <argb> ], [ frame: <penStyle> ], [ font: <font> ], [ icon: <image> ], [ rect: <floatRect> ] } ] // Omitted attributes are "inherited" from "checked".
	[ disabled:    { [ image: <image> ], [ fill: <argb> ], [ frame: <penStyle> ], [ font: <font> ], [ icon: <image> ], [ rect: <floatRect> ] } ] // Omitted attributes are "inherited" from "standard".
}

<slider> = {
	type: "slider"
	[ bounds: <rect> ]
	[ hint: <metaText> ]								// Empty hint ("") is different from not declaring a hint at all since an empty hint blocks other hints from showing.
	[ readonly: <bool> ]						// also depends on whether gui-variable is editable or not
	[ autoRefresh: <fps> ]							// to have this view constantly update itself, e.g. for providing visual feedback with a "readonly" slider. For parameter sliders this is rarely necessary as any parameter changes will trigger a global refresh.
	[ range: { <real>, <real> } ]	// default is 0.0 to 1.0
	[ default: <real> ]
	[ variable: <var> ]
	cap: {
		size: { <real>, <real> }
		// Only supports rounded: 0 and rounded: 100 right now
		[ rounded: <percent> ] // = 0%  // TODO: | { <real>, <real> } ]						// 100 percent = full ellipse form
		[ color: <argb> ] // = black
		[ image: <image>, scale: <percent> ]
	}
	[ film: {										// film frame (corresponding to the current value) is drawn beneath the cap (but above the slit)
		image: <image>
		frames: <int>
		[interpolate: <bool>]
		[offset: { <int>, <int> } ]
	} ]
	[ slit: {
		( start: { <real>, <real> }, end: { <real>, <real> } )			// linear slider
		| ( center: { <real>, <real> }, radius: <real>, sweep: { <real>, <real> /* length in angles */ } )	// arced slider
		[ thickness: <real> ]	// = 4
		[ color: <argb> ]	// = black
		// TODO: [ fill: <argb>=0 ]					// fills "up to" the cap
	} ]
	[ snap: <bool> | {
		[ value: <real> ]	// = default
		[ area: <real> ]	// = 4 pixels
		[ color: <argb> ]
		[ image: <image> ]
	} ]
	// TODO: [ quickJump: (true|false)=true ]		// support for "quick jump" = click outside cap to move slider directly to that position
	[ fineRatio: <real> ]	// =10%				// shift-dragging precision
}

<knob> = {
	type: "knob"
	[ hint: <metaText> ]								// Empty hint ("") is different from not declaring a hint at all since an empty hint blocks other hints from showing.
	[ readonly: <bool> ]				// also depends on whether gui-variable is editable or not
	[ autoRefresh: <fps> ]							// to have this view constantly update itself, e.g. for providing visual feedback with a "readonly" knob. For parameter knobs this is rarely necessary as any parameter changes will trigger a global refresh.
	[ range: { <real>, <real> } ]	// default is 0.0 to 1.0
	// TODO: [ wrap: <bool> ]
	[ default: <real> ]
	[ variable: <var> ]
	[ sweep: { <real>, <real> /* length in angles, default is -135 + 270 */ } ]
	[ cap: {
		[ size: <real> ]
		[ offset: { <real>, <real> } ]
		[ color: <argb> ]
		[ frame: <penStyle> ]
		[ dial: <penStyle> ]
		[ image: <image>, [ scale: <percent> ], [ angle: <real> ] ]
	} ]
	[ film: {										// film frame (corresponding to the current value) is drawn beneath the cap
		image: <image>
		frames: <int>
		[ range: { <real>, <real> } ] // Define min and max angle in film. Default matches "sweep".
		[ interpolate: <bool> ]
		[ offset: { <int>, <int> } ]
	} ]
	[ snap: <bool> | {
		[ value: <real> ]	// = default
		[ area: <real> ]	// = 4 pixels
		[ color: <argb> ]
		[ frame: <penStyle> ]
		[ dial: <penStyle> ]
	} ]
	[ transmission: {
		[ resolution: <real> /* =1 */ ] // smallest mouse movement counted
		// TODO : snapping is kind of broken now if you have diff horizontal and vertical transmission, e.g. slow horizontal transmission compared to vertical means it will stay at snapping point much longer.
		[ vertical: <real> /* =200 */ ] // number of pixels for full range, 0 = vertical movement ignored
		[ horizontal: <real> /* =200 */ ] // number of pixels for full range, 0 = horizontal movement ignored
		[ fine: <percent> /* =10% */ ] // the fine rate (in percent) for shift-key adjustements
	} ]
}