#! /usr/local/bin/PikaCmd

include('stdlib.pika');
include('systools.pika');
include.addSearchPath('lab');
include('toC.pika');

FUNCTION_TEMPLATE_ZERO_TERMINATED = '
/* Built with QuickHashMaker.pika */
static int --{functionName}--(int n /* string length */, const char* s /* zero-terminated string */) {
	static const char* STRINGS[--{stringCount}--] = {
		--{stringList}--
	};
	static const int QUICK_HASH_TABLE[--{tableSize}--] = {
		--{tableData}--
	};
	if (n < --{minLength}-- || n > --{maxLength}--) return -1;
	int stringIndex = QUICK_HASH_TABLE[--{hashExpression}--];
	return (stringIndex >= 0 && strcmp(s, STRINGS[stringIndex]) == 0) ? stringIndex : -1;
}
';

FUNCTION_TEMPLATE_GENERIC = '
/* Built with QuickHashMaker.pika */
static int --{functionName}--(int n /* string length */, const char* s) {
	static const char* STRINGS[--{stringCount}--] = {
		--{stringList}--
	};
	static const int QUICK_HASH_TABLE[--{tableSize}--] = {
		--{tableData}--
	};
	if (n < --{minLength}-- || n > --{maxLength}--) return -1;
	int stringIndex = QUICK_HASH_TABLE[--{hashExpression}--];
	return (stringIndex >= 0 && strncmp(s, STRINGS[stringIndex], n) == 0 && STRINGS[stringIndex][n] == 0) ? stringIndex : -1;
}
';

print('One string per line or many enclosed in " ". Finish with empty line.');

prune(@gotIt);
strings.n = 0;
for (; { s = input(''); s != '' };) {
	for (; s != ''; ) {
		if (s{i = span(s, " \t"):}{0} == '"') {
			word = unescape(s{:i=parse(s=s{i:}, true)});
			s = s{find(s=s{i:}, '"'):};
		} else {
			word = s;
			s = '';
		};
		if (exists(@gotIt[word])) throw('Duplicate string!');
		gotIt[word] = true;
		append(@strings, word);
	}
};
zeroTerminated = (lower(input('Input is zero terminated (y)? '){0}) != 'n');
allowMultiplication = (lower(input('Allow * (n)? '){0}) == 'y');
tryCount = pow(10, +coalesce(input('Try how hard (5)? '), 5));
findCount = +coalesce(input('Find how many (3)? '), 3);
functionName = coalesce(input('Function name (<<<findsomething>>>)? '), '<<<findsomething>>>');

maxLength = 0;
minLength = 10000000;
iterate(@strings, >{ minLength = min(length($2), minLength); maxLength = max(length($2), maxLength) });
print(bake('Lengths: {minLength} to {maxLength}'));
allowedLength = (if (zeroTerminated) minLength else minLength - 1);

paddedStrings.n = strings.n;
iterate(@strings, >paddedStrings[$1] = $2 # repeat("\0", maxLength - length($2)));

intRandom = function { trunc(random($0 - 0.00000001)); };
o = function { ordinal(w{$0}) };
if (!allowMultiplication) {
	compose(@OPS
			, function { if ((j = intRandom(l)) > allowedLength) [$1]++; '(' # $0 # ' ^ o(' # j # '))' }
			, function { if ((j = intRandom(l)) > allowedLength) [$1]++; $0 # ' + o(' # j # ')' }
			, function { if ((j = intRandom(l)) > allowedLength) [$1]++; $0 # ' - o(' # j # ')' }
			, function { '(' # $0 # ' ^ ' # intRandom(65536) # ')' }
			, function { $0 # ' + ' # intRandom(65536) }
			, function { '(' # $0 # ' << ' # intRandom(8) # ')' }
			, function { '(' # $0 # ' >> ' # intRandom(8) # ')' }
			, function { '(' # $0 # ' ^ n)' }
			, function { $0 # ' + n' }
			, function { $0 # ' - n' });
} else {
	compose(@OPS
			, function { if ((j = intRandom(l)) > allowedLength) [$1]++; '(' # $0 # ' ^ o(' # j # '))' }
			, function { if ((j = intRandom(l)) > allowedLength) [$1]++; '(' # $0 # ' + o(' # j # '))' }
			, function { if ((j = intRandom(l)) > allowedLength) [$1]++; '(' # $0 # ' - o(' # j # '))' }
			, function { if ((j = intRandom(l)) > allowedLength) [$1]++; [$1]++; '((' # $0 # ' & 0xFFFF) * o(' # j # '))' }
			, function { '(' # $0 # ' ^ ' # intRandom(65536) # ')' }
			, function { '(' # $0 # ' + ' # intRandom(65536) # ')' }
			, function { '(' # $0 # ' << ' # intRandom(8) # ')' }
			, function { '(' # $0 # ' >> ' # intRandom(8) # ')' }
			, function { '((' # $0 # ' & 0xFFFF) * ' # intRandom(65536) # ')' }
			, function { '(' # $0 # ' ^ n)' }
			, function { '(' #$0 # ' + n)' }
			, function { '(' #$0 # ' - n)' }
			, function { [$1]++; '((' #$0 # ' & 0xFFFF) * n)' });
};

makeRandomHashFunction = function {
    args(@complexity);
	for (; {
		i = 1;
		if (random(2) < 1) s = 'n'
		else {
			j = intRandom(l);
			s = 'o(' # j # ')';
			if (j > allowedLength) i++;
		};
		for (; i < complexity; ++i) s = OPS[intRandom(OPS.n)](s, @i);
		( i > complexity )
	}; );
	( s )
};

for (minSize = 1; strings.n > minSize; minSize <<= 1) ;
maxSize = minSize * 4;
counter = 1;
fill(@s, 0, maxSize, 0);

prune(@tried);

l = maxLength;
for ({ complexity = 1; foundCount = 0 }; foundCount < findCount; ++complexity) {
	print(bake('--- Trying complexity: {complexity}'));
	
	for (size = minSize; foundCount < findCount && size <= maxSize; size <<= 1) {
		print(bake('--- Trying size: {size}'));
		mask = size - 1;
		
		for (i = 0; foundCount < findCount && i < tryCount; ++i) {
			f = '{ (' # makeRandomHashFunction(complexity) # ') & ' # mask # ' }';
			if (!exists(@tried[f])) {
				tried[f] = true;
				bad = false;
				
				for (j = 0; !bad && j < strings.n; ++j) {
					w = paddedStrings[j];
					n = length(strings[j]);
					idx = f();
					if (s[idx] == counter) bad = true;
					s[idx] = counter;
				};
				
				counter++;
				
				if (!bad) {
					++foundCount;
					expr = f{2:length(f)-4};
					for (j = 0; j <= allowedLength; ++j) {
						expr = replace(expr, 'o(' # j # ')', 's[' # j # ']');
					};
					for (; j <= maxLength; ++j) {
						expr = replace(expr, 'o(' # j # ')', bake('({j} < n ? s[{j}] : 0)'));
					};
					a.n = size;
					fill(@a, 0, size, -1);
					for (j = 0; j < strings.n; ++j) {
						w = paddedStrings[j];
						n = length(strings[j]);
						idx = f();
						a[idx] = j;
					};
					
					map(@replaceMap
							, 'functionName', >functionName
							, 'minLength', >minLength
							, 'maxLength', >maxLength
							, 'stringCount', >strings.n
							, 'stringList', >stringListToC(@strings, 80, pre)
							, 'tableSize', >size
							, 'tableData', >numberListToC(@a, 16, 0, pre)
							, 'hashExpression', >expr);
					in = (if (zeroTerminated) FUNCTION_TEMPLATE_ZERO_TERMINATED else FUNCTION_TEMPLATE_GENERIC);
					out = '';
					for (; in !== ''; ) {
						out #= in{:(i = search(in, '--{'))};
						if ((in = in{i:}) !== '') {
							pre = out{rfind(out, "\n\r")+1:};
							i = search(in{3:}, '}--');
							out #= replaceMap[in{3:i}]();
							in = in{3+i+3:};
						}
					};
					print(out);
				}
			}
		}
	}
}

